<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAMO TrafficApp</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { background-color: #f8f9fa; }
        #map { height: calc(60vh - 60px); border-radius: 8px; width: 100%; }
        .sidebar { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); max-height: calc(100vh - 120px); overflow-y: auto; }
        .tour-card-layout { display: flex; flex-direction: column; }
        @media (min-width: 768px) { .tour-card-layout { flex-direction: row; } }
        .tour-list-column { flex: 0 0 320px; padding: 1rem 1.5rem 1rem 0; border-right: 1px solid #dee2e6; }
        @media (max-width: 767.98px) {
            .tour-list-column { border-right: none; border-bottom: 1px solid #dee2e6; padding: 1rem 1.5rem; }
        }
        .tour-details-column { flex: 1 1 auto; padding: 1rem 1.5rem; }
        .tour-card-layout .list-group-item { border-radius: 0; }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
        <div class="container-fluid">
            <a class="navbar-brand" href="/">FAMO TrafficApp</a>
            
            <!-- Navigation Links -->
            <div class="navbar-nav me-auto">
                <a class="nav-link active" href="/">Hauptseite</a>
                <a class="nav-link" href="/ui/tourplan-management">Tourplan Management</a>
                <a class="nav-link" href="/ui/tourplan-visual-test">Visual Test</a>
                <a class="nav-link" href="/docs">API Docs</a>
            </div>
            
            <!-- Status Indicators -->
            <div class="navbar-nav">
                <span class="navbar-text me-3">
                    <i class="fas fa-circle text-success"></i> Server online
                    </span>
                <span class="navbar-text me-3" id="llmStatus">
                    <i class="fas fa-circle text-warning"></i> LLM pr√ºfe...
                </span>
                <span class="navbar-text" id="dbStatus">
                    <i class="fas fa-database text-info"></i> DB pr√ºfe...
                </span>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
            <div class="sidebar" id="workflowSidebar">
                <h5><i class="fas fa-project-diagram"></i> Workflow</h5>
                <div id="workflowStatus" class="small text-muted mb-3">Noch kein Upload.</div>

                <h5><i class="fas fa-upload"></i> CSV / Workflow</h5>
        <div class="mb-2">
            <label for="csvFile" class="form-label">CSV-Datei ausw√§hlen:</label>
            <input type="file" id="csvFile" class="form-control" accept=".csv,text/csv" onchange="handleFileChange()">
            
            <!-- Upload Status -->
            <div id="uploadInfo" class="small text-muted mt-2"></div>
        </div>
                <button class="btn btn-success w-100" onclick="runWorkflow()">
                    <i class="fas fa-cogs"></i> Kompletter Workflow (Parse + Geocode + Optimize)
                </button>

                <h5 class="mt-3"><i class="fas fa-route"></i> Touren generieren</h5>
                <a href="multi-tour-generator.html" class="btn btn-outline-secondary w-100 mb-3">
                    <i class="fas fa-route"></i> Multi-Tour Generator
                </a>
            </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <div class="card mb-3">
                    <div class="card-header">
                        <h4><i class="fas a-map"></i> Karte</h4>
                    </div>
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h4><i class="fas fa-route"></i> Tour√ºbersicht</h4>
                        <div class="small text-muted" id="tourSummary">Keine Daten</div>
                    </div>
                    <div class="card-body tour-card-layout">
                        <div class="tour-list-column">
                            <div id="tourList" class="list-group list-group-flush"></div>
                        </div>
                        <div class="tour-details-column">
                            <div id="tourDetails" class="border rounded p-3 bg-light h-100">
                                <div class="text-center text-muted py-4">
                                    <i class="fas fa-info-circle"></i><br>
                                    Noch keine Tourdaten. CSV hochladen oder Workflow starten.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let parsedData = null;
        let workflowResult = null;
        let activeTourKey = null;
        let allTourCustomers = {};
        let tourMarkers = [];
        let currentFilename = null;
        let geoCache = {};

        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM geladen, starte...');
            initializeMap();
            loadStatusData();
        });

        // Karte initialisieren
        function initializeMap() {
            console.log('Initialisiere Karte...');
            
            if (typeof L === 'undefined') {
                console.error('Leaflet nicht geladen!');
                return;
            }
            
            try {
                // Karte auf FAMO Standort zentrieren (Gittersee)
                map = L.map('map').setView([51.01127, 13.70161], 15);
                console.log('Karte erstellt');
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
                
                // FAMO Dresden Marker - Korrekte Position (rotes Kreuz)
                L.marker([51.01127, 13.70161]).addTo(map)
                    .bindPopup('<b>üè≠ FAMO Dresden</b><br>Stuttgarter Str. 33<br>01189 Dresden<br><br>üè≠ Industriegebiet Gittersee')
                    .openPopup();
                
                console.log('Karte erfolgreich initialisiert!');
            } catch (error) {
                console.error('Fehler beim Initialisieren der Karte:', error);
            }
        }

        function updateWorkflowStatus(message) {
            document.getElementById('workflowStatus').innerHTML = message;
        }

        function handleFileChange() {
            const input = document.getElementById('csvFile');
            const status = document.getElementById('workflowStatus');
            const uploadInfo = document.getElementById('uploadInfo');
            
            if (!input.files || !input.files.length) {
                currentFilename = null;
                status.innerHTML = 'Noch kein Upload.';
                status.className = 'small text-muted mb-3';
                uploadInfo.innerHTML = '';
                return;
            }
            
            const file = input.files[0];
            currentFilename = file.name;
            
            // Upload √ºber neue API
            uploadCsvFile(file);
        }

        // Neue Upload-API Funktionen
        async function apiUploadCsv(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch('/api/upload/csv', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload fehlgeschlagen: ${errorText}`);
            }
            
            return response.json();
        }

        async function uploadCsvFile(file) {
            const uploadInfo = document.getElementById('uploadInfo');
            const status = document.getElementById('workflowStatus');
            
            // Upload-Status anzeigen
            uploadInfo.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Lade hoch: ${file.name} (${(file.size/1024).toFixed(1)} KB)`;
            uploadInfo.className = 'small text-info mt-2';
            
            try {
                // Upload √ºber API
                const result = await apiUploadCsv(file);
                
                // Erfolg anzeigen
                uploadInfo.innerHTML = `<i class="fas fa-check text-success"></i> Upload erfolgreich: ${result.staging_file}`;
                uploadInfo.className = 'small text-success mt-2';
                
                // Workflow-Status aktualisieren
                status.innerHTML = `<span class="text-success">‚úì Datei hochgeladen: ${file.name}</span>`;
                status.className = 'small text-success mb-3';
                
                // Automatisch Match starten
                await loadMatchForFile(result.staging_file);
                
            } catch (error) {
                console.error('Upload-Fehler:', error);
                uploadInfo.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> Fehler: ${error.message}`;
                uploadInfo.className = 'small text-danger mt-2';
                
                status.innerHTML = `<span class="text-danger">‚úó Upload fehlgeschlagen: ${error.message}</span>`;
                status.className = 'small text-danger mb-3';
            }
        }

        async function loadMatchForFile(filePath) {
            try {
                const url = '/api/tourplan/match?file=' + encodeURIComponent(filePath);
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Match-API Fehler: ${response.status} - ${errorText}`);
                }
                
                const matchData = await response.json();
                
                // Match-Daten verarbeiten (bestehende Logik)
                if (matchData.items && matchData.items.length > 0) {
                    updateWorkflowStatus(`‚úì Match erfolgreich: ${matchData.items.length} Adressen verarbeitet`);
                    // Hier k√∂nnte die Karte/Tabelle aktualisiert werden
                    console.log('Match-Daten:', matchData);
                } else {
                    updateWorkflowStatus('‚ö† Match: Keine Adressen gefunden');
                }
                
            } catch (error) {
                console.error('Match-Fehler:', error);
                updateWorkflowStatus(`‚úó Match fehlgeschlagen: ${error.message}`);
            }
        }


        // Daten aktualisieren
        async function runWorkflow() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Bitte w√§hlen Sie eine CSV-Datei aus.');
                return;
            }

            try {
                updateWorkflowStatus('<span class="text-info">Workflow wird ausgef√ºhrt...</span>');

                const formData = new FormData();
                formData.append('file', file);

                const response = await fetch(`/api/tourplan/match?file=./tourplaene/${encodeURIComponent(file.name)}`, {
                    method: 'GET'
                });

                let data;
                try {
                    data = await response.json();
                } catch (e) {
                    const errorText = await response.text();
                    console.error("JSON Parsing Fehler:", e, "Rohe Antwort:", errorText);
                    updateWorkflowStatus(`<span class="text-danger">Workflow fehlgeschlagen: Ung√ºltige Server-Antwort (${response.status}). Details: ${errorText.substring(0, 100)}...</span>`);
                    return; 
                }

                if (response.ok && data.items && data.items.length > 0) {
                    workflowResult = data;
                    parsedData = null;
                    renderToursFromMatch(data);
                    updateWorkflowStatus(`<span class="text-success">Workflow erfolgreich. ${data.ok} OK, ${data.warn} Warn, ${data.bad} Bad</span>`);
                } else {
                    updateWorkflowStatus(`<span class="text-danger">Workflow fehlgeschlagen: ${data.error || data.detail || 'Keine Touren gefunden'}</span>`);
                }
            } catch (error) {
                console.error('Workflow Fehler:', error);
                updateWorkflowStatus('<span class="text-danger">Workflow Fehler. Details in der Konsole.</span>');
            }
        }

        // Status-Daten laden (LLM + DB)
        async function loadStatusData() {
            try {
                // LLM-Status: Offline (nicht implementiert)
                updateLLMStatus({available: false, provider: 'offline'});
                
                // DB-Status abfragen
                const dbResponse = await fetch('/health/db');
                const dbData = await dbResponse.json();
                updateDBStatus(dbData);
            } catch (error) {
                console.error('Fehler beim Laden der Status-Daten:', error);
                updateLLMStatus({available: false, provider: 'offline'});
                updateDBStatus({status: 'offline', error: error.message});
            }
        }

        // LLM-Status aktualisieren
        function updateLLMStatus(data) {
            const llmStatus = document.getElementById('llmStatus');
            if (data.available) {
                llmStatus.innerHTML = `<i class="fas fa-circle text-success"></i> LLM ${data.provider}`;
                } else {
                llmStatus.innerHTML = `<i class="fas fa-circle text-danger"></i> LLM offline`;
            }
        }

        // DB-Status aktualisieren
        function updateDBStatus(data) {
            const dbStatus = document.getElementById('dbStatus');
            if (data.status === 'online') {
                dbStatus.innerHTML = `<i class="fas fa-database text-success"></i> DB online (${data.tables || ''} Tabellen)`;
            } else {
                dbStatus.innerHTML = `<i class="fas fa-database text-danger"></i> DB offline`;
            }
        }

        // CSV Tour Processor
        async function processAllCSV() {
            try {
                console.log('Starte CSV Tour Processing...');
                
                const response = await fetch('/api/tourplan/bulk-process-all', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('CSV Tour Processing erfolgreich:', result);
                    alert(`[OK] CSV Tour Processing erfolgreich!\n\n` +
                          `Kunden verarbeitet: ${result.total_customers || 0}\n` +
                          `Eindeutige Kunden: ${result.unique_customers || 0}\n` +
                          `In DB gespeichert: ${result.saved_customers || 0}\n` +
                          `Touren gefunden: ${result.tours_found || 0}\n` +
                          `Touren gespeichert: ${result.saved_tours || 0}\n` +
                          `BAR-Touren: ${result.bar_tours || 0}\n` +
                          `Normale Touren: ${result.normal_tours || 0}\n` +
                          `Geocoding Erfolg: ${result.geocoding_success || 0}\n` +
                          `Geocoding Fehler: ${result.geocoding_failed || 0}\n` +
                          `Geocoding Rate: ${result.geocoding_rate || '0%'}\n` +
                          `Dateien verarbeitet: ${result.files_processed || 0}`);
                    await refreshData();
                } else {
                    const error = await response.text();
                    console.error('Fehler beim CSV Tour Processing:', error);
                    alert(`[FEHLER] Fehler beim CSV Tour Processing:\n${error}`);
                }
            } catch (error) {
                console.error('Fehler beim CSV Tour Processing:', error);
                alert(`[FEHLER] Fehler beim CSV Tour Processing:\n${error.message}`);
            }
        }

        // Touren-Details laden
        function renderToursFromParsedData() {
            if (!parsedData || !parsedData.tours) {
                renderEmptyTours();
                return;
            }

            // Touren nach Zeit sortieren
            const tours = (parsedData.tours || []).filter(passFilter);
            
            // Sortierung nach Zeit hinzuf√ºgen
            tours.sort((a, b) => {
                const timeA = extractTime(a.time || a.name || '');
                const timeB = extractTime(b.time || b.name || '');
                return timeA - timeB; // Aufsteigende Sortierung
            });

            if (!tours.length) {
                renderEmptyTours();
                return;
            }

            document.getElementById('tourSummary').textContent = `${tours.length} Touren ¬∑ ${parsedData.stats?.total_customers || 0} Kunden`;

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = tours.map((tour, index) => {
                const key = `parsed-${index}`;
                const barCount = tour.customers.filter(c => c.bar_flag).length;
                const badge = barCount ? `<span class="badge bg-warning text-dark ms-2">${barCount} BAR</span>` : '';
                const normalizedCustomers = tour.customers.map(customer => ({
                    customer_number: customer.customer_number,
                    name: customer.name,
                    street: customer.street,
                    postal_code: customer.postal_code,
                    city: customer.city,
                    bar_flag: customer.bar_flag,
                    latitude: customer.latitude,
                    longitude: customer.longitude,
                    address: customer.resolved_address || customer.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [customer.street, customer.postal_code, customer.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '';
                })()
                }));

                allTourCustomers[key] = {
                    name: tour.name,
                    type: tour.tour_type,
                    time: tour.time,
                    customers: normalizedCustomers
                };
                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${tour.name}</strong>${badge}
                                <div class="small text-muted">${tour.customer_count} Kunden ¬∑ ${tour.tour_type} ¬∑ ${tour.time || 'Zeit n/a'}</div>
                            </div>
                            <span class="badge bg-primary rounded-pill">${tour.customer_count}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = tours.length ? `parsed-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        // Hilfsfunktion zum Extrahieren der Zeit aus Tour-Namen
        function extractTime(timeString) {
            if (!timeString) return 9999; // Fallback f√ºr Touren ohne Zeit
            
            // Suche nach Zeit-Pattern: HH.MM oder HH:MM
            const timeMatch = timeString.match(/(\d{1,2})[.:](\d{2})/);
            if (timeMatch) {
                const hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                return hours * 60 + minutes; // Minuten seit Mitternacht
            }
            
            return 9999; // Fallback f√ºr unbekannte Formate
        }

        // Rendert Touren basierend auf der urspr√ºnglichen CSV-Struktur
        function renderToursFromCSVStructure(matchData, fileName) {
            console.log('renderToursFromCSVStructure aufgerufen, matchData:', matchData);
            
            const items = matchData.items || [];
            if (!items.length) {
                console.log('Keine Items gefunden in matchData');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${items.length} Items aus CSV-Struktur`);
            document.getElementById('tourSummary').textContent = `${matchData.ok} OK, ${matchData.warn} Warn, ${matchData.bad} Bad`;

            // Gruppiere Items nach Tour-Zeit basierend auf der urspr√ºnglichen CSV-Struktur
            const tours = {};
            let currentTour = null;
            
            items.forEach((item, index) => {
                // Erkenne Tour-Zeilen basierend auf dem display_name
                const displayName = item.display_name || '';
                
                if (displayName.includes('Tour') || displayName.includes('BAR') || displayName.includes('Anlief')) {
                    // Das ist eine Tour-Zeile
                    currentTour = displayName;
                    if (!tours[currentTour]) {
                        tours[currentTour] = {
                            name: currentTour,
                            customers: [],
                            isBarTour: displayName.includes('BAR'),
                            time: extractTimeFromTourName(displayName)
                        };
                    }
                } else if (currentTour && displayName.trim()) {
                    // Das ist ein Kunde f√ºr die aktuelle Tour
                    tours[currentTour].customers.push({
                        customer_number: item.customer_number || item.id || '',
                        name: displayName,
                        street: item.resolved_address || '',
                        postal_code: '',
                        city: '',
                        bar_flag: tours[currentTour].isBarTour,
                        latitude: item.lat,
                        longitude: item.lon,
                        address: item.resolved_address || '',
                        status: item.status
                    });
                }
            });

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = Object.values(tours).map((tour, index) => {
                const key = `csv-${index}`;
                const customerCount = tour.customers.length;
                const okCount = tour.customers.filter(c => c.status === 'ok').length;
                const warnCount = tour.customers.filter(c => c.status === 'warn').length;
                const badCount = tour.customers.filter(c => c.status === 'bad').length;
                const barBadge = tour.isBarTour ? `<span class="badge bg-warning text-dark ms-2">BAR</span>` : '';
                
                allTourCustomers[key] = tour;

                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${tour.name}</strong>${barBadge}
                                <div class="small text-muted">${okCount} OK, ${warnCount} Warn, ${badCount} Bad</div>
                            </div>
                            <span class="badge bg-primary rounded-pill">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = Object.keys(tours).length ? `csv-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        // Hilfsfunktion zum Extrahieren der Zeit aus Tour-Namen
        function extractTimeFromTourName(tourName) {
            const timeMatch = tourName.match(/(\d{1,2})[.:](\d{2})/);
            if (timeMatch) {
                return `${timeMatch[1]}:${timeMatch[2]}`;
            }
            return tourName;
        }

        // Rendert Touren aus dem Match-Endpunkt - EINFACH
        function renderToursFromMatch(matchData) {
            console.log('renderToursFromMatch aufgerufen, matchData:', matchData);
            
            const items = matchData.items || [];
            if (!items.length) {
                console.log('Keine Items gefunden in matchData');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${items.length} Items aus Match`);
            document.getElementById('tourSummary').textContent = `${matchData.ok} OK, ${matchData.warn} Warn, ${matchData.bad} Bad`;

            // Gruppiere Items nach Tour-Zeit basierend auf der urspr√ºnglichen CSV-Struktur
            const tours = {};
            let currentTour = null;
            
            items.forEach((item, index) => {
                // Erkenne Tour-Zeilen basierend auf dem display_name
                const displayName = item.display_name || '';
                
                if (displayName.includes('Tour') || displayName.includes('BAR') || displayName.includes('Anlief')) {
                    // Das ist eine Tour-Zeile
                    currentTour = displayName;
                    if (!tours[currentTour]) {
                        tours[currentTour] = {
                            name: currentTour,
                            customers: [],
                            isBarTour: displayName.includes('BAR'),
                            time: extractTimeFromTourName(displayName)
                        };
                    }
                } else if (currentTour && displayName.trim()) {
                    // Das ist ein Kunde f√ºr die aktuelle Tour
                    tours[currentTour].customers.push({
                        customer_number: item.customer_number || item.id || '',
                        name: displayName,
                        street: item.resolved_address || '',
                        postal_code: '',
                        city: '',
                        bar_flag: tours[currentTour].isBarTour,
                        latitude: item.lat,
                        longitude: item.lon,
                        address: item.resolved_address || '',
                        status: item.status
                    });
                }
            });

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = Object.values(tours).map((tour, index) => {
                const key = `match-${index}`;
                const customerCount = tour.customers.length;
                const okCount = tour.customers.filter(c => c.status === 'ok').length;
                const warnCount = tour.customers.filter(c => c.status === 'warn').length;
                const badCount = tour.customers.filter(c => c.status === 'bad').length;
                const barBadge = tour.isBarTour ? `<span class="badge bg-warning text-dark ms-2">BAR</span>` : '';
                
                allTourCustomers[key] = tour;

                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${tour.name}</strong>${barBadge}
                                <div class="small text-muted">${okCount} OK, ${warnCount} Warn, ${badCount} Bad</div>
                            </div>
                            <span class="badge bg-primary rounded-pill">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = Object.keys(tours).length ? `match-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        function renderToursFromWorkflow() {
            console.log('renderToursFromWorkflow aufgerufen, workflowResult:', workflowResult);
            
            // Neue Datenstruktur: workflow_results.final_results.routes.routes
            const routes = workflowResult?.final_results?.routes;
            const tourRoutes = routes?.routes || [];
            
            if (!tourRoutes.length) {
                console.log('Keine Touren gefunden in workflowResult');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${tourRoutes.length} Touren aus Workflow`);
            document.getElementById('tourSummary').textContent = `${routes.total_routes} Touren (Workflow)`;

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = tourRoutes.map((tour, index) => {
                const key = `workflow-${index}`;
                const customerCount = tour.customers?.length || 0;
                const barCount = tour.is_bar_tour ? `<span class="badge bg-warning text-dark ms-2">BAR</span>` : '';
                
                // Kunden mit Koordinaten f√ºr die Karte vorbereiten
                const customers = (tour.customers || []).map(c => ({
                    customer_number: c.customer_number || c.kdnr || '',
                    name: c.name || c.customer_name || 'Unbekannt',
                    street: c.street || c.address || '',
                    postal_code: c.postal_code || c.zip || '',
                    city: c.city || '',
                    bar_flag: !!(c.bar_flag || c.bar),
                    latitude: c.coordinates?.lat || c.latitude,
                    longitude: c.coordinates?.lon || c.longitude,
                    address: c.resolved_address || c.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [c.street || c.address || '', c.postal_code || c.zip || '', c.city || ''].map(clean).filter(Boolean);
                    return parts.join(', ') || '';
                })()
                }));

                // Kunden f√ºr diese Tour speichern
                allTourCustomers[key] = {
                    name: tour.name || `Tour ${index + 1}`,
                    type: tour.tour_type || 'Workflow',
                    time: tour.time || '',
                    customers
                };

                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${tour.name || `Tour ${index + 1}`}</strong>${barCount}
                                <div class="small text-muted">${customerCount} Kunden ¬∑ ${tour.tour_type || 'Workflow'}</div>
                            </div>
                            <span class="badge bg-primary rounded-pill">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = tourRoutes.length ? `workflow-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        function renderCustomerList(customers) {
            if (!customers || !customers.length) {
                return '<span class="text-muted">Keine Kunden vorhanden.</span>';
            }

            return `
                <div class="table-responsive">
                    <table class="table table-sm align-middle">
                        <thead>
                            <tr><th>#</th><th>Kunde</th><th>Adresse</th><th>KdNr</th><th class="text-center">Geo</th></tr>
                        </thead>
                        <tbody>
                            ${customers.map((c, idx) => {
                                const key = `${c.customer_number || idx}-${idx}`;
                                c._geoKey = key;
                                const rowClass = hasCoordinates(c) ? '' : ' class="table-danger"';
                                return `
                                <tr${rowClass}>
                                    <td>${idx + 1}</td>
                                    <td>${c.name}${c.bar_flag ? ' <span class="badge bg-warning text-dark ms-1">BAR</span>' : ''}</td>
                                    <td>${c.resolved_address || c.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [c.street, c.postal_code, c.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '‚Äî';
                })()}</td>
                                    <td>${c.customer_number}</td>
                                    <td class="text-center">
                                        <span class="geo-status" data-geokey="${key}">${getGeoStatusIcon(c)}</span>
                                    </td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                </div>`;
        }

        function hasCoordinates(customer) {
            const lat = parseFloat(customer?.latitude);
            const lon = parseFloat(customer?.longitude);
            return !isNaN(lat) && !isNaN(lon);
        }

        function getGeoStatusIcon(customerOrFlag) {
            const hasCoords = typeof customerOrFlag === 'boolean' ? customerOrFlag : hasCoordinates(customerOrFlag);
            if (hasCoords) {
                return '<i class="fas fa-check-circle text-success"></i>';
            }
            return '<i class="fas fa-times-circle text-danger"></i>';
        }

        function updateGeoIndicator(customer, hasCoords) {
            if (!customer || !customer._geoKey) {
                return;
            }
            const el = document.querySelector(`.geo-status[data-geokey="${customer._geoKey}"]`);
            if (el) {
                el.innerHTML = getGeoStatusIcon(hasCoords);
            }
        }

        function bindTourListEvents() {
            const buttons = document.querySelectorAll('#tourList .list-group-item');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const key = btn.getAttribute('data-tour-key');
                    selectTour(key);
                });
            });
        }

        function selectTour(key) {
            if (!key || !allTourCustomers[key]) {
                return;
            }

            activeTourKey = key;
            updateTourListSelection(key);
            renderTourDetails(allTourCustomers[key]);
        }

        function updateTourListSelection(key) {
            const buttons = document.querySelectorAll('#tourList .list-group-item');
            buttons.forEach(btn => {
                if (btn.getAttribute('data-tour-key') === key) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function renderTourDetails(tourData) {
            if (!tourData) {
                document.getElementById('tourDetails').innerHTML = '<span class="text-muted">Keine Tour ausgew√§hlt.</span>';
                clearTourMarkers();
                return;
            }

            const details = document.getElementById('tourDetails');
            details.innerHTML = `
                <h5>${tourData.name}</h5>
                <div class="mb-2 text-muted">${tourData.type || ''} ${tourData.time ? '¬∑ ' + tourData.time : ''}</div>
                ${renderCustomerList(tourData.customers)}
            `;

            highlightTourOnMap(tourData.customers);
        }

        function renderWorkflowDetails(info) {
            if (!info || !info.ai_result) {
                return '<span class="text-muted">Keine Detaildaten verf√ºgbar.</span>';
            }

            const tours = info.subtours || [];
            if (!tours.length) {
                return '<span class="text-muted">Keine Untertouren erstellt.</span>';
            }

            return tours.map((tour, idx) => `
                <div class="mb-3">
                    <h6>Untertour ${idx + 1}</h6>
                    <pre class="bg-light p-2">${JSON.stringify(tour, null, 2)}</pre>
                </div>`).join('');
        }

        function renderEmptyTours() {
            document.getElementById('tourSummary').textContent = 'Keine Tourdaten';
            document.getElementById('tourList').innerHTML = '';
            document.getElementById('tourDetails').innerHTML = `
                <div class="text-center text-muted py-4">
                    <i class="fas fa-info-circle"></i><br>
                    Noch keine Tourdaten. CSV hochladen oder Workflow starten.
                </div>`;
            clearTourMarkers();
        }

        function passFilter(tour) {
            // Alle Touren werden angezeigt (Filter entfernt)
            return true;
        }

        function passWorkflowFilter(header, info) {
            // Alle Touren werden angezeigt (Filter entfernt)
            return true;
        }

        function clearTourMarkers() {
            if (!map || !tourMarkers.length) {
                return;
            }
            tourMarkers.forEach(marker => map.removeLayer(marker));
            tourMarkers = [];
        }

        async function highlightTourOnMap(customers) {
            if (!map) {
                return;
            }

            clearTourMarkers();

            if (!customers || !customers.length) {
                return;
            }

            const bounds = [];

            for (const customer of customers) {
                // Koordinaten sind jetzt direkt im Customer-Objekt vom Server
                const hasCoords = hasCoordinates(customer);
                updateGeoIndicator(customer, hasCoords);
                
                if (!hasCoords) {
                    console.warn(`Keine Koordinaten f√ºr ${customer.name}`);
                    continue;
                }

                const lat = parseFloat(customer.latitude);
                const lon = parseFloat(customer.longitude);
                
                const marker = L.marker([lat, lon], {
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    })
                }).addTo(map);
                marker.bindPopup(`<strong>${customer.name}</strong><br>${customer.resolved_address || customer.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [customer.street, customer.postal_code, customer.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '‚Äî';
                })()}</strong>`);
                tourMarkers.push(marker);
                bounds.push([lat, lon]);
            }

            if (bounds.length) {
                const featureGroup = L.featureGroup(tourMarkers);
                map.fitBounds(featureGroup.getBounds().pad(0.2));
            }
        }

        async function resolveCustomerCoordinates(customer) {
            const lat = parseFloat(customer.latitude);
            const lon = parseFloat(customer.longitude);
            if (!isNaN(lat) && !isNaN(lon)) {
                return [lat, lon];
            }

            const key = `${customer.street || ''}|${customer.postal_code || ''}|${customer.city || ''}`;
            if (geoCache[key]) {
                return geoCache[key];
            }

            const parts = [customer.street, customer.postal_code, customer.city].filter(Boolean);
            if (!parts.length) {
                return null;
            }

            const address = encodeURIComponent(parts.join(', '));
            try {
                const response = await fetch(`/api/geocode?address=${address}`);
                if (!response.ok) {
                    return null;
                }
                const result = await response.json();
                if (result.lat !== undefined && result.lon !== undefined) {
                    const coords = [parseFloat(result.lat), parseFloat(result.lon)];
                    if (!isNaN(coords[0]) && !isNaN(coords[1])) {
                        geoCache[key] = coords;
                        customer.latitude = coords[0];
                        customer.longitude = coords[1];
                        return coords;
                    }
                }
            } catch (error) {
                console.warn('Geocoding fehlgeschlagen:', error);
            }

            return null;
        }
    </script>
</body>
</html>
