<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAMO TrafficApp</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { background-color: #f0f4f8; }
        #map { height: calc(80vh - 60px); border-radius: 8px; width: 100%; }
        .sidebar { background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); max-height: calc(100vh - 120px); overflow-y: auto; }
        
        /* Phase 2: Farbige UI-Verbesserungen */
        .tour-list-column { background: linear-gradient(135deg, #ffffff 0%, #f5f7fa 100%); border-radius: 8px; padding: 1rem; }
        .tour-details-column { background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border-radius: 8px; padding: 1rem; }
        
        /* Markierung f√ºr aktive Tour in der Liste */
        .list-group-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: #fff !important;
            border-left: 5px solid #4c63d2 !important;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            transform: translateX(3px);
            transition: all 0.2s ease;
        }
        
        /* Markierung f√ºr aktive Zeile in der Kundenliste */
        .table tbody tr.active-row {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%) !important;
            border-left: 4px solid #2196f3 !important;
            font-weight: 500;
        }
        
        /* Hover-Effekte f√ºr bessere Interaktivit√§t */
        .list-group-item:hover:not(.active) {
            background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
            transform: translateX(2px);
            transition: all 0.15s ease;
        }
        
        .table tbody tr:hover:not(.active-row) {
            background-color: #f8f9fa;
            cursor: pointer;
        }
        
        /* Farbige Badges */
        .badge.bg-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important; }
        .badge.bg-success { background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%) !important; }
        .badge.bg-warning { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%) !important; }
        
        /* Performance: GPU-Beschleunigung */
        .list-group-item, .table tbody tr {
            will-change: transform, background-color;
        }
        .tour-card-layout { display: flex; flex-direction: column; }
        @media (min-width: 768px) { .tour-card-layout { flex-direction: row; } }
        .tour-list-column { flex: 0 0 320px; padding: 1rem 1.5rem 1rem 0; border-right: 1px solid #dee2e6; }
        @media (max-width: 767.98px) {
            .tour-list-column { border-right: none; border-bottom: 1px solid #dee2e6; padding: 1rem 1.5rem; }
        }
        .tour-details-column { flex: 1 1 auto; padding: 1rem 1.5rem; }
        .tour-card-layout .list-group-item { border-radius: 0; }
        /* BAR-Tour Hervorhebung: Orange Hintergrund (wie fr√ºher) */
        .bar-tour-highlight {
            background-color: #ffe0b2 !important; /* Hellorange Hintergrund */
            border-left: 4px solid #ff9800 !important; /* Orange Border */
        }
        .bar-tour-highlight:hover {
            background-color: #ffcc80 !important; /* Mittelorange bei Hover */
        }
        .bar-tour-highlight.active {
            background-color: #ff9800 !important; /* Orange wenn aktiv */
            color: #000 !important;
            font-weight: bold;
        }
        /* W-Tour Hervorhebung: Andere Farbe (z.B. Blau/Gr√ºn) - erscheint GANZ OBEN */
        .w-tour-highlight {
            background-color: #e3f2fd !important; /* Hellblau Hintergrund */
            border-left: 4px solid #2196f3 !important; /* Blau Border */
            font-weight: 500 !important;
        }
        .w-tour-highlight:hover {
            background-color: #bbdefb !important; /* Helleres Blau bei Hover */
        }
        .w-tour-highlight.active {
            background-color: #2196f3 !important; /* Blau wenn aktiv */
            color: #fff !important;
            font-weight: bold;
        }
        /* Kombination: W-Tour + BAR */
        .w-tour-highlight.bar-tour-highlight {
            background-color: #fff3e0 !important; /* Hellorange-Gelb */
            border-left: 4px solid #ff9800 !important; /* Orange Border (BAR hat Priorit√§t) */
        }
        /* Optimierungs-Button Styling */
        .optimize-tour-btn {
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .optimize-tour-btn:hover {
            opacity: 1;
            color: #007bff !important;
        }
        .list-group-item:hover .optimize-tour-btn {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
        <div class="container-fluid">
            <a class="navbar-brand" href="/">FAMO TrafficApp</a>
            
            <!-- Navigation Links -->
            <div class="navbar-nav me-auto">
                <a class="nav-link active" href="/">Hauptseite</a>
                <a class="nav-link" href="/admin.html">
                    <i class="fas fa-cog"></i> Admin
                </a>
                <a class="nav-link" href="/ui/test-dashboard">
                    <i class="fas fa-vial"></i> Test-Dashboard
                </a>
                <a class="nav-link" href="/ui/ai-test">
                    <i class="fas fa-robot"></i> AI Test
                </a>
                <a class="nav-link" href="/docs">API Docs</a>
            </div>
            
            <!-- Status Indicators -->
            <div class="navbar-nav">
                <span class="navbar-text me-3">
                    <i class="fas fa-circle text-success"></i> Server online
                    </span>
                <span class="navbar-text me-3" id="osrmStatus">
                    <i class="fas fa-route text-warning"></i> OSRM pr√ºfe...
                </span>
                <span class="navbar-text me-3" id="llmStatus">
                    <i class="fas fa-circle text-warning"></i> LLM pr√ºfe...
                </span>
                <span class="navbar-text me-3" id="dbStatus">
                    <i class="fas fa-database text-info"></i> DB pr√ºfe...
                </span>
                <a href="/admin/ki-improvements" class="navbar-text me-3 text-decoration-none position-relative" id="ki-monitor-link" title="CC - CodeChecker Dashboard">
                    <i class="fas fa-robot text-primary"></i> CC
                    <span class="badge bg-success position-absolute top-0 start-100 translate-middle" id="ki-monitor-badge" style="font-size: 0.6em; display: none;">0</span>
                </a>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
            <div class="sidebar" id="workflowSidebar">
                <h5><i class="fas fa-project-diagram"></i> Workflow</h5>
                <div id="workflowStatus" class="small text-muted mb-3">Noch kein Upload.</div>

                <h5><i class="fas fa-upload"></i> CSV / Workflow</h5>
        <div class="mb-2">
            <label for="csvFile" class="form-label">CSV-Datei ausw√§hlen:</label>
            <input type="file" id="csvFile" class="form-control" accept=".csv,text/csv" onchange="handleFileChange()">
            
            <!-- Upload Status -->
            <div id="uploadInfo" class="small text-muted mt-2"></div>
        </div>
                <button class="btn btn-success w-100" onclick="runWorkflow()">
                    <i class="fas fa-cogs"></i> Kompletter Workflow (Parse + Geocode + Optimize)
                </button>

                <!-- Stats-Box (read-only) mit Toggle -->
                <div id="stats-box" class="card mb-3" style="display: none;">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0"><i class="fas fa-chart-bar"></i> Statistik</h6>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="stats-toggle" checked onchange="toggleStatsBox()">
                            <label class="form-check-label" for="stats-toggle" style="font-size: 0.85em; cursor: pointer;">
                                <span id="stats-toggle-label">An</span>
                            </label>
                        </div>
                    </div>
                    <div class="card-body" id="stats-content" style="font-size: 0.9em;">
                        <div class="row mb-2">
                            <div class="col-8"><span>Touren (Monat):</span></div>
                            <div class="col-4 text-end"><b id="stat-tours-month">‚Äì</b></div>
                        </div>
                        <div class="row mb-2">
                            <div class="col-8"><span>Stops √ò pro Tour:</span></div>
                            <div class="col-4 text-end"><b id="stat-stops-avg">‚Äì</b></div>
                        </div>
                        <div class="row">
                            <div class="col-8"><span>KM (OSRM):</span></div>
                            <div class="col-4 text-end"><b id="stat-km-osrm">‚Äì</b></div>
                        </div>
                    </div>
                </div>
                
                <h5 class="mt-3"><i class="fas fa-robot"></i> KI-Status</h5>
                <div id="aiStatusField" class="alert alert-info mb-3" style="font-size: 0.9em;">
                    <i class="fas fa-info-circle"></i> <span id="aiStatusText">Bereit f√ºr Optimierung</span>
                </div>
                
                
                <h5 class="mt-3"><i class="fas fa-route"></i> Sub-Routen Generator</h5>
                <button class="btn btn-success w-100 mb-2" id="btnGenerateSubRoutes" onclick="generateSubRoutes()" style="display: none;">
                    <i class="fas fa-magic"></i> Routen optimieren (W-Touren & >4 Kunden)
                </button>
                <div id="subRouteStatus" class="small text-muted mb-3" style="display: none;"></div>
                <div id="subRouteProgress" class="mb-3" style="display: none;">
                    <div class="progress" style="height: 25px;">
                        <div id="subRouteProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" style="width: 0%" 
                             aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                            <span id="subRouteProgressText">0%</span>
                        </div>
                    </div>
                    <div id="subRouteProgressDetails" class="small text-muted mt-1 text-center"></div>
                </div>
                
                <h5 class="mt-3"><i class="fas fa-window-restore"></i> Panels abdocken</h5>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button class="btn btn-outline-primary" style="flex: 1;" onclick="openMapPanel()" title="Karte in separates Fenster √∂ffnen">
                        <i class="fas fa-map"></i> Karte abdocken
                    </button>
                    <button class="btn btn-outline-primary" style="flex: 1;" onclick="openToursPanel()" title="Tour-√úbersicht in separates Fenster √∂ffnen">
                        <i class="fas fa-list"></i> Touren abdocken
                    </button>
                </div>
                
                <h5 class="mt-3"><i class="fas fa-camera"></i> Blitzer & Hindernisse</h5>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button id="toggleSpeedCamerasBtn" class="btn btn-warning" style="flex: 1;" onclick="toggleSpeedCameras()" title="Blitzer auf der Karte ein-/ausblenden">
                        <i class="fas fa-eye-slash"></i> Blitzer ausblenden
                    </button>
                    <button id="toggleTrafficIncidentsBtn" class="btn btn-secondary" style="flex: 1;" onclick="toggleTrafficIncidents()" title="Baustellen, Unf√§lle, Sperrungen auf der Karte ein-/ausblenden">
                        <i class="fas fa-eye"></i> Hindernisse einblenden
                    </button>
                </div>
                
                <!-- KI-Verbesserungen Widget -->
                <div class="ki-improvements-widget mt-3">
                    <h5><i class="fas fa-robot"></i> KI-Verbesserungen</h5>
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span>Heute:</span>
                        <span class="badge bg-success" id="ki-improvements-badge">0</span>
                    </div>
                    <div id="ki-improvements-list" class="small">
                        <div class="text-muted">Lade...</div>
                    </div>
                    <a href="/admin/ki-improvements" class="btn btn-sm btn-outline-primary w-100 mt-2">
                        <i class="fas fa-chart-line"></i> Dashboard
                    </a>
                </div>
            </div>
            </div>
            
            <!-- Optimization Modal -->
            <div class="modal fade" id="optimizationModal" tabindex="-1" aria-labelledby="optimizationModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="optimizationModalLabel">Tour-Optimierung</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schlie√üen</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <div class="card mb-3">
                    <div class="card-header">
                        <h4><i class="fas a-map"></i> Karte</h4>
                    </div>
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div>
                                <h4 class="mb-2"><i class="fas fa-list"></i> Tour-√úbersicht</h4>
                                <button class="btn btn-lg btn-outline-danger" id="clearAllBtn" onclick="clearAllTours()" style="display: none;">
                                    <i class="fas fa-trash"></i> Clear
                                </button>
                            </div>
                            <div class="text-end align-self-center">
                                <div class="small text-muted" id="tourSummary">Keine Daten</div>
                            </div>
                        </div>
                    </div>
                    <div class="card-body tour-card-layout">
                        <div class="tour-list-column">
                            <div id="tourList" class="list-group list-group-flush"></div>
                        </div>
                        <div class="tour-details-column">
                            <div id="tourDetails" class="border rounded p-3 bg-light h-100">
                                <div class="text-center text-muted py-4">
                                    <i class="fas fa-info-circle"></i><br>
                                    Noch keine Tourdaten. CSV hochladen oder Workflow starten.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mapbox/polyline@1.0.1/polyline.js"></script>
    <script type="module" src="/static/js/polyline6.js"></script>
    <script type="module" src="/static/js/panel-ipc.js"></script>
    <script>
        // KRITISCH: Funktionen SOFORT im globalen Scope definieren, BEVOR andere Scripts geladen werden
        // Dies verhindert "ReferenceError: function is not defined" Fehler
        console.log('[INIT] Definiere Fallback-Funktionen...');
        
        // Fallback f√ºr handleFileChange - wird sofort verf√ºgbar gemacht
        window.handleFileChange = function() {
            console.log('[FALLBACK] handleFileChange() aufgerufen');
            const input = document.getElementById('csvFile');
            if (!input) {
                console.error('[FALLBACK] csvFile Input nicht gefunden!');
                alert('Fehler: Datei-Input nicht gefunden. Bitte Seite neu laden.');
                return;
            }
            if (!input.files || !input.files.length) {
                console.log('[FALLBACK] Keine Datei ausgew√§hlt');
                const status = document.getElementById('workflowStatus');
                if (status) {
                    status.innerHTML = 'Bitte w√§hlen Sie eine CSV-Datei aus.';
                    status.className = 'small text-warning mb-3';
                }
                return;
            }
            const file = input.files[0];
            console.log('[FALLBACK] Datei ausgew√§hlt:', file.name, `(${(file.size/1024).toFixed(1)} KB)`);
            const status = document.getElementById('workflowStatus');
            if (status) {
                status.innerHTML = `<span class="text-info">Datei ausgew√§hlt: ${file.name} (${(file.size/1024).toFixed(1)} KB)</span>`;
            }
            // Vollst√§ndige Funktion wird sp√§ter √ºberschrieben, aber Fallback funktioniert bereits
        };
        
        // Fallback f√ºr runWorkflow - wird sofort verf√ºgbar gemacht
        window.runWorkflow = async function() {
            console.log('[FALLBACK] runWorkflow() aufgerufen');
            const fileInput = document.getElementById('csvFile');
            if (!fileInput) {
                const errorMsg = 'Fehler: Datei-Input nicht gefunden. Bitte Seite neu laden.';
                console.error('[FALLBACK]', errorMsg);
                alert(errorMsg);
                const status = document.getElementById('workflowStatus');
                if (status) {
                    status.innerHTML = `<span class="text-danger">${errorMsg}</span>`;
                }
                return;
            }
            const file = fileInput.files[0];
            if (!file) {
                const errorMsg = 'Bitte w√§hlen Sie zuerst eine CSV-Datei aus!';
                console.warn('[FALLBACK]', errorMsg);
                alert(errorMsg);
                const status = document.getElementById('workflowStatus');
                if (status) {
                    status.innerHTML = `<span class="text-warning">${errorMsg}</span>`;
                }
                return;
            }
            console.log('[FALLBACK] Starte Workflow f√ºr:', file.name);
            const status = document.getElementById('workflowStatus');
            if (status) {
                status.innerHTML = `<span class="text-info">Workflow wird gestartet f√ºr: ${file.name}...</span>`;
            }
            alert('Workflow-Funktion wird geladen. Bitte warten Sie einen Moment und versuchen Sie es erneut.');
            // Vollst√§ndige Funktion wird sp√§ter √ºberschrieben, aber Fallback funktioniert bereits
        };
        
        console.log('[INIT] Fallback-Funktionen definiert:', {
            handleFileChange: typeof window.handleFileChange,
            runWorkflow: typeof window.runWorkflow
        });
    </script>
    <script>
        // ============================================================
        // ROBUSTE FEHLERBEHANDLUNG: Alle Funktionen mit Fallbacks
        // ============================================================
        
        // Wrapper f√ºr sichere Funktionsausf√ºhrung (verhindert Abst√ºrze)
        function safeExecute(fn, fallback = () => {}, context = 'Unknown') {
            try {
                return fn();
            } catch (error) {
                console.warn(`[SAFE-EXEC] Fehler in ${context}:`, error);
                try {
                    return fallback();
                } catch (fallbackError) {
                    console.warn(`[SAFE-EXEC] Fallback-Fehler in ${context}:`, fallbackError);
                    return null;
                }
            }
        }
        
        // Wrapper f√ºr sichere async Funktionsausf√ºhrung
        async function safeExecuteAsync(fn, fallback = async () => {}, context = 'Unknown') {
            try {
                return await fn();
            } catch (error) {
                console.warn(`[SAFE-EXEC] Fehler in ${context}:`, error);
                try {
                    return await fallback();
                } catch (fallbackError) {
                    console.warn(`[SAFE-EXEC] Fallback-Fehler in ${context}:`, fallbackError);
                    return null;
                }
            }
        }
        
        // WICHTIG: Funktionen SOFORT definieren, damit sie f√ºr onclick/onchange verf√ºgbar sind
        window.handleFileChange = function() {
            return safeExecute(() => {
                console.log('[FILE-CHANGE] handleFileChange() aufgerufen');
                
                const input = document.getElementById('csvFile');
                if (!input) {
                    console.warn('[FILE-CHANGE] csvFile Input nicht gefunden!');
                    return;
                }
                
                const status = document.getElementById('workflowStatus');
                const uploadInfo = document.getElementById('uploadInfo');
                
                if (!input.files || !input.files.length) {
                    console.log('[FILE-CHANGE] Keine Datei ausgew√§hlt');
                    if (typeof currentFilename !== 'undefined') currentFilename = null;
                    if (status) {
                        status.innerHTML = 'Noch kein Upload.';
                        status.className = 'small text-muted mb-3';
                    }
                    if (uploadInfo) {
                        uploadInfo.innerHTML = '';
                    }
                    return;
                }
                
                const file = input.files[0];
                if (typeof currentFilename !== 'undefined') currentFilename = file.name;
                console.log('[FILE-CHANGE] Datei ausgew√§hlt:', file.name, `(${(file.size/1024).toFixed(1)} KB)`);
                
                // Upload √ºber neue API (wird sp√§ter definiert)
                if (typeof uploadCsvFile === 'function') {
                    uploadCsvFile(file);
                } else {
                    console.warn('[FILE-CHANGE] uploadCsvFile() noch nicht definiert - wird √ºbersprungen');
                }
            }, () => {}, 'handleFileChange');
        };
        
        window.runWorkflow = async function() {
            return await safeExecuteAsync(async () => {
                console.log('[WORKFLOW] runWorkflow() aufgerufen');
                
                const fileInput = document.getElementById('csvFile');
                if (!fileInput) {
                    const errorMsg = 'Fehler: Datei-Input nicht gefunden. Bitte Seite neu laden.';
                    console.error('[WORKFLOW]', errorMsg);
                    alert(errorMsg);
                    updateWorkflowStatus(`<span class="text-danger">${errorMsg}</span>`);
                    return;
                }
                
                const file = fileInput.files[0];
                console.log('[WORKFLOW] Datei:', file ? file.name : 'KEINE DATEI');

                if (!file) {
                    const errorMsg = 'Bitte w√§hlen Sie zuerst eine CSV-Datei aus!';
                    console.warn('[WORKFLOW]', errorMsg);
                    alert(errorMsg);
                    updateWorkflowStatus(`<span class="text-warning">${errorMsg}</span>`);
                    return;
                }
                
                console.log('[WORKFLOW] Starte Workflow f√ºr:', file.name);
                
                // Weiterleitung zur vollst√§ndigen runWorkflow-Funktion (wird sp√§ter definiert)
                if (window._runWorkflowFull) {
                    await window._runWorkflowFull();
                } else {
                    const errorMsg = 'Workflow-Funktion noch nicht geladen. Bitte warten Sie einen Moment und versuchen Sie es erneut.';
                    console.error('[WORKFLOW]', errorMsg);
                    alert(errorMsg);
                    updateWorkflowStatus(`<span class="text-danger">${errorMsg}</span>`);
                }
            }, async (error) => {
                const errorMsg = `Workflow-Fehler: ${error.message || 'Unbekannter Fehler'}`;
                console.error('[WORKFLOW] Fehler in safeExecuteAsync:', error);
                alert(errorMsg);
                updateWorkflowStatus(`<span class="text-danger">${errorMsg}</span>`);
            }, 'runWorkflow');
        };
        
        let map;
        let parsedData = null;
        let workflowResult = null;
        let activeTourKey = null;
        let allTourCustomers = {};
        let tourMarkers = [];
        let tourRouteLines = [];  // WICHTIG: F√ºr OSRM-Routen-Linien auf der Karte
        let currentFilename = null;
        let geoCache = {};
        
        // Panel-Fenster-Management
        let mapPanelWindow = null;
        let toursPanelWindow = null;

        // State-Management: Speichere Touren in localStorage
        function saveToursToStorage() {
            try {
                if (workflowResult) {
                    localStorage.setItem('workflowResult', JSON.stringify(workflowResult));
                }
                if (Object.keys(allTourCustomers).length > 0) {
                    localStorage.setItem('allTourCustomers', JSON.stringify(allTourCustomers));
                }
                if (activeTourKey) {
                    localStorage.setItem('activeTourKey', activeTourKey);
                }
                if (currentFilename) {
                    localStorage.setItem('currentFilename', currentFilename);
                }
            } catch (e) {
                console.error('Fehler beim Speichern:', e);
            }
        }
        
        // State-Management: Lade Touren aus localStorage
        function restoreToursFromStorage() {
            try {
                const savedWorkflow = localStorage.getItem('workflowResult');
                const savedCustomers = localStorage.getItem('allTourCustomers');
                const savedTourKey = localStorage.getItem('activeTourKey');
                const savedFilename = localStorage.getItem('currentFilename');
                
                if (savedWorkflow) {
                    workflowResult = JSON.parse(savedWorkflow);
                    console.log('Workflow-Ergebnisse wiederhergestellt:', workflowResult);
                }
                
                if (savedCustomers) {
                    const loadedCustomers = JSON.parse(savedCustomers);
                    console.log('[RESTORE] Tour-Kunden aus localStorage geladen:', Object.keys(loadedCustomers).length, 'Touren');
                    console.log('[RESTORE] Geladene Keys:', Object.keys(loadedCustomers));
                    
                    // WICHTIG: Normalisiere Keys beim Laden (konvertiere alte Keys zu neuen Format)
                    allTourCustomers = {};
                    let normalizedCount = 0;
                    Object.entries(loadedCustomers).forEach(([oldKey, tourData]) => {
                        // Pr√ºfe ob Key bereits normalisiert ist (enth√§lt nur alphanumerisch, Bindestrich, Unterstrich)
                        const isNormalized = /^workflow-[a-zA-Z0-9_-]+(-[A-Z])?$/.test(oldKey);
                        
                        if (isNormalized) {
                            // Key ist bereits normalisiert - verwende direkt
                            allTourCustomers[oldKey] = tourData;
                        } else {
                            // Key muss normalisiert werden
                            // Extrahiere Tour-Metadaten f√ºr generateTourKey()
                            const tourMeta = {
                                tour_id: tourData.name || oldKey.replace('workflow-', '').replace(/-[A-Z]$/, ''),
                                _base_tour_id: tourData._base_tour_id || extractBaseTourId(tourData),
                                _sub_route: tourData._sub_route || tourData._sub_route_letter || (oldKey.match(/-([A-Z])$/)?.[1] || '')
                            };
                            const newKey = generateTourKey(tourMeta);
                            
                            if (newKey !== oldKey) {
                                console.log(`[RESTORE] Normalisiere Key: "${oldKey}" ‚Üí "${newKey}"`);
                                normalizedCount++;
                            }
                            
                            allTourCustomers[newKey] = tourData;
                        }
                    });
                    
                    if (normalizedCount > 0) {
                        console.log(`[RESTORE] ${normalizedCount} Keys normalisiert - speichere aktualisierte Keys`);
                        // Speichere normalisierte Keys zur√ºck
                        localStorage.setItem('allTourCustomers', JSON.stringify(allTourCustomers));
                    }
                    
                    console.log('[RESTORE] Tour-Kunden normalisiert:', Object.keys(allTourCustomers).length, 'Touren');
                    console.log('[RESTORE] Normalisierte Keys:', Object.keys(allTourCustomers));
                }
                
                // WICHTIG: Priorisiere workflowResult √ºber allTourCustomers!
                // Problem: Wenn beide vorhanden sind, wurde allTourCustomers verwendet, was die alten
                // Haupttouren enthielt. Jetzt l√∂schen wir alte Eintr√§ge in allTourCustomers, die zu
                // den Touren in workflowResult geh√∂ren, bevor wir rendern.
                if (workflowResult && workflowResult.tours && workflowResult.tours.length > 0) {
                    // L√∂sche alte Eintr√§ge in allTourCustomers, die zu diesen Touren geh√∂ren
                    const baseTourIds = new Set();
                    workflowResult.tours.forEach(tour => {
                        // WICHTIG: _base_tour_id extrahieren - Sub-Routen haben Format "W-07.00 A", Basis ist "W-07.00"
                        let baseId = tour._base_tour_id;
                        if (!baseId && tour.tour_id) {
                            // Entferne Sub-Route Buchstaben (A, B, C, ...) und "Uhr Tour" / "Uhr BAR"
                            baseId = tour.tour_id.replace(/\s+[A-Z]$/, '').replace(/\s*(Uhr\s*)?(Tour|BAR)$/i, '').trim();
                        }
                        if (baseId) {
                            baseTourIds.add(baseId);
                        }
                    });
                    
                    console.log(`[RESTORE] Base-Tour-IDs gefunden:`, Array.from(baseTourIds));
                    
                    let deletedCount = 0;
                    Object.keys(allTourCustomers).forEach(key => {
                        const tour = allTourCustomers[key];
                        // WICHTIG: Base-ID extrahieren - unterst√ºtze verschiedene Formate
                        let tourBaseId = tour._base_tour_id;
                        if (!tourBaseId && tour.name) {
                            // Entferne Sub-Route Buchstaben (A, B, C, ...) und "Uhr Tour" / "Uhr BAR"
                            tourBaseId = tour.name.replace(/\s+[A-Z]$/, '').replace(/\s*(Uhr\s*)?(Tour|BAR)$/i, '').trim();
                        }
                        if (!tourBaseId) {
                            // Fallback: Erste Zeile vor Leerzeichen
                            tourBaseId = (tour.name || '').split(' ')[0];
                        }
                        
                        // Pr√ºfe ob diese Tour zu einer der Base-IDs geh√∂rt
                        if (tourBaseId && baseTourIds.has(tourBaseId)) {
                            console.log(`[RESTORE] L√∂sche alten Eintrag: ${key} (Tour: ${tourBaseId}) - wird durch workflowResult ersetzt`);
                            delete allTourCustomers[key];
                            deletedCount++;
                        }
                    });
                    
                    if (deletedCount > 0) {
                        console.log(`[RESTORE] ${deletedCount} alte Eintr√§ge gel√∂scht, verwende workflowResult mit Sub-Routen`);
                    }
                    
                    // Rendere aus workflowResult (enth√§lt Sub-Routen)
                    renderToursFromMatch(workflowResult);
                    // WICHTIG: Speichere die aktualisierten allTourCustomers sofort!
                    // renderToursFromMatch() erstellt neue Eintr√§ge in allTourCustomers,
                    // diese m√ºssen gespeichert werden, damit sie nach Reload erhalten bleiben.
                    saveToursToStorage();
                    // Sub-Routen Button aktualisieren nach dem Rendern
                    updateSubRouteButtonVisibility();
                } else if (Object.keys(allTourCustomers).length > 0) {
                    // Nur wenn workflowResult leer ist, verwende allTourCustomers
                    console.log('[RESTORE] workflowResult leer, verwende allTourCustomers');
                    renderToursFromCustomers();
                    // WICHTIG: Button auch hier aktualisieren!
                    updateSubRouteButtonVisibility();
                }
                
                // WICHTIG: Normalisiere auch activeTourKey beim Laden
                if (savedTourKey) {
                    let normalizedTourKey = savedTourKey;
                    
                    // Pr√ºfe ob Key normalisiert ist
                    const isNormalized = /^workflow-[a-zA-Z0-9_-]+(-[A-Z])?$/.test(savedTourKey);
                    
                    if (!isNormalized) {
                        // Normalisiere Key
                        const normalizedKey = savedTourKey.replace(/[^a-zA-Z0-9-]/g, '_');
                        // Suche √§hnlichen Key in allTourCustomers
                        const matchingKey = Object.keys(allTourCustomers).find(k => {
                            const normalizedK = k.replace(/[^a-zA-Z0-9-]/g, '_');
                            return normalizedK === normalizedKey || 
                                   normalizedK.includes(normalizedKey) || 
                                   normalizedKey.includes(normalizedK);
                        });
                        
                        if (matchingKey) {
                            normalizedTourKey = matchingKey;
                            console.log(`[RESTORE] Normalisiere activeTourKey: "${savedTourKey}" ‚Üí "${normalizedTourKey}"`);
                            // Speichere normalisierten Key zur√ºck
                            localStorage.setItem('activeTourKey', normalizedTourKey);
                        }
                    }
                    
                    if (allTourCustomers[normalizedTourKey]) {
                        setTimeout(() => {
                            selectTour(normalizedTourKey);
                        }, 100);
                    } else {
                        console.warn(`[RESTORE] activeTourKey "${normalizedTourKey}" nicht in allTourCustomers gefunden`);
                    }
                }
                
                if (savedFilename) {
                    currentFilename = savedFilename;
                    const uploadInfo = document.getElementById('uploadInfo');
                    if (uploadInfo) {
                        uploadInfo.innerHTML = `<i class="fas fa-check text-success"></i> Datei wiederhergestellt: ${savedFilename}`;
                    }
                }
                
                // Clear-Button anzeigen wenn Daten vorhanden
                updateClearButtonVisibility();
                
            } catch (e) {
                console.error('Fehler beim Wiederherstellen:', e);
            }
        }
        
        // Hilfsfunktion: Rendere Touren aus allTourCustomers
        function renderToursFromCustomers() {
            const tourList = document.getElementById('tourList');
            // WICHTIG: Verwende Object.entries() um sowohl Keys als auch Werte zu bekommen
            const tourEntries = Object.entries(allTourCustomers);
            
            if (tourEntries.length === 0) {
                renderEmptyTours();
                updateSubRouteButtonVisibility();
                return;
            }
            
            let totalCustomers = 0;
            let totalWarnings = 0;
            let totalBad = 0;
            
            tourEntries.forEach(([key, tour]) => {
                totalCustomers += tour.customers ? tour.customers.length : 0;
                if (tour.customers) {
                    tour.customers.forEach(c => {
                        if (c.warning) totalWarnings++;
                        if (c.status === 'bad') totalBad++;
                    });
                }
            });
            
            document.getElementById('tourSummary').textContent = 
                `${tourEntries.length} Touren ¬∑ ${totalCustomers} Adressen ¬∑ ${totalWarnings} Warnungen ¬∑ ${totalBad} Bad`;
            
            tourList.innerHTML = tourEntries.map(([originalKey, tour], index) => {
                const key = `restored-${index}`;
                const customerCount = tour.customers ? tour.customers.length : 0;
                const barBadge = tour.isBarTour ? '<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>' : '';
                
                return `
                    <button class="list-group-item list-group-item-action position-relative" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${tour.name || `Tour ${index + 1}`}</strong>${barBadge}
                                <div class="small text-muted">${customerCount} Kunden</div>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge bg-primary rounded-pill">${customerCount}</span>
                                <button class="btn btn-sm btn-link p-0 text-secondary optimize-tour-btn" 
                                        data-tour-key="${key}" 
                                        data-tour-name="${tour.name || `Tour ${index + 1}`}"
                                        data-stop-count="${customerCount}"
                                        title="Tour mit AI optimieren"
                                        onclick="event.stopPropagation(); optimizeTour('${key}', '${tour.name || `Tour ${index + 1}`}');">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </button>
                `;
            }).join('');
            
            bindTourListEvents();
            
            // WICHTIG: Button-Sichtbarkeit nach dem Rendern aktualisieren!
            updateSubRouteButtonVisibility();
        }
        
        // Clear-Button: Alle Daten l√∂schen
        function clearAllTours() {
            if (!confirm('M√∂chten Sie wirklich alle Touren und Daten l√∂schen?')) {
                return;
            }
            
            // Variablen zur√ºcksetzen
            workflowResult = null;
            allTourCustomers = {};
            activeTourKey = null;
            currentFilename = null;
            
            // localStorage leeren
            localStorage.removeItem('workflowResult');
            localStorage.removeItem('allTourCustomers');
            localStorage.removeItem('activeTourKey');
            localStorage.removeItem('currentFilename');
            localStorage.removeItem('optimizedTours');
            
            // UI zur√ºcksetzen
            renderEmptyTours();
            const workflowStatus = document.getElementById('workflowStatus');
            if (workflowStatus) {
                workflowStatus.innerHTML = 'Noch kein Upload.';
            }
            const uploadInfo = document.getElementById('uploadInfo');
            if (uploadInfo) {
                uploadInfo.innerHTML = '';
            }
            const csvFile = document.getElementById('csvFile');
            if (csvFile) {
                csvFile.value = '';
            }
            
            // KI-Status zur√ºcksetzen
            updateAIStatus('Bereit f√ºr Optimierung', 'info');
            
            // Clear-Button verstecken
            updateClearButtonVisibility();
        }
        
        // Clear-Button Sichtbarkeit aktualisieren
        function updateClearButtonVisibility() {
            const clearBtn = document.getElementById('clearAllBtn');
            if (!clearBtn) return;
            
            const hasData = (workflowResult && workflowResult.tours && workflowResult.tours.length > 0) || 
                           Object.keys(allTourCustomers).length > 0;
            clearBtn.style.display = hasData ? 'block' : 'none';
        }

        // ============================================================
        // PFLICHT: Automatisches Fehler-Logging - JEDER Fehler wird gespeichert!
        // ============================================================
        
        /**
         * Sendet Fehler automatisch an Backend zum Speichern in LESSONS_LOG.md
         */
        async function autoLogError(errorType, errorMessage, filePath, lineNumber, stackTrace) {
            return await safeExecuteAsync(async () => {
                const response = await fetch('/api/errors/auto-log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        error_type: errorType,
                        error_message: errorMessage,
                        file_path: filePath,
                        line_number: lineNumber,
                        stack_trace: stackTrace,
                        url: window.location.href,
                        user_agent: navigator.userAgent,
                        severity: 'üî¥ KRITISCH'
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[AUTO-LOG] Fehler automatisch gespeichert:', result.title);
                } else {
                    console.warn('[AUTO-LOG] Fehler beim Speichern:', response.status);
                }
            }, async () => {
                console.warn('[AUTO-LOG] Auto-Logging fehlgeschlagen - wird √ºbersprungen');
            }, 'autoLogError');
        }
        
        // Globaler Error-Handler f√ºr alle JavaScript-Fehler
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('[GLOBAL-ERROR]', message, 'in', source, 'Zeile', lineno);
            
            // Automatisch speichern
            autoLogError(
                error ? error.name : 'Error',
                message || 'Unbekannter Fehler',
                source || 'unknown',
                lineno || 0,
                error ? error.stack : null
            );
            
            // Standard-Verhalten beibehalten
            return false;
        };
        
        // Handler f√ºr unhandled Promise Rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('[UNHANDLED-REJECTION]', event.reason);
            
            const error = event.reason;
            const errorType = error && error.name ? error.name : 'UnhandledRejection';
            const errorMessage = error && error.message ? error.message : String(event.reason);
            const stackTrace = error && error.stack ? error.stack : null;
            
            // Automatisch speichern
            autoLogError(
                errorType,
                errorMessage,
                'promise-rejection',
                0,
                stackTrace
            );
        });
        
        // Handler f√ºr alle anderen Fehler
        window.addEventListener('error', function(event) {
            if (event.error) {
                console.error('[ERROR-EVENT]', event.error);
                
                // Automatisch speichern
                autoLogError(
                    event.error.name || 'Error',
                    event.error.message || 'Unbekannter Fehler',
                    event.filename || 'unknown',
                    event.lineno || 0,
                    event.error.stack || null
                );
            }
        });
        
        // ============================================================
        // Initialisierung
        // ============================================================
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM geladen, starte...');
            console.log('[AUTO-LOG] Automatisches Fehler-Logging aktiviert - JEDER Fehler wird gespeichert!');
            initializeMap();
            loadStatusData();
            restoreToursFromStorage();
            loadKIImprovementsWidget();
            connectKIImprovementsWebSocket();
            refreshOsrmBadge(); // OSRM-Badge beim Laden
            
            // Button-Status beim Laden initialisieren
            setTimeout(() => {
                updateSpeedCameraToggleButton();
                updateTrafficIncidentToggleButton();
                updateSubRouteButtonVisibility();
            }, 500);
        });
        
        // KI-Verbesserungen Widget
        async function loadKIImprovementsWidget() {
            return await safeExecuteAsync(async () => {
                const response = await fetch('/api/ki-improvements/stats');
                if (!response.ok) {
                    console.warn('[KI-WIDGET] Stats-API Fehler:', response.status);
                    return;
                }
                
                const stats = await response.json();
                
                const badge = document.getElementById('ki-improvements-badge');
                if (badge) {
                    badge.textContent = stats.improvements_today || 0;
                }
                
                // Navbar-Badge aktualisieren
                const navbarBadge = document.getElementById('ki-monitor-badge');
                if (navbarBadge) {
                    const count = stats.improvements_today || 0;
                    if (count > 0) {
                        navbarBadge.textContent = count;
                        navbarBadge.style.display = 'inline-block';
                    } else {
                        navbarBadge.style.display = 'none';
                    }
                }
                
                // Lade letzte Verbesserungen
                const recentResponse = await fetch('/api/ki-improvements/recent?limit=3');
                if (!recentResponse.ok) {
                    console.warn('[KI-WIDGET] Recent-API Fehler:', recentResponse.status);
                    return;
                }
                
                const improvements = await recentResponse.json();
                
                const list = document.getElementById('ki-improvements-list');
                if (list && improvements.length > 0) {
                    list.innerHTML = improvements.map(imp => {
                        const file = imp.file.split('/').pop() || imp.file;
                        const icon = imp.action === 'improved' ? '‚úÖ' : '‚ö†Ô∏è';
                        const time = new Date(imp.timestamp).toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'});
                        return `<div class="mb-1"><small>${icon} ${file} (${time})</small></div>`;
                    }).join('');
                } else if (list) {
                    list.innerHTML = '<div class="text-muted">Noch keine Verbesserungen</div>';
                }
            }, async (error) => {
                console.error('[KI-WIDGET] Fehler beim Laden:', error);
            }, 'loadKIImprovementsWidget');
        }
        
        // WebSocket f√ºr Live-Updates
        let kiWebSocket = null;
        
        function connectKIImprovementsWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/ki-improvements`;
                kiWebSocket = new WebSocket(wsUrl);
                
                kiWebSocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'improvement') {
                        // Toast-Notification anzeigen
                        showImprovementToast(data.data);
                        // Widget aktualisieren
                        loadKIImprovementsWidget();
                    } else if (data.type === 'stats') {
                        // Stats aktualisieren
                        const badge = document.getElementById('ki-improvements-badge');
                        if (badge && data.data) {
                            badge.textContent = data.data.improvements_today || 0;
                        }
                        
                        // Navbar-Badge aktualisieren
                        const navbarBadge = document.getElementById('ki-monitor-badge');
                        if (navbarBadge && data.data) {
                            const count = data.data.improvements_today || 0;
                            if (count > 0) {
                                navbarBadge.textContent = count;
                                navbarBadge.style.display = 'inline-block';
                            } else {
                                navbarBadge.style.display = 'none';
                            }
                        }
                    }
                };
                
                kiWebSocket.onerror = (error) => {
                    // WebSocket-Fehler sind nicht kritisch - nur loggen, nicht in Konsole spammen
                    // console.error('[KI-WEBSOCKET] Fehler:', error);
                };
                
                kiWebSocket.onclose = () => {
                    // Reconnect nach 5 Sekunden
                    setTimeout(connectKIImprovementsWebSocket, 5000);
                };
            } catch (e) {
                console.error('[KI-WEBSOCKET] Verbindungsfehler:', e);
            }
        }
        
        // Toast-Notification
        function showImprovementToast(improvement) {
            const file = improvement.file.split('/').pop() || improvement.file;
            const icon = improvement.action === 'improved' ? '‚úÖ' : '‚ö†Ô∏è';
            const bgColor = improvement.action === 'improved' ? 'success' : 'warning';
            
            const toast = document.createElement('div');
            toast.className = `toast-notification alert alert-${bgColor} alert-dismissible fade show`;
            toast.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; min-width: 300px; max-width: 400px;';
            toast.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="fas fa-robot me-2"></i>
                    <div class="flex-grow-1">
                        <strong>CC - CodeChecker</strong><br>
                        <small>${icon} ${file}</small><br>
                        <small>${improvement.issues_fixed || 0} Issues behoben</small>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto-close nach 10 Sekunden
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 10000);
        }
        
        // State-Management: Beim Verlassen der Seite speichern
        window.addEventListener('beforeunload', function() {
            saveToursToStorage();
        });

        // Karte initialisieren
        function initializeMap() {
            console.log('Initialisiere Karte...');
            
            if (typeof L === 'undefined') {
                console.error('Leaflet nicht geladen!');
                return;
            }
            
            try {
                // Karte auf FAMO Standort zentrieren (Gittersee)
                map = L.map('map').setView([51.01127, 13.70161], 15);
                console.log('Karte erstellt');
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
                
                // FAMO Dresden Marker - Haupt-Depot in kr√§ftigem Lila mit Warehouse-Symbol
                const depotMarker = L.marker([51.01127, 13.70161], {
                    icon: L.divIcon({
                        className: 'custom-depot-marker',
                        html: `
                            <div style="
                                background-color: #9C27B0;
                                border: 3px solid #7B1FA2;
                                border-radius: 8px;
                                width: 45px;
                                height: 45px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                box-shadow: 0 3px 10px rgba(0,0,0,0.3);
                                transform: rotate(-45deg);
                            ">
                                <i class="fas fa-warehouse" style="
                                    color: white;
                                    font-size: 24px;
                                    transform: rotate(45deg);
                                    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
                                "></i>
                            </div>
                            <div style="
                                position: absolute;
                                bottom: -8px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 0;
                                height: 0;
                                border-left: 10px solid transparent;
                                border-right: 10px solid transparent;
                                border-top: 12px solid #7B1FA2;
                            "></div>
                        `,
                        iconSize: [45, 45],
                        iconAnchor: [22, 45],
                        popupAnchor: [0, -45]
                    })
                }).addTo(map);
                depotMarker.bindPopup(`
                    <div style="text-align: center;">
                        <b style="color: #9C27B0; font-size: 1.2em;">üè≠ FAMO Dresden</b><br>
                        <strong style="color: #7B1FA2; font-size: 1.1em;">HAUPT-DEPOT</strong><br>
                        <hr style="margin: 8px 0;">
                        <i class="fas fa-map-marker-alt"></i> Stuttgarter Str. 33<br>
                        01189 Dresden<br>
                        <small><i class="fas fa-industry"></i> Industriegebiet Gittersee</small>
                    </div>
                `);
                depotMarker.openPopup();
                
                console.log('Karte erfolgreich initialisiert!');
            } catch (error) {
                console.error('Fehler beim Initialisieren der Karte:', error);
            }
        }

        function updateWorkflowStatus(message) {
            document.getElementById('workflowStatus').innerHTML = message;
        }

        // handleFileChange ist bereits oben definiert (f√ºr onclick/onchange)
        // Diese Funktion wird hier √ºberschrieben mit vollst√§ndiger Logik
        window.handleFileChange = function() {
            console.log('[FILE-CHANGE] handleFileChange() aufgerufen');
            
            const input = document.getElementById('csvFile');
            if (!input) {
                console.error('[FILE-CHANGE] csvFile Input nicht gefunden!');
                return;
            }
            
            const status = document.getElementById('workflowStatus');
            const uploadInfo = document.getElementById('uploadInfo');
            
            if (!input.files || !input.files.length) {
                console.log('[FILE-CHANGE] Keine Datei ausgew√§hlt');
                currentFilename = null;
                if (status) {
                    status.innerHTML = 'Noch kein Upload.';
                    status.className = 'small text-muted mb-3';
                }
                if (uploadInfo) {
                    uploadInfo.innerHTML = '';
                }
                return;
            }
            
            const file = input.files[0];
            currentFilename = file.name;
            console.log('[FILE-CHANGE] Datei ausgew√§hlt:', file.name, `(${(file.size/1024).toFixed(1)} KB)`);
            
            // Upload √ºber neue API
            uploadCsvFile(file);
        };

        // Neue Upload-API Funktionen
        // State: Pfad nach Upload merken
        let LAST_UPLOAD_PATH = null;

        async function apiUploadCsv(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch('/api/upload/csv', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Upload fehlgeschlagen: ${response.status}`);
            }
            
            // Nur einmal lesen - direkt JSON
            const data = await response.json();
            
            // stored_path ist das neue vereinheitlichte Feld
            const p = data?.stored_path;
            if (!p) {
                throw new Error('Upload response missing stored_path');
            }
            
            LAST_UPLOAD_PATH = p;
            return data;
        }

        async function uploadCsvFile(file) {
            const uploadInfo = document.getElementById('uploadInfo');
            const status = document.getElementById('workflowStatus');
            
            // Fallback: Erstelle Elemente wenn sie fehlen (f√ºr Robustheit)
            if (!uploadInfo) {
                console.warn('[UPLOAD] uploadInfo Element nicht gefunden, erstelle Fallback');
                const container = document.querySelector('#workflowSidebar');
                if (container) {
                    const fallback = document.createElement('div');
                    fallback.id = 'uploadInfo';
                    fallback.className = 'small text-muted mt-2';
                    container.appendChild(fallback);
                } else {
                    console.error('[UPLOAD] Konnte uploadInfo Element nicht erstellen - Container nicht gefunden');
                    alert('Fehler: Upload-Interface nicht gefunden. Bitte Seite neu laden.');
                    return;
                }
            }
            
            if (!status) {
                console.warn('[UPLOAD] workflowStatus Element nicht gefunden, erstelle Fallback');
                const container = document.querySelector('#workflowSidebar');
                if (container) {
                    const fallback = document.createElement('div');
                    fallback.id = 'workflowStatus';
                    fallback.className = 'small text-muted mb-3';
                    fallback.innerHTML = 'Noch kein Upload.';
                    container.insertBefore(fallback, container.firstChild);
                } else {
                    console.error('[UPLOAD] Konnte workflowStatus Element nicht erstellen - Container nicht gefunden');
                    // Weiter machen, aber ohne Status-Anzeige
                }
            }
            
            // Upload-Status anzeigen
            uploadInfo.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Lade hoch: ${file.name} (${(file.size/1024).toFixed(1)} KB)`;
            uploadInfo.className = 'small text-info mt-2';
            
            try {
                // Upload √ºber API
                const result = await apiUploadCsv(file);
                
                // Erfolg anzeigen - verwende direkte Extraktion wie im Backup (kompatibler)
                const stagedPath = result.stored_path || result.staged_path || result.staging_file || result.filename || null;
                
                // Debug: Logge die Antwort-Struktur
                console.log('[UPLOAD] Upload-Response:', result);
                console.log('[UPLOAD] stagedPath:', stagedPath);
                
                // Aktualisiere LAST_UPLOAD_PATH f√ºr sp√§tere Verwendung
                LAST_UPLOAD_PATH = stagedPath;
                
                if (stagedPath && stagedPath !== 'undefined' && stagedPath !== 'null' && typeof stagedPath === 'string' && stagedPath.trim() !== '') {
                    // Zeige nur Dateiname, nicht den ganzen Pfad (f√ºr bessere Lesbarkeit)
                    const fileName = stagedPath.split(/[/\\]/).pop() || stagedPath;
                    uploadInfo.innerHTML = `<i class="fas fa-check text-success"></i> Upload erfolgreich: ${fileName}`;
                    uploadInfo.className = 'small text-success mt-2';
                    
                    // Workflow-Status aktualisieren
                    if (status) {
                        status.innerHTML = `<span class="text-success">‚úì Datei hochgeladen: ${file.name}</span>`;
                        status.className = 'small text-success mb-3';
                    }
                    
                    // Automatisch Match starten (optional, nicht kritisch - Workflow macht das auch)
                    // Fehler werden still behandelt, da Match nicht kritisch ist
                    loadMatchForFile(stagedPath).catch(err => {
                        // Match-Fehler sind nicht kritisch - Workflow funktioniert trotzdem
                        console.log('[MATCH] Match optional fehlgeschlagen (nicht kritisch):', err.message);
                    });
                } else {
                    console.error('[UPLOAD] Kein g√ºltiger Pfad gefunden in Response:', result);
                    uploadInfo.innerHTML = `<i class="fas fa-exclamation-triangle text-warning"></i> Upload unvollst√§ndig: ${file.name} (kein Pfad in Response)`;
                    uploadInfo.className = 'small text-warning mt-2';
                    if (status) {
                        status.innerHTML = `<span class="text-warning">‚ö† Upload unvollst√§ndig: Kein g√ºltiger Pfad in Server-Antwort</span>`;
                        status.className = 'small text-warning mb-3';
                    }
                    throw new Error('Upload unvollst√§ndig: Server hat keinen g√ºltigen Pfad zur√ºckgegeben');
                }
                
            } catch (error) {
                console.error('Upload-Fehler:', error);
                uploadInfo.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> Fehler: ${error.message}`;
                uploadInfo.className = 'small text-danger mt-2';
                
                status.innerHTML = `<span class="text-danger">‚úó Upload fehlgeschlagen: ${error.message}</span>`;
                status.className = 'small text-danger mb-3';
            }
        }

        async function loadMatchForFile(filePath) {
            // Pr√ºfe ob filePath vorhanden ist (fr√ºhe Validierung)
            if (!filePath || filePath === 'undefined' || filePath === 'null' || filePath === undefined || typeof filePath !== 'string' || filePath.trim() === '') {
                // Match ist optional - nur in Console loggen
                console.log('[MATCH] Kein g√ºltiger Dateipfad angegeben, √ºberspringe Match (optional)', {filePath});
                // Keine UI-Meldung - Match ist nicht kritisch
                return;
            }
            
            // Fallback: Verwende LAST_UPLOAD_PATH wenn filePath fehlt
            const pathToUse = filePath || LAST_UPLOAD_PATH;
            if (!pathToUse) {
                uiError('Keine hochgeladene Datei im Kontext. Erst CSV hochladen.');
                return;
            }
            
            try {
                // URL-Encoding f√ºr file-Parameter
                const r = await fetch(`/api/tourplan/match?file=${encodeURIComponent(pathToUse)}`);
                
                if (!r.ok) {
                    throw new Error(`match failed ${r.status}`);
                }
                
                // Nur einmal lesen - direkt JSON
                const matchData = await r.json();
                
                // Match-Daten verarbeiten (bestehende Logik)
                if (matchData.items && matchData.items.length > 0) {
                    // Match erfolgreich - nur in Console loggen (optional, nicht kritisch)
                    console.log(`[MATCH] Match erfolgreich: ${matchData.items.length} Adressen verarbeitet`);
                    console.log('Match-Daten:', matchData);
                    
                    // WICHTIG: Rendere Match-Daten in Tour√ºbersicht
                    renderToursFromMatch(matchData);
                } else {
                    // Keine Adressen - auch nicht kritisch
                    console.log('[MATCH] Match: Keine Adressen gefunden (optional)');
                }
                
            } catch (error) {
                // Match-Fehler sind nicht kritisch - Workflow funktioniert trotzdem
                // Nur in Console loggen, keine alarmierende UI-Meldung
                console.log('[MATCH] Match optional fehlgeschlagen (nicht kritisch):', error.message);
                // Keine updateWorkflowStatus() - Match ist optional
            }
        }
        
        // Hilfsfunktion f√ºr UI-Fehler
        function uiError(msg) {
            console.error(msg);
            alert(msg);
        }
        
        // WICHTIG: Zentrale Fehleranzeige f√ºr verschiedene HTTP-Status-Codes
        function showErrorBanner(statusCode, message, traceId = null) {
            // Entferne bestehende Banner
            const existingBanner = document.getElementById('error-banner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            // Erstelle neues Banner
            const banner = document.createElement('div');
            banner.id = 'error-banner';
            banner.className = 'alert alert-dismissible fade show';
            banner.style.cssText = 'position: fixed; top: 70px; left: 50%; transform: translateX(-50%); z-index: 9999; min-width: 400px; max-width: 800px;';
            
            let alertClass = 'alert-danger';
            let icon = 'fa-exclamation-triangle';
            let title = 'Fehler';
            
            // Status-Code-spezifische Behandlung
            if (statusCode === 429) {
                // 429 = Too Many Requests (Quota √ºberschritten)
                alertClass = 'alert-warning';
                icon = 'fa-hourglass-half';
                title = 'Quota √ºberschritten';
                message = message || 'Zu viele Anfragen. Bitte warten Sie einen Moment und versuchen Sie es erneut.';
            } else if (statusCode === 503) {
                // 503 = Service Unavailable (OSRM down, transient)
                alertClass = 'alert-info';
                icon = 'fa-info-circle';
                title = 'Service vor√ºbergehend nicht verf√ºgbar';
                message = message || 'Der Routing-Service ist vor√ºbergehend nicht verf√ºgbar. Es wird ein Fallback verwendet.';
            } else if (statusCode === 402) {
                // 402 = Payment Required (wird zu 429 gemappt, aber f√ºr Vollst√§ndigkeit)
                alertClass = 'alert-warning';
                icon = 'fa-credit-card';
                title = 'Quota √ºberschritten';
                message = message || 'API-Quota √ºberschritten. Bitte warten Sie einen Moment.';
            } else {
                // 500 oder andere Fehler
                alertClass = 'alert-danger';
                icon = 'fa-exclamation-circle';
                title = 'Fehler';
                message = message || 'Ein unerwarteter Fehler ist aufgetreten.';
            }
            
            banner.className = `alert ${alertClass} alert-dismissible fade show`;
            banner.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="fas ${icon} me-2"></i>
                    <div class="flex-grow-1">
                        <strong>${title}</strong><br>
                        <small>${message}</small>
                        ${traceId ? `<br><small class="text-muted">Trace-ID: ${traceId}</small>` : ''}
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            `;
            
            // F√ºge Banner nach Navbar ein
            const navbar = document.querySelector('nav');
            if (navbar) {
                navbar.parentNode.insertBefore(banner, navbar.nextSibling);
            } else {
                document.body.insertBefore(banner, document.body.firstChild);
            }
            
            // Auto-close nach 10 Sekunden (au√üer bei 500-Fehlern)
            if (statusCode !== 500) {
                setTimeout(() => {
                    if (banner.parentNode) {
                        banner.remove();
                    }
                }, 10000);
            }
        }
        
        // Hilfsfunktion: Zeigt Zeitbox-√úberschreitung an
        function showTimeboxWarning(tourName, actualTime, maxTime) {
            const warning = document.createElement('div');
            warning.className = 'alert alert-danger alert-dismissible fade show';
            warning.style.cssText = 'position: fixed; bottom: 20px; right: 20px; z-index: 9999; min-width: 300px; max-width: 400px;';
            warning.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="fas fa-clock me-2"></i>
                    <div class="flex-grow-1">
                        <strong>Zeitbox √ºberschritten</strong><br>
                        <small>Tour: ${tourName}</small><br>
                        <small>Zeit: ${actualTime.toFixed(1)} Min (Limit: ${maxTime} Min)</small>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            `;
            document.body.appendChild(warning);
            
            // Auto-close nach 15 Sekunden
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.remove();
                }
            }, 15000);
        }
        
        // WICHTIG: Zentrale fetch-Wrapper-Funktion mit automatischer Fehlerbehandlung
        async function fetchWithErrorHandling(url, options = {}) {
            return await safeExecuteAsync(async () => {
                try {
                    const response = await fetch(url, options);
                    
                    // Pr√ºfe HTTP-Status-Code
                    if (!response.ok) {
                        const statusCode = response.status;
                        let errorData = null;
                        let traceId = null;
                        
                        try {
                            const text = await response.text();
                            if (text) {
                                errorData = JSON.parse(text);
                                traceId = errorData.trace_id || null;
                            }
                        } catch (e) {
                            // Response ist kein JSON
                        }
                        
                        // Zeige Fehler-Banner basierend auf Status-Code
                        const errorMessage = errorData?.error_detail || errorData?.error || errorData?.detail || `HTTP ${statusCode}`;
                        showErrorBanner(statusCode, errorMessage, traceId);
                        
                        // Werfe Error weiter (f√ºr .catch() in aufrufendem Code)
                        throw new Error(`HTTP ${statusCode}: ${errorMessage}`);
                    }
                    
                    return response;
                } catch (error) {
                    // Network-Fehler oder andere Exceptions
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        showErrorBanner(0, 'Netzwerk-Fehler: Server nicht erreichbar', null);
                    }
                    throw error;
                }
            }, async () => {
                // Fallback: Gib null zur√ºck statt Fehler zu werfen
                console.warn('[FETCH] Fehler beim Fetch, verwende Fallback');
                return null;
            }, 'fetchWithErrorHandling');
        }

        // Frontend-Fetch Guard: Single-read JSON-Funktion (verhindert "body used already")
        async function fetchJSON(url, opts = {}) {
            const res = await fetch(url, opts);
            const ct = res.headers.get('content-type') || '';
            const payload = ct.includes('application/json') ? await res.json() : await res.text();
            
            if (!res.ok) {
                throw { status: res.status, body: payload };
            }
            
            return payload;
        }


        // Live-Geocoding-Progress anzeigen
        let geocodingProgressInterval = null;
        
        function startGeocodingProgress(sessionId) {
            const progressDiv = document.getElementById('geocodingProgress');
            if (!progressDiv) {
                // Progress-Div erstellen falls nicht vorhanden
                const statusDiv = document.getElementById('workflowStatus');
                const newDiv = document.createElement('div');
                newDiv.id = 'geocodingProgress';
                newDiv.className = 'alert alert-info mt-2';
                newDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span id="progressText">Lade...</span>';
                statusDiv.after(newDiv);
            }
            
            // Polling alle 500ms
            geocodingProgressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/workflow/geocoding-progress/${sessionId}`);
                    const progress = await response.json();
                    
                    const progressDiv = document.getElementById('geocodingProgress');
                    const progressText = document.getElementById('progressText');
                    
                    if (!progress || progress.status === 'completed' || progress.status === 'idle') {
                        if (geocodingProgressInterval) {
                            clearInterval(geocodingProgressInterval);
                            geocodingProgressInterval = null;
                        }
                        if (progressDiv && progress.status === 'completed') {
                            progressDiv.className = 'alert alert-success mt-2';
                            progressDiv.innerHTML = `<i class="fas fa-check-circle"></i> Geocoding abgeschlossen! ${progress.processed}/${progress.total} verarbeitet (${progress.db_hits || 0} DB, ${progress.geoapify_calls || 0} Geoapify)`;
                            setTimeout(() => {
                                if (progressDiv) {
                                    progressDiv.style.display = 'none';
                                    progressDiv.className = '';
                                    progressDiv.innerHTML = '';
                                }
                            }, 3000);
                        } else if (progressDiv && (progress.status === 'idle' || !progress)) {
                            // Session nicht mehr aktiv oder Progress beendet - verstecken
                            progressDiv.style.display = 'none';
                            progressDiv.className = '';
                            progressDiv.innerHTML = '';
                        }
                        return;
                    }
                    
                    const percentage = progress.total > 0 ? Math.round((progress.processed / progress.total) * 100) : 0;
                    const stats = `DB: ${progress.db_hits || 0} | Geoapify: ${progress.geoapify_calls || 0} | Fehler: ${progress.errors || 0}`;
                    
                    if (progressText) {
                        progressText.innerHTML = `
                            <strong>${progress.current || 'Verarbeite...'}</strong><br>
                            <small>${progress.processed}/${progress.total} (${percentage}%) | ${stats}</small>
                        `;
                    }
                    
                    // Progress-Bar aktualisieren
                    let progressBar = document.getElementById('geocodingProgressBar');
                    if (!progressBar) {
                        progressBar = document.createElement('div');
                        progressBar.id = 'geocodingProgressBar';
                        progressBar.className = 'progress mt-2';
                        progressBar.style.height = '20px';
                        progressBar.innerHTML = '<div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>';
                        progressDiv.appendChild(progressBar);
                    }
                    const bar = progressBar.querySelector('.progress-bar');
                    if (bar) {
                        bar.style.width = `${percentage}%`;
                        bar.textContent = `${percentage}%`;
                    }
                    
                } catch (error) {
                    console.error('Progress-Fehler:', error);
                }
            }, 500); // Alle 500ms aktualisieren
        }
        
        function stopGeocodingProgress() {
            if (geocodingProgressInterval) {
                clearInterval(geocodingProgressInterval);
                geocodingProgressInterval = null;
            }
            // Verstecke und entferne das Progress-Element
            const progressDiv = document.getElementById('geocodingProgress');
            if (progressDiv) {
                progressDiv.style.display = 'none';
                progressDiv.className = '';
                progressDiv.innerHTML = '';
            }
        }

        // Daten aktualisieren
        // WICHTIG: Speichere als _runWorkflowFull und √ºberschreibe window.runWorkflow
        window._runWorkflowFull = async function() {
            console.log('[WORKFLOW] _runWorkflowFull() aufgerufen');
            
            const fileInput = document.getElementById('csvFile');
            if (!fileInput) {
                const errorMsg = 'Fehler: Datei-Input nicht gefunden. Bitte Seite neu laden.';
                console.error('[WORKFLOW]', errorMsg);
                alert(errorMsg);
                updateWorkflowStatus(`<span class="text-danger">${errorMsg}</span>`);
                return;
            }
            
            const file = fileInput.files[0];
            console.log('[WORKFLOW] Datei:', file ? file.name : 'KEINE DATEI');

            if (!file) {
                const errorMsg = 'Bitte w√§hlen Sie zuerst eine CSV-Datei aus!';
                console.warn('[WORKFLOW]', errorMsg);
                alert(errorMsg);
                updateWorkflowStatus(`<span class="text-warning">${errorMsg}</span>`);
                return;
            }
            
            console.log('[WORKFLOW] Starte Workflow f√ºr:', file.name);

            try {
                updateWorkflowStatus('<span class="text-info">Workflow wird ausgef√ºhrt...</span>');
                
                // Progress-Div anzeigen
                const statusDiv = document.getElementById('workflowStatus');
                let progressDiv = document.getElementById('geocodingProgress');
                if (!progressDiv) {
                    progressDiv = document.createElement('div');
                    progressDiv.id = 'geocodingProgress';
                    progressDiv.className = 'alert alert-info mt-2';
                    progressDiv.style.display = 'block';
                    progressDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span id="progressText">Starte Geocoding...</span>';
                    statusDiv.after(progressDiv);
                } else {
                    progressDiv.style.display = 'block';
                    progressDiv.className = 'alert alert-info mt-2';
                }

                // Verwende den korrekten Workflow-Endpoint
                const formData = new FormData();
                formData.append('file', file);

                // Starte Progress-Polling VOR dem Upload (l√§uft parallel)
                // Die session_id wird im Backend generiert, wir pollen einfach eine generische Session
                // ODER: Wir warten auf die erste Response und starten dann
                
                const response = await fetch('/api/workflow/upload', {
                    method: 'POST',
                    body: formData
                });

                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error("JSON Parsing Fehler:", e, "Rohe Antwort:", responseText);
                    updateWorkflowStatus(`<span class="text-danger">Workflow fehlgeschlagen: Ung√ºltige Server-Antwort (${response.status}). Details: ${responseText.substring(0, 100)}...</span>`);
                    stopGeocodingProgress();
                    return; 
                }

                // Debug: Logge die Antwort-Struktur
                console.log('[WORKFLOW] Backend-Response:', data);
                console.log('[WORKFLOW] Touren gefunden:', data.tours?.length || 0);
                console.log('[WORKFLOW] Erste Tour:', data.tours?.[0]);
                
                // Live-Progress starten falls session_id vorhanden
                // (Auch wenn Upload bereits fertig ist, zeigt es finale Stats)
                if (data.geocoding_session_id && data.counts) {
                    // Nur starten wenn noch nicht alle verarbeitet sind
                    const totalToProcess = (data.counts.ok || 0) + (data.counts.warn || 0) + (data.counts.bad || 0);
                    if (totalToProcess > 0) {
                        console.log('[WORKFLOW] Starte Live-Progress f√ºr Session:', data.geocoding_session_id);
                        startGeocodingProgress(data.geocoding_session_id);
                    } else {
                        // Workflow bereits vollst√§ndig abgeschlossen - kein Progress n√∂tig
                        stopGeocodingProgress();
                    }
                } else {
                    // Keine Session-ID oder bereits abgeschlossen - Progress stoppen
                    stopGeocodingProgress();
                }
                
                if (response.ok && data.tours && data.tours.length > 0) {
                    // Workflow erfolgreich - Progress definitiv stoppen und UI zur√ºcksetzen
                    setTimeout(() => {
                        stopGeocodingProgress();
                    }, 2000); // Kurz warten falls noch finales Update kommt
                    
                    // WICHTIG: Erstelle Deep-Copy der Touren, damit sp√§tere √Ñnderungen nicht die Original-Daten beeintr√§chtigen
                    const toursCopy = JSON.parse(JSON.stringify(data.tours));
                    
                    workflowResult = { 
                        items: [], 
                        tours: toursCopy,  // Verwende Kopie
                        ok: data.counts?.ok || data.ok || 0, 
                        warn: data.counts?.warn || data.warn || 0, 
                        bad: data.counts?.bad || data.bad || 0 
                    };
                    parsedData = null;
                    
                    console.log('[WORKFLOW] Rendere Touren:', workflowResult.tours.length);
                    
                    // Geocoding-Stats anzeigen
                    if (data.geocoding_stats) {
                        const stats = data.geocoding_stats;
                        console.log(`[GEOCODE STATS] DB-Hits: ${stats.db_hits}, Geoapify-Calls: ${stats.geoapify_calls}, Fehler: ${stats.errors}`);
                    }
                    
                    // Erste Renderung mit originalen Daten
                    renderToursFromMatch(workflowResult);
                    
                    // KI-Status aktualisieren
                    updateAIStatus(`Workflow erfolgreich: ${data.tours.length} Touren geladen`, 'info');
                    
                    // WICHTIG: Automatische Optimierung ist DEAKTIVIERT
                    // Die Optimierung erfolgt nur manuell √ºber den Button "Routen optimieren"
                    // await autoOptimizeLargeTours(workflowResult.tours);  // DEAKTIVIERT
                    
                    // Sub-Routen Generator Button anzeigen wenn W-Touren vorhanden
                    updateSubRouteButtonVisibility();
                    
                    // Optimierte Touren im localStorage speichern f√ºr Tour-Management-Seite
                    // WICHTIG: Verwende workflowResult.tours (enth√§lt bereits optimierte Touren)
                    localStorage.setItem('optimizedTours', JSON.stringify({
                        tours: workflowResult.tours,  // Aktualisierte Touren (inkl. Optimierungen)
                        filename: file.name,
                        timestamp: new Date().toISOString(),
                        counts: {
                            ok: data.counts?.ok || data.ok || 0,
                            warn: data.counts?.warn || data.warn || 0,
                            bad: data.counts?.bad || data.bad || 0
                        }
                    }));
                    console.log('[WORKFLOW] Optimierte Touren im localStorage gespeichert f√ºr Tour-Management');
                    
                    // Speichere State f√ºr Wiederherstellung (nach Optimierung)
                    saveToursToStorage();
                    
                    // Clear-Button anzeigen
                    updateClearButtonVisibility();
                    
                    const consolidatedInfo = data.tours_consolidated 
                        ? ` (${data.tours_before_consolidation - data.tour_count} T-Touren zusammengelegt)`
                        : '';
                    
                    updateWorkflowStatus(`<span class="text-success">Workflow erfolgreich. ${data.counts?.ok || data.ok || 0} OK, ${data.counts?.warn || data.warn || 0} Warn, ${data.counts?.bad || data.bad || 0} Bad - ${workflowResult.tours.length} Touren generiert${consolidatedInfo}</span>`);
                } else if (response.ok) {
                    stopGeocodingProgress();
                    // Keine Touren gefunden - zeige detaillierte Fehler
                    let errorMsg = 'Keine Touren gefunden';
                    if (data.errors && data.errors.length > 0) {
                        errorMsg = data.errors[0];
                    } else if (data.detail) {
                        errorMsg = data.detail;
                    } else if (data.error) {
                        errorMsg = data.error;
                    }
                    
                    // Zeige auch Warnings falls vorhanden (inkl. Filter-Warnungen)
                    if (data.warnings && data.warnings.length > 0) {
                        // Pr√ºfe ob Filter-Warnung vorhanden
                        const filterWarning = data.warnings.find(w => w.includes('Filter entfernt') || w.includes('durch Filter-Liste'));
                        if (filterWarning) {
                            errorMsg = filterWarning;
                        } else {
                            errorMsg += ` (${data.warnings.length} Warnungen)`;
                        }
                        // Zeige erste 3 Warnungen in Konsole
                        console.warn('[WORKFLOW] Warnungen:', data.warnings.slice(0, 3));
                    }
                    
                    updateWorkflowStatus(`<span class="text-warning">Workflow abgeschlossen, aber keine Touren gefunden: ${errorMsg}</span>`);
                    console.error('Workflow Details:', data);
                    console.error('[WORKFLOW] M√∂gliche Ursachen: 1) Alle Touren durch Filter-Liste entfernt, 2) Geocoding fehlgeschlagen, 3) Parser findet keine Touren');
                } else {
                    updateWorkflowStatus(`<span class="text-danger">Workflow fehlgeschlagen: ${data.detail || data.error || 'HTTP ' + response.status}</span>`);
                }
            } catch (error) {
                console.error('Workflow Fehler:', error);
                stopGeocodingProgress();
                updateWorkflowStatus(`<span class="text-danger">Workflow Fehler: ${error.message}. Details in der Konsole.</span>`);
            }
        };
        
        // √úberschreibe window.runWorkflow mit vollst√§ndiger Funktion
        // WICHTIG: Pr√ºfe ob _runWorkflowFull existiert, sonst behalte Fallback
        if (typeof window._runWorkflowFull === 'function') {
            console.log('[WORKFLOW] √úberschreibe runWorkflow mit vollst√§ndiger Funktion');
            window.runWorkflow = window._runWorkflowFull;
        } else {
            console.warn('[WORKFLOW] _runWorkflowFull nicht gefunden, verwende Fallback');
        }

        // Stats-Box Toggle-Funktion
        function toggleStatsBox() {
            const toggle = document.getElementById('stats-toggle');
            const statsBox = document.getElementById('stats-box');
            const statsContent = document.getElementById('stats-content');
            const toggleLabel = document.getElementById('stats-toggle-label');
            
            if (!toggle || !statsBox) return;
            
            const isEnabled = toggle.checked;
            
            // Speichere Einstellung in localStorage
            localStorage.setItem('stats-box-enabled', isEnabled ? 'true' : 'false');
            
            if (isEnabled) {
                // An: Zeige Box und lade Daten
                statsBox.style.display = 'block';
                if (statsContent) {
                    statsContent.style.opacity = '1';
                    statsContent.style.filter = 'none';
                }
                toggleLabel.textContent = 'An';
                toggleLabel.style.color = '';
                loadStatsBox();
            } else {
                // Aus: Verstecke Inhalt (Box bleibt sichtbar, aber grau)
                if (statsContent) {
                    statsContent.style.opacity = '0.4';
                    statsContent.style.filter = 'grayscale(100%)';
                }
                toggleLabel.textContent = 'Aus';
                toggleLabel.style.color = '#6c757d';
            }
        }
        
        // Lade Toggle-Status beim Start
        function initStatsToggle() {
            const toggle = document.getElementById('stats-toggle');
            const savedState = localStorage.getItem('stats-box-enabled');
            
            if (toggle) {
                // Standard: An (wenn nicht gespeichert)
                toggle.checked = savedState !== 'false';
                toggleStatsBox();
            }
        }

        // Stats-Box laden
        async function loadStatsBox() {
            // Pr√ºfe ob Toggle aktiviert ist
            const toggle = document.getElementById('stats-toggle');
            const statsBox = document.getElementById('stats-box');
            
            if (toggle && !toggle.checked) {
                // Toggle aus: Box verstecken
                if (statsBox) {
                    statsBox.style.display = 'none';
                }
                return; // Nicht laden wenn ausgeschaltet
            }
            
            // Toggle an: Box anzeigen
            if (statsBox) {
                statsBox.style.display = 'block';
            }
            
            try {
                const response = await fetch('/api/stats/overview');
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (!response.ok) {
                    // Bei Fehler: Zeige Fehlermeldung in der Box
                    const statsContent = document.getElementById('stats-content');
                    if (statsContent) {
                        let errorData = { error: 'Unbekannter Fehler' };
                        try {
                            errorData = JSON.parse(responseText);
                        } catch (e) {
                            // Fallback wenn kein JSON
                            errorData = { error: responseText.substring(0, 100) || 'Unbekannter Fehler' };
                        }
                        statsContent.innerHTML = `
                            <div class="alert alert-warning mb-0" style="font-size: 0.85em;">
                                <i class="fas fa-exclamation-triangle"></i> 
                                <strong>Fehler:</strong> ${errorData.error || 'Stats-Aggregation fehlgeschlagen'}<br>
                                <small>${errorData.detail || 'Bitte Server-Logs pr√ºfen'}</small>
                            </div>
                        `;
                    }
                    console.error('[STATS] Stats-API Fehler:', response.status, errorData);
                    return;
                }
                
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error('[STATS] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                    throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                }
                
                // Pr√ºfe ob Fehler in Response (sollte nicht vorkommen bei 200, aber sicherheitshalber)
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Stelle normale Stats-Anzeige wieder her (falls sie durch Fehler √ºberschrieben wurde)
                const statsContent = document.getElementById('stats-content');
                if (statsContent && !statsContent.querySelector('.row')) {
                    statsContent.innerHTML = `
                        <div class="row mb-2">
                            <div class="col-8"><span>Touren (Monat):</span></div>
                            <div class="col-4 text-end"><b id="stat-tours-month">‚Äì</b></div>
                        </div>
                        <div class="row mb-2">
                            <div class="col-8"><span>Stops √ò pro Tour:</span></div>
                            <div class="col-4 text-end"><b id="stat-stops-avg">‚Äì</b></div>
                        </div>
                        <div class="row">
                            <div class="col-8"><span>KM (OSRM):</span></div>
                            <div class="col-4 text-end"><b id="stat-km-osrm">‚Äì</b></div>
                        </div>
                    `;
                }
                
                // F√ºlle Daten ein
                const toursEl = document.querySelector('#stat-tours-month');
                const stopsEl = document.querySelector('#stat-stops-avg');
                const kmEl = document.querySelector('#stat-km-osrm');
                
                if (toursEl) toursEl.textContent = data.monthly_tours ?? '0';
                if (stopsEl) stopsEl.textContent = data.avg_stops?.toFixed(1) ?? '0';
                if (kmEl) kmEl.textContent = data.km_osrm_month?.toFixed(1) ?? '0';
                
                // Box anzeigen (sollte bereits angezeigt sein, aber sicherheitshalber)
                if (statsBox && toggle && toggle.checked) {
                    statsBox.style.display = 'block';
                }
            } catch (e) {
                // Bei unerwarteten Fehlern: Zeige Fehlermeldung
                const statsContent = document.getElementById('stats-content');
                if (statsContent) {
                    statsContent.innerHTML = `
                        <div class="alert alert-danger mb-0" style="font-size: 0.85em;">
                            <i class="fas fa-times-circle"></i> 
                            <strong>Fehler:</strong> ${e.message || 'Unbekannter Fehler beim Laden der Statistiken'}
                        </div>
                    `;
                }
                console.error('[STATS] Fehler beim Laden der Stats:', e);
            }
        }

        // OSRM-Badge aktualisieren
        async function refreshOsrmBadge() {
            try {
                const r = await fetch('/health/osrm');
                const j = await r.json();
                const badge = document.getElementById('osrmStatus');
                if (badge) {
                    if (j.ok) {
                        badge.innerHTML = '<i class="fas fa-route text-success"></i> OSRM online';
                    } else {
                        badge.innerHTML = '<i class="fas fa-route text-danger"></i> OSRM offline';
                    }
                }
            } catch {
                const badge = document.getElementById('osrmStatus');
                if (badge) {
                    badge.innerHTML = '<i class="fas fa-route text-danger"></i> OSRM offline';
                }
            }
        }
        
        // Status-Daten laden (OSRM + LLM + DB)
        async function loadStatusData() {
            try {
                // Stats-Toggle initialisieren
                initStatsToggle();
                // Stats-Box laden (wenn aktiviert)
                await loadStatsBox();
                
                // OSRM-Badge aktualisieren
                await refreshOsrmBadge();
                
                // OSRM-Status abfragen
                try {
                    const osrmResponse = await fetch('/health/osrm');
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const osrmResponseText = await osrmResponse.text();
                    let osrmData = {};
                    try {
                        osrmData = JSON.parse(osrmResponseText);
                    } catch (e) {
                        console.error('[STATUS] OSRM-Response JSON Parsing Fehler:', e);
                    }
                    
                    // WICHTIG: OSRM-Endpoint gibt {"ok": true/false} zur√ºck, nicht {"status": "ok"}
                    if (osrmResponse.ok && osrmData.ok === true) {
                        updateOSRMStatus({
                            available: true,
                            message: 'OSRM erreichbar',
                            url: osrmData.url || 'unknown'
                        });
                    } else if (osrmResponse.status === 404) {
                        // 404 bedeutet Endpoint nicht gefunden - wahrscheinlich Router-Problem oder Server muss neu gestartet werden
                        console.error('[STATUS] OSRM-Endpoint nicht gefunden (404) - Router m√∂glicherweise nicht registriert oder Server muss neu gestartet werden');
                        updateOSRMStatus({
                            available: false,
                            message: 'OSRM-Endpoint nicht gefunden (404) - Server neu starten?',
                            url: 'unknown'
                        });
                    } else {
                        // 503 (Service Unavailable) oder andere Fehler
                        updateOSRMStatus({
                            available: false,
                            message: osrmData.reason || (osrmResponse.status === 503 ? 'OSRM Service Unavailable' : 'OSRM nicht erreichbar'),
                            url: osrmData.url || 'unknown'
                        });
                    }
                } catch (e) {
                    updateOSRMStatus({
                        available: false,
                        message: 'OSRM-Pr√ºfung fehlgeschlagen',
                        url: 'unknown'
                    });
                }
                
                // LLM-Status abfragen
                try {
                    const llmResponse = await fetch('/api/workflow/status');
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const llmResponseText = await llmResponse.text();
                    let llmData = {};
                    try {
                        llmData = JSON.parse(llmResponseText);
                    } catch (e) {
                        console.error('[STATUS] LLM-Response JSON Parsing Fehler:', e);
                    }
                    
                    if (llmResponse.ok) {
                        // LLM ist verf√ºgbar wenn:
                        // - llm_status ist "enabled" oder "No calls made" (bedeutet LLM ist konfiguriert)
                        // - llm_model ist vorhanden und nicht "N/A"
                        // - workflow_engine existiert (bedeutet System ist verf√ºgbar)
                        const llmStatus = llmData.llm_status || '';
                        const llmModel = llmData.llm_model || 'N/A';
                        const hasWorkflowEngine = llmData.workflow_engine && llmData.workflow_engine.length > 0;
                        
                        // WICHTIG: "No calls made" bedeutet LLM ist konfiguriert und verf√ºgbar, nur noch nicht verwendet
                        const llmAvailable = (
                            llmStatus === 'enabled' || 
                            llmStatus === 'No calls made' ||  // "No calls made" bedeutet LLM ist konfiguriert
                            (llmModel && llmModel !== 'N/A') ||
                            hasWorkflowEngine
                        );
                        
                        updateLLMStatus({
                            available: llmAvailable,
                            provider: llmModel !== 'N/A' ? llmModel : (hasWorkflowEngine ? 'OpenAI (konfiguriert)' : 'offline')
                        });
                    } else {
                        updateLLMStatus({available: false, provider: 'offline'});
                    }
                } catch (e) {
                    updateLLMStatus({available: false, provider: 'offline'});
                }
                
                // DB-Status abfragen
                try {
                    const dbResponse = await fetch('/health/db');
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const dbResponseText = await dbResponse.text();
                    let dbData;
                    try {
                        dbData = JSON.parse(dbResponseText);
                    } catch (e) {
                        console.error('[STATUS] DB-Response JSON Parsing Fehler:', e, 'Rohe Antwort:', dbResponseText);
                        dbData = { status: 'offline', error: 'Ung√ºltige Server-Antwort' };
                    }
                    
                    // WICHTIG: DB-Endpoint gibt {"ok": true/false} zur√ºck, nicht {"status": "online"}
                    if (dbResponse.ok && dbData.ok === true) {
                        // HTTP 200 und ok: true bedeutet DB ist online
                        dbData.status = 'online';
                        // Tabellen-Info aus Response √ºbernehmen (falls vorhanden)
                        if (!dbData.tables && dbResponse.ok) {
                            // Tabellen-Info k√∂nnte in separatem Feld sein
                            dbData.tables = dbData.tables || [];
                        }
                    } else if (dbResponse.status === 503) {
                        // 503 bedeutet Service Unavailable
                        dbData.status = 'offline';
                    } else {
                        // Andere Fehler
                        dbData = { status: 'offline', error: dbData.error || 'DB-Endpoint nicht erreichbar' };
                    }
                    updateDBStatus(dbData);
                } catch (e) {
                    console.error('[STATUS] DB-Status-Fehler:', e);
                    updateDBStatus({ status: 'offline', error: e.message });
                }
            } catch (error) {
                console.error('Fehler beim Laden der Status-Daten:', error);
                updateOSRMStatus({available: false, message: 'Fehler', url: 'unknown'});
                updateLLMStatus({available: false, provider: 'offline'});
                updateDBStatus({status: 'offline', error: error.message});
            }
        }

        // OSRM-Status aktualisieren
        function updateOSRMStatus(data) {
            const osrmStatus = document.getElementById('osrmStatus');
            if (!osrmStatus) return;
            
            if (data.available) {
                osrmStatus.innerHTML = `<i class="fas fa-route text-success"></i> OSRM online`;
                osrmStatus.title = `OSRM: ${data.message} (${data.url})`;
            } else {
                osrmStatus.innerHTML = `<i class="fas fa-route text-danger"></i> OSRM offline`;
                osrmStatus.title = `OSRM: ${data.message} (${data.url})`;
            }
        }

        // LLM-Status aktualisieren
        function updateLLMStatus(data) {
            const llmStatus = document.getElementById('llmStatus');
            if (data.available) {
                llmStatus.innerHTML = `<i class="fas fa-circle text-success"></i> LLM ${data.provider}`;
                } else {
                llmStatus.innerHTML = `<i class="fas fa-circle text-danger"></i> LLM offline`;
            }
        }

        // DB-Status aktualisieren
        function updateDBStatus(data) {
            const dbStatus = document.getElementById('dbStatus');
            if (!dbStatus) return;
            
            // Pr√ºfe sowohl 'status' als auch HTTP-Status-Code
            const isOnline = data && (data.status === 'online' || (data.status !== 'offline' && !data.error));
            
            if (isOnline) {
                // Tabellen-Liste formatieren (nur Anzahl anzeigen, nicht alle Namen)
                let tablesInfo = '';
                if (data.tables) {
                    if (typeof data.tables === 'string') {
                        const tableList = data.tables.split(', ');
                        tablesInfo = `${tableList.length} Tabellen`;
                    } else if (Array.isArray(data.tables)) {
                        tablesInfo = `${data.tables.length} Tabellen`;
                    } else {
                        tablesInfo = 'online';
                    }
                } else if (data.table_count) {
                    tablesInfo = `${data.table_count} Tabellen`;
                } else {
                    tablesInfo = 'online';
                }
                dbStatus.innerHTML = `<i class="fas fa-database text-success"></i> DB online (${tablesInfo})`;
            } else {
                dbStatus.innerHTML = `<i class="fas fa-database text-danger"></i> DB offline`;
            }
        }

        // CSV Tour Processor
        async function processAllCSV() {
            try {
                console.log('Starte CSV Tour Processing...');
                
                const response = await fetch('/api/tourplan/bulk-process-all', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (response.ok) {
                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (e) {
                        console.error('[CSV-PROCESS] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                        throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                    }
                    console.log('CSV Tour Processing erfolgreich:', result);
                    alert(`[OK] CSV Tour Processing erfolgreich!\n\n` +
                          `Kunden verarbeitet: ${result.total_customers || 0}\n` +
                          `Eindeutige Kunden: ${result.unique_customers || 0}\n` +
                          `In DB gespeichert: ${result.saved_customers || 0}\n` +
                          `Touren gefunden: ${result.tours_found || 0}\n` +
                          `Touren gespeichert: ${result.saved_tours || 0}\n` +
                          `BAR-Touren: ${result.bar_tours || 0}\n` +
                          `Normale Touren: ${result.normal_tours || 0}\n` +
                          `Geocoding Erfolg: ${result.geocoding_success || 0}\n` +
                          `Geocoding Fehler: ${result.geocoding_failed || 0}\n` +
                          `Geocoding Rate: ${result.geocoding_rate || '0%'}\n` +
                          `Dateien verarbeitet: ${result.files_processed || 0}`);
                    await refreshData();
                } else {
                    // responseText wurde bereits gelesen
                    let errorText = responseText;
                    try {
                        const errorData = JSON.parse(responseText);
                        errorText = errorData.error || errorData.detail || responseText;
                    } catch (e) {
                        // Kein JSON, verwende rohen Text
                    }
                    console.error('Fehler beim CSV Tour Processing:', errorText);
                    alert(`[FEHLER] Fehler beim CSV Tour Processing:\n${errorText}`);
                }
            } catch (error) {
                console.error('Fehler beim CSV Tour Processing:', error);
                alert(`[FEHLER] Fehler beim CSV Tour Processing:\n${error.message}`);
            }
        }

        // Touren-Details laden
        function renderToursFromParsedData() {
            if (!parsedData || !parsedData.tours) {
                renderEmptyTours();
                return;
            }

            // Touren nach Zeit sortieren
            const tours = (parsedData.tours || []).filter(passFilter);
            
            // Sortierung nach Zeit hinzuf√ºgen
            tours.sort((a, b) => {
                const timeA = extractTime(a.time || a.name || '');
                const timeB = extractTime(b.time || b.name || '');
                return timeA - timeB; // Aufsteigende Sortierung
            });

            if (!tours.length) {
                renderEmptyTours();
                return;
            }

            document.getElementById('tourSummary').textContent = `${tours.length} Touren ¬∑ ${parsedData.stats?.total_customers || 0} Kunden`;

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = tours.map((tour, index) => {
                const key = `parsed-${index}`;
                const barCount = tour.customers.filter(c => c.bar_flag).length;
                const badge = barCount ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCount} BAR</span>` : '';
                const normalizedCustomers = tour.customers.map(customer => ({
                    customer_number: customer.customer_number,
                    name: customer.name,
                    street: customer.street,
                    postal_code: customer.postal_code,
                    city: customer.city,
                    bar_flag: customer.bar_flag,
                    latitude: customer.latitude,
                    longitude: customer.longitude,
                    address: customer.resolved_address || customer.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [customer.street, customer.postal_code, customer.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '';
                })()
                }));

                allTourCustomers[key] = {
                    name: tour.name,
                    type: tour.tour_type,
                    time: tour.time,
                    customers: normalizedCustomers
                };
                
                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const cleanTourName = routeLetter ? (tour.name || '').replace(/\s[A-Z]$/, '').trim() : (tour.name || '');
                const stopsText = routeNumber 
                    ? `${tour.customer_count} Kunden ${routeNumber} ¬∑ ${tour.tour_type} ¬∑ ${tour.time || 'Zeit n/a'}`
                    : `${tour.customer_count} Kunden ¬∑ ${tour.tour_type} ¬∑ ${tour.time || 'Zeit n/a'}`;
                
                return `
                    <button class="list-group-item list-group-item-action position-relative" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${cleanTourName}</strong>${badge}
                                <div class="small text-muted">${stopsText}</div>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge bg-primary rounded-pill">${tour.customer_count}</span>
                                <button class="btn btn-sm btn-link p-0 text-secondary optimize-tour-btn" 
                                        data-tour-key="${key}" 
                                        data-tour-name="${tour.name}"
                                        data-stop-count="${tour.customer_count}"
                                        title="Tour mit AI optimieren"
                                        onclick="event.stopPropagation(); optimizeTour('${key}', '${tour.name}');">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = tours.length ? `parsed-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        // Hilfsfunktion zum Extrahieren der Zeit aus Tour-Namen
        function extractTime(timeString) {
            if (!timeString) return 9999; // Fallback f√ºr Touren ohne Zeit
            
            // Suche nach Zeit-Pattern: HH.MM oder HH:MM
            const timeMatch = timeString.match(/(\d{1,2})[.:](\d{2})/);
            if (timeMatch) {
                const hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                return hours * 60 + minutes; // Minuten seit Mitternacht
            }
            
            return 9999; // Fallback f√ºr unbekannte Formate
        }

        // ==========================================
        // HELPER: Einheitliche Base-ID-Extraktion
        // ==========================================
        function extractBaseTourId(tour) {
            // Priorit√§t: _base_tour_id > Extraktion aus tour_id > Extraktion aus name
            if (tour._base_tour_id) {
                return tour._base_tour_id;
            }
            
            const tourId = tour.tour_id || tour.name || '';
            if (!tourId) {
                return '';
            }
            
            // Entferne Sub-Route-Buchstaben (A, B, C, ...)
            // Entferne "Uhr Tour" / "Uhr BAR"
            return tourId
                .replace(/\s+[A-Z]$/, '')                    // " A", " B", etc.
                .replace(/\s*(Uhr\s*)?(Tour|BAR)$/i, '')    // "Uhr Tour", "Uhr BAR"
                .trim();
        }

        // ==========================================
        // HELPER: Eindeutiger Key f√ºr Tour
        // ==========================================
        function generateTourKey(tour) {
            const baseId = extractBaseTourId(tour);
            const subRoute = tour._sub_route || '';
            
            // WICHTIG: Behalte Punkt (.) f√ºr Zeit-Format (z.B. W-07.00)
            // Ersetze NUR problematische Sonderzeichen, BEHALTE Punkt und Bindestrich
            let normalizedBaseId = baseId.replace(/[^a-zA-Z0-9.\-]/g, '_');
            
            // Normalisiere mehrfache Unterstriche zu einem
            normalizedBaseId = normalizedBaseId.replace(/_+/g, '_');
            
            // Entferne f√ºhrende/abschlie√üende Unterstriche
            normalizedBaseId = normalizedBaseId.replace(/^_+|_+$/g, '');
            
            // Mit Sub-Route: workflow-W-07.00-A
            // Ohne Sub-Route: workflow-W-07.00
            return subRoute 
                ? `workflow-${normalizedBaseId}-${subRoute}`
                : `workflow-${normalizedBaseId}`;
        }


        // Rendert Touren basierend auf der urspr√ºnglichen CSV-Struktur
        function renderToursFromCSVStructure(matchData, fileName) {
            console.log('renderToursFromCSVStructure aufgerufen, matchData:', matchData);
            
            const items = matchData.items || [];
            if (!items.length) {
                console.log('Keine Items gefunden in matchData');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${items.length} Items aus CSV-Struktur`);
            document.getElementById('tourSummary').textContent = `${matchData.ok} OK, ${matchData.warn} Warn, ${matchData.bad} Bad`;

            // Gruppiere Items nach Tour-Zeit basierend auf der urspr√ºnglichen CSV-Struktur
            const tours = {};
            let currentTour = null;
            
            items.forEach((item, index) => {
                // Erkenne Tour-Zeilen basierend auf dem display_name
                const displayName = item.display_name || '';
                
                if (displayName.includes('Tour') || displayName.includes('BAR') || displayName.includes('Anlief')) {
                    // Das ist eine Tour-Zeile
                    currentTour = displayName;
                    if (!tours[currentTour]) {
                        tours[currentTour] = {
                            name: currentTour,
                            customers: [],
                            isBarTour: displayName.includes('BAR'),
                            time: extractTimeFromTourName(displayName)
                        };
                    }
                } else if (currentTour && displayName.trim()) {
                    // Das ist ein Kunde f√ºr die aktuelle Tour
                    tours[currentTour].customers.push({
                        customer_number: item.customer_number || item.id || '',
                        name: displayName,
                        street: item.resolved_address || '',
                        postal_code: '',
                        city: '',
                        bar_flag: tours[currentTour].isBarTour,
                        latitude: item.lat,
                        longitude: item.lon,
                        address: item.resolved_address || '',
                        status: item.status
                    });
                }
            });

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = Object.values(tours).map((tour, index) => {
                const key = `csv-${index}`;
                const customerCount = tour.customers.length;
                const okCount = tour.customers.filter(c => c.status === 'ok').length;
                const warnCount = tour.customers.filter(c => c.status === 'warn').length;
                const badCount = tour.customers.filter(c => c.status === 'bad').length;
                const barBadge = tour.isBarTour ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>` : '';
                
                allTourCustomers[key] = tour;

                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const isSubRoute = !!routeLetter;
                
                // Tourname ohne Buchstaben (f√ºr Anzeige)
                const cleanTourName = routeLetter ? (tour.name || '').replace(/\s[A-Z]$/, '').trim() : (tour.name || '');
                
                const baseTourId = tour._base_tour_id || cleanTourName?.split(' ')[0] || '';
                const routeIndex = tour._route_index !== undefined ? tour._route_index : index;
                const tourColor = tour._tour_color || getTourColor(baseTourId, routeIndex);
                
                // Border-Farbe f√ºr Sub-Routen
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // Status-Zeile mit Zahlen (wenn vorhanden)
                const statusText = routeNumber 
                    ? `${okCount} OK, ${warnCount} Warn, ${badCount} Bad ${routeNumber}`
                    : `${okCount} OK, ${warnCount} Warn, ${badCount} Bad`;
                
                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${cleanTourName}</strong>${barBadge}
                                <div class="small text-muted">${statusText}</div>
                            </div>
                            <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = Object.keys(tours).length ? `csv-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        // Hilfsfunktion zum Extrahieren der Zeit aus Tour-Namen (f√ºr Sortierung)
        function extractTimeFromTourName(tourName) {
            if (!tourName) return 9999;
            
            // Suche nach Zeit-Pattern: HH.MM oder HH:MM
            const timeMatch = tourName.match(/(\d{1,2})[.:](\d{2})/);
            if (timeMatch) {
                const hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                return hours * 60 + minutes; // Minuten seit Mitternacht
            }
            
            return 9999; // Fallback f√ºr Touren ohne Zeit
        }

        // Rendert Touren aus dem Match-Endpunkt oder Workflow-Ergebnis
        function renderToursFromMatch(matchData) {
            console.log('renderToursFromMatch aufgerufen, matchData:', matchData);
            
            // WICHTIG: Pr√ºfe ob matchData Sub-Routen enth√§lt
            const toursToRender = matchData.tours || [];
            const hasSubRoutesInData = toursToRender.some(t => t._sub_route || (t.tour_id && t.tour_id.match(/\s[A-Z]$/)));
            
            // WICHTIG: Pr√ºfe ob bereits Sub-Routen in allTourCustomers existieren
            const existingSubRoutes = Object.values(allTourCustomers).filter(t => t._sub_route || (t.name && t.name.match(/\s[A-Z]$/)));
            const hasExistingSubRoutes = existingSubRoutes.length > 0;
            
            console.log(`[RENDER] Sub-Routen-Check: Incoming=${hasSubRoutesInData}, Existing=${hasExistingSubRoutes}`);
            
            // KRITISCH: Wenn Sub-Routen existieren, NICHTS l√∂schen!
            // Grund: Sub-Routen wurden von updateToursWithSubRoutes() erstellt und d√ºrfen nicht √ºberschrieben werden!
            if (hasExistingSubRoutes && !hasSubRoutesInData) {
                console.log(`[RENDER] ‚ö†Ô∏è Sub-Routen existieren bereits - √ºberspringe L√∂schen, um Sub-Routen zu sch√ºtzen!`);
                // KEIN L√∂schen - Sub-Routen bleiben erhalten
            } else {
                // Normale Logik: L√∂sche alte Eintr√§ge nur wenn KEINE Sub-Routen existieren
                const baseTourIds = new Set();
                
                // Sammle alle Base-IDs mit Helper-Funktion
                toursToRender.forEach(tour => {
                    const baseId = extractBaseTourId(tour);  // ‚úÖ Helper verwenden
                    if (baseId) {
                        baseTourIds.add(baseId);
                    }
                });
                
                console.log(`[RENDER] Base-Tour-IDs gefunden:`, Array.from(baseTourIds));
                
                // L√∂sche ALLE Eintr√§ge, die zu diesen Touren geh√∂ren
                // ABER: Nur wenn es KEINE Sub-Routen sind!
                let deletedCount = 0;
                Object.keys(allTourCustomers).forEach(key => {
                    const tour = allTourCustomers[key];
                    const tourBaseId = extractBaseTourId(tour);  // ‚úÖ Helper verwenden
                    
                    // Pr√ºfe ob dieser Eintrag eine Sub-Route ist
                    const isSubRoute = tour._sub_route || (tour.name && tour.name.match(/\s[A-Z]$/));
                    
                    // L√∂sche NUR wenn:
                    // 1. Base-ID passt
                    // 2. KEINE Sub-Route ist
                    if (tourBaseId && baseTourIds.has(tourBaseId) && !isSubRoute) {
                        console.log(`[RENDER] L√∂sche alten Eintrag: ${key} (Tour: ${tourBaseId})`);
                        delete allTourCustomers[key];
                        deletedCount++;
                    } else if (isSubRoute) {
                        console.log(`[RENDER] √úberspringe Sub-Route: ${key} (Tour: ${tour.name})`);
                    }
                });
                
                if (deletedCount > 0) {
                    console.log(`[RENDER] ${deletedCount} alte Eintr√§ge gel√∂scht`);
                }
            }
            
            // Unterst√ºtze sowohl 'tours' (vom Workflow) als auch 'items' (vom Match-Endpoint)
            const tours = matchData.tours || [];
            const items = matchData.items || [];
            
            if (tours.length > 0) {
                // Workflow-Format: Direkt Touren verwenden
                console.log(`Rendering ${tours.length} Touren aus Workflow`);
                // WICHTIG: Unterst√ºtze sowohl 'stops' als auch 'customers' (Workflow kann beide Formate liefern)
                const totalAddresses = tours.reduce((sum, t) => sum + (t.stops?.length || t.customers?.length || 0), 0);
                const okCount = matchData.ok || matchData.counts?.ok || 0;
                const warnCount = matchData.warn || matchData.counts?.warn || 0;
                const badCount = matchData.bad || matchData.counts?.bad || 0;
                document.getElementById('tourSummary').textContent = `${okCount} OK, ${warnCount} Warn, ${badCount} Bad - ${tours.length} Touren`;
                
                // Hilfsfunktion: Extrahiere Basis-Tour-Name f√ºr Gruppierung (z.B. "W-07.00" aus "W-07.00 Uhr BAR" oder "W-07.00 Uhr Tour")
                function getTourBaseName(tourId) {
                    if (!tourId) return '';
                    // Entferne "Uhr BAR", "Uhr Tour", "BAR", "Tour" f√ºr Gruppierung
                    return tourId.replace(/\s*(Uhr\s*)?(BAR|Tour)$/i, '').trim();
                }
                
                // Hilfsfunktion: Pr√ºfe ob Tour eine BAR-Tour ist
                function isBarTour(tourId) {
                    return tourId && /BAR/i.test(tourId);
                }
                
                // Touren f√ºr Gruppierung vorbereiten und sortieren
                const toursWithMeta = tours.map((tour, index) => ({
                    ...tour,
                    index,
                    baseName: getTourBaseName(tour.tour_id),
                    isBar: isBarTour(tour.tour_id),
                    time: extractTimeFromTourName(tour.tour_id || '')
                }));
                
                // Intelligente Sortierung f√ºr verschiedene Tour-Typen
                // Hilfsfunktion: Pr√ºfe ob Tour eine W-Tour ist
                function isWTour(tourId) {
                    return tourId && /^W-\d+\.\d+/.test(tourId);
                }
                
                // Hilfsfunktion: Erkenne Tour-Typ
                function getTourType(tourId) {
                    if (!tourId) return 'other';
                    const upperId = tourId.toUpperCase();
                    
                    if (isWTour(tourId)) return 'w-tour';
                    if (/^T\d+/.test(tourId)) return 't-tour';  // T17, T71, T8
                    if (upperId.startsWith('BZ')) return 'bautzen';  // BZ, BZ-...
                    if (upperId.startsWith('CB')) return 'cottbus';  // CB, CB-...
                    if (upperId === 'DBD') return 'dbd';  // DBD (sollte letzter sein)
                    if (upperId === 'DVD') return 'dvd';  // DVD (Nachtlieferung, unwichtig)
                    
                    return 'other';
                }
                
                // Hilfsfunktion: Extrahiere Tour-Nummer f√ºr Sortierung
                function extractTourNumber(tourId) {
                    if (!tourId) return 9999;
                    
                    // T-Touren: T17 -> 17, T71 -> 71
                    const tMatch = tourId.match(/^T(\d+)/);
                    if (tMatch) return parseInt(tMatch[1]);
                    
                    // W-Touren: W-07.00 -> 7.00
                    const wMatch = tourId.match(/^W-(\d+)\.(\d+)/);
                    if (wMatch) return parseFloat(`${wMatch[1]}.${wMatch[2]}`);
                    
                    // Andere: Extrahiere erste Zahl
                    const numMatch = tourId.match(/(\d+)/);
                    if (numMatch) return parseInt(numMatch[1]);
                    
                    return 9999;
                }
                
                // Hilfsfunktion: Extrahiere Zeit f√ºr Sortierung (Minuten seit Mitternacht)
                function getTimeForSort(tourId) {
                    const timeMatch = tourId.match(/(\d{1,2})[.:](\d{2})/);
                    if (timeMatch) {
                        const hours = parseInt(timeMatch[1]);
                        const minutes = parseInt(timeMatch[2]);
                        return hours * 60 + minutes;
                    }
                    return 9999; // Keine Zeit gefunden = ans Ende
                }
                
                toursWithMeta.sort((a, b) => {
                    const aType = getTourType(a.tour_id);
                    const bType = getTourType(b.tour_id);
                    
                    // 1. W-Touren ZUERST (ganz oben) - unabh√§ngig von Zeit
                    if (aType === 'w-tour' && bType !== 'w-tour') return -1;
                    if (aType !== 'w-tour' && bType === 'w-tour') return 1;
                    
                    // 2. Innerhalb der W-Touren: nach Zeit sortieren
                    if (aType === 'w-tour' && bType === 'w-tour') {
                        const aTime = getTimeForSort(a.tour_id);
                        const bTime = getTimeForSort(b.tour_id);
                        const aHasTime = aTime !== 9999;
                        const bHasTime = bTime !== 9999;
                        
                        // Wenn beide Zeit haben: nach Zeit sortieren
                        if (aHasTime && bHasTime) {
                            if (aTime !== bTime) {
                                return aTime - bTime;  // Aufsteigend: fr√ºhere Zeit zuerst
                            }
                            // Gleiche Zeit: BAR vor normal
                            if (a.isBar && !b.isBar) return -1;
                            if (!a.isBar && b.isBar) return 1;
                            return 0;
                        }
                        
                        // Wenn nur eine Zeit hat: die mit Zeit kommt zuerst
                        if (aHasTime && !bHasTime) return -1;
                        if (!aHasTime && bHasTime) return 1;
                        
                        // Beide ohne Zeit: BAR vor normal, dann alphabetisch
                        if (a.isBar && !b.isBar) return -1;
                        if (!a.isBar && b.isBar) return 1;
                        return (a.tour_id || '').localeCompare(b.tour_id || '');
                    }
                    
                    // 3. Bei anderen Touren (nicht W-Touren): PRIM√ÑR nach Zeit sortieren
                    const aTime = getTimeForSort(a.tour_id);
                    const bTime = getTimeForSort(b.tour_id);
                    const aHasTime = aTime !== 9999;
                    const bHasTime = bTime !== 9999;
                    
                    // Wenn beide eine Zeit haben: Zeit hat absoluten Vorrang
                    if (aHasTime && bHasTime) {
                        if (aTime !== bTime) {
                            return aTime - bTime;  // Aufsteigend: fr√ºhere Zeit zuerst (7:45 vor 18:00)
                        }
                        // Gleiche Zeit: BAR vor normal, dann Typ
                    }
                    
                    // Wenn nur eine Zeit hat: die mit Zeit kommt IMMER zuerst
                    if (aHasTime && !bHasTime) return -1; // Zeit-Tour kommt vor Tour ohne Zeit
                    if (!aHasTime && bHasTime) return 1; // Tour ohne Zeit kommt nach Zeit-Tour
                    
                    // 2. DBD und DVD ans Ende (nur wenn keine Zeit vorhanden)
                    if (aType === 'dbd' && bType !== 'dbd') return 1;
                    if (aType !== 'dbd' && bType === 'dbd') return -1;
                    if (aType === 'dvd' && bType !== 'dvd') return 1;
                    if (aType !== 'dvd' && bType === 'dvd') return -1;
                    
                    // 4. Gleicher Typ: Sortiere nach Nummer oder Name, dann BAR vor normal
                    if (aType === bType) {
                        // F√ºr W-Touren: bereits nach Zeit sortiert (oben)
                        if (aType === 'w-tour') {
                            // Gleiche Zeit: BAR vor normal
                            if (a.isBar && !b.isBar) return -1;
                            if (!a.isBar && b.isBar) return 1;
                            return 0;
                        }
                        
                        // F√ºr T-Touren: nach Nummer sortieren (wenn keine Zeit vorhanden)
                        if (aType === 't-tour' && !aHasTime && !bHasTime) {
                            const aNum = extractTourNumber(a.tour_id);
                            const bNum = extractTourNumber(b.tour_id);
                            if (aNum !== bNum) return aNum - bNum;
                            // Gleiche Nummer: BAR vor normal
                            if (a.isBar && !b.isBar) return -1;
                            if (!a.isBar && b.isBar) return 1;
                            return 0;
                        }
                        
                        // Gleiche Zeit bei gleichem Typ: BAR vor normal, dann alphabetisch
                        if (a.isBar && !b.isBar) return -1;
                        if (!a.isBar && b.isBar) return 1;
                        return (a.tour_id || '').localeCompare(b.tour_id || '');
                    }
                    
                    // 5. Verschiedene Typen (nur wenn keine Zeit vorhanden): Sortiere nach Priorit√§t
                    const typePriority = {
                        'w-tour': 1,
                        't-tour': 2,
                        'bautzen': 3,
                        'cottbus': 3,
                        'other': 4,
                        'dbd': 5,
                        'dvd': 6
                    };
                    const aPriority = typePriority[aType] || 4;
                    const bPriority = typePriority[bType] || 4;
                    if (aPriority !== bPriority) return aPriority - bPriority;
                    
                    // 6. Gleiche Priorit√§t: BAR vor normal, dann alphabetisch
                    if (a.isBar && !b.isBar) return -1;
                    if (!a.isBar && b.isBar) return 1;
                    return (a.tour_id || '').localeCompare(b.tour_id || '');
                });
                
                const tourList = document.getElementById('tourList');
                // WICHTIG: Leere Tour-Liste vor neuem Rendering, um Duplikate zu vermeiden
                tourList.innerHTML = '';
                
                tourList.innerHTML = toursWithMeta.map((tourMeta) => {
                    // WICHTIG: Verwende generateTourKey() f√ºr konsistente Keys mit allTourCustomers
                    const key = generateTourKey(tourMeta);
                    // WICHTIG: Unterst√ºtze sowohl 'stops' als auch 'customers' (Workflow kann beide Formate liefern)
                    const stops = tourMeta.stops || tourMeta.customers || [];
                    const customerCount = stops.length;
                    const isBar = tourMeta.isBar;
                    
                    // Kunden mit Koordinaten f√ºr die Karte vorbereiten
                    // WICHTIG: Verwende individuelles bar_flag pro Kunde (falls vorhanden), sonst Tour-Level bar_flag
                    // BAR-Flag hat Priorit√§t: Erst individuell, dann Tour-Level, dann false
                    const customers = stops.map(stop => {
                        // Bestimme bar_flag: Erst individuell, dann Tour-Level, dann false
                        let barFlag = false;
                        if (stop.bar_flag !== undefined) {
                            barFlag = !!stop.bar_flag; // Individuelles bar_flag hat h√∂chste Priorit√§t
                        } else if (isBar !== undefined) {
                            barFlag = !!isBar; // Tour-Level bar_flag als Fallback
                        }
                        
                        return {
                            customer_number: stop.order_id || stop.customer_number || '',
                            name: stop.customer || stop.name || 'Unbekannt',
                            street: stop.street || '',
                            postal_code: stop.postal_code || '',
                            city: stop.city || '',
                            bar_flag: barFlag,  // Explizit gesetztes bar_flag
                            latitude: stop.lat,
                            longitude: stop.lon,
                            address: stop.address || (() => {
                                const parts = [stop.street, stop.postal_code, stop.city].filter(Boolean);
                                return parts.join(', ') || '';
                            })(),
                            has_coordinates: stop.has_coordinates !== undefined ? stop.has_coordinates : (stop.lat && stop.lon),  // Flag f√ºr Warnungen
                            warning: stop.warning || null  // Warnung direkt beim Kunden
                        };
                    });
                    
                    // WICHTIG: Erstelle Eintr√§ge in allTourCustomers, ABER nur wenn sie noch nicht existieren!
                    // Grund: Beim initialen Rendering m√ºssen Eintr√§ge erstellt werden.
                    // ABER: Wenn updateToursWithSubRoutes() bereits Eintr√§ge erstellt hat, werden diese NICHT √ºberschrieben!
                    // key wurde bereits oben deklariert (Zeile 2527) - verwende diese Variable!
                    
                    // KRITISCH: Pr√ºfe ob dieser Tour eine Sub-Route entspricht
                    const isSubRouteInData = tourMeta._sub_route || (tourMeta.tour_id && tourMeta.tour_id.match(/\s[A-Z]$/));
                    
                    // Wenn Sub-Routen existieren, erstelle KEINE neuen Eintr√§ge f√ºr Haupttouren!
                    if (hasExistingSubRoutes && !isSubRouteInData) {
                        console.log(`[RENDER] ‚ö†Ô∏è √úberspringe Erstellung von Haupttour ${tourMeta.tour_id} - Sub-Routen existieren bereits!`);
                        // KEIN Erstellen - Sub-Routen haben Priorit√§t!
                    } else if (!allTourCustomers[key]) {
                        // Eintrag existiert noch nicht ‚Üí erstelle ihn
                        allTourCustomers[key] = {
                            name: tourMeta.tour_id || `Tour ${tourMeta.index + 1}`,
                            type: isBar ? 'BAR' : 'Workflow',
                            time: tourMeta.time,
                            customers: customers,
                            stops: stops,
                            optimization_method: tourMeta.optimization_method,
                            optimized: tourMeta.optimized,
                            reasoning: tourMeta.reasoning,
                            _base_tour_id: extractBaseTourId(tourMeta),
                            _sub_route: tourMeta._sub_route || (tourMeta.tour_id?.match(/\s([A-Z])$/) ? tourMeta.tour_id.match(/\s([A-Z])$/)[1] : null),
                            _tour_color: tourMeta._tour_color,
                            isBarTour: isBar
                        };
                        console.log(`[RENDER] Erstelle neuen Eintrag: ${key} (Tour: ${tourMeta.tour_id})`);
                    } else {
                        console.log(`[RENDER] Eintrag existiert bereits: ${key} (Tour: ${tourMeta.tour_id}) - √ºberspringe Erstellung`);
                    }
                    
                    // CSS-Klassen: W-Touren bekommen andere Farbe, BAR-Touren orange
                    const isWTour = /^W-\d+\.\d+/.test(tourMeta.tour_id || '');
                    const wTourClass = isWTour ? 'w-tour-highlight' : '';
                    
                    // BAR-Status: Pr√ºfe ob Tour BAR ist ODER ob einzelne Kunden BAR-Flag haben
                    const hasBarCustomers = customers.some(c => c.bar_flag === true);
                    const tourIsBar = isBar || hasBarCustomers;
                    const barCustomerCount = customers.filter(c => c.bar_flag === true).length;
                    
                    const barClass = tourIsBar ? 'bar-tour-highlight' : '';
                    const combinedClass = `${wTourClass} ${barClass}`.trim();
                    
                    // BAR-Badge: Zeige wenn Tour BAR ist oder BAR-Kunden vorhanden
                    const barBadge = tourIsBar 
                        ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCustomerCount > 0 ? barCustomerCount + ' ' : ''}BAR</span>` 
                        : '';
                    
                    // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                    const routeLetterMatch = (tourMeta.tour_id || '').match(/\s([A-Z])$/);
                    const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                    const isSubRoute = !!routeLetter;
                    
                    // Tourname ohne Buchstaben (f√ºr Anzeige)
                    const cleanTourName = routeLetter 
                        ? (tourMeta.tour_id || '').replace(/\s[A-Z]$/, '').trim() 
                        : (tourMeta.tour_id || `Tour ${tourMeta.index + 1}`);
                    
                    // WICHTIG: baseTourId mit Helper-Funktion extrahieren
                    const baseTourId = extractBaseTourId(tourMeta);
                    const tourColor = getTourColor(baseTourId);
                    const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                    
                    // Stops-Zeile mit Zahlen (wenn vorhanden)
                    const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                    const stopsText = routeNumber 
                        ? `${customerCount} Stops ${routeNumber}`
                        : `${customerCount} Stops`;
                    
                    return `
                        <button class="list-group-item list-group-item-action ${combinedClass}" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                            <div class="d-flex justify-content-between">
                                <div>
                                    <strong>${cleanTourName}</strong>${barBadge}
                                    <div class="small text-muted">${stopsText}</div>
                                </div>
                                <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                            </div>
                        </button>`;
                }).join('');
                
                bindTourListEvents();
                
                // WICHTIG: Aktualisiere Sub-Routen Button nach Rendering
                updateSubRouteButtonVisibility();
                
                // Debug: Logge allTourCustomers nach Update
                const tourCount = Object.keys(allTourCustomers).filter(k => k.startsWith('workflow-')).length;
                console.log(`[RENDER] allTourCustomers aktualisiert: ${tourCount} Workflow-Touren in allTourCustomers`);
                
                if (tours.length > 0) {
                    // Warte kurz, damit DOM aktualisiert ist, dann erste Tour ausw√§hlen
                    setTimeout(() => {
                        const firstKey = generateTourKey(toursWithMeta[0]);
                        selectTour(firstKey);
                    }, 100);
                }
                return;
            }
            
            // Legacy Match-Format: Items verarbeiten
            if (!items.length) {
                console.log('Keine Items oder Touren gefunden in matchData');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${items.length} Items aus Match`);
            document.getElementById('tourSummary').textContent = `${matchData.ok} OK, ${matchData.warn} Warn, ${matchData.bad} Bad`;

            // Gruppiere Items nach Tour-Zeit basierend auf der urspr√ºnglichen CSV-Struktur
            const groupedTours = {};
            let currentTour = null;
            
            items.forEach((item, index) => {
                // Erkenne Tour-Zeilen basierend auf dem display_name
                const displayName = item.display_name || '';
                
                if (displayName.includes('Tour') || displayName.includes('BAR') || displayName.includes('Anlief')) {
                    // Das ist eine Tour-Zeile
                    currentTour = displayName;
                    if (!groupedTours[currentTour]) {
                        groupedTours[currentTour] = {
                            name: currentTour,
                            customers: [],
                            isBarTour: displayName.includes('BAR'),
                            time: extractTimeFromTourName(displayName)
                        };
                    }
                } else if (currentTour && displayName.trim()) {
                    // Das ist ein Kunde f√ºr die aktuelle Tour
                    groupedTours[currentTour].customers.push({
                        customer_number: item.customer_number || item.id || '',
                        name: displayName,
                        street: item.resolved_address || '',
                        postal_code: '',
                        city: '',
                        bar_flag: groupedTours[currentTour].isBarTour,
                        latitude: item.lat,
                        longitude: item.lon,
                        address: item.resolved_address || '',
                        status: item.status
                    });
                }
            });

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = Object.values(groupedTours).map((tour, index) => {
                const key = `match-${index}`;
                const customerCount = tour.customers.length;
                const okCount = tour.customers.filter(c => c.status === 'ok').length;
                const warnCount = tour.customers.filter(c => c.status === 'warn').length;
                const badCount = tour.customers.filter(c => c.status === 'bad').length;
                const barBadge = tour.isBarTour ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>` : '';
                
                allTourCustomers[key] = tour;

                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const isSubRoute = !!routeLetter;
                
                // Tourname ohne Buchstaben (f√ºr Anzeige)
                const cleanTourName = routeLetter ? (tour.name || '').replace(/\s[A-Z]$/, '').trim() : (tour.name || '');
                
                const baseTourId = tour._base_tour_id || cleanTourName?.split(' ')[0] || '';
                const routeIndex = tour._route_index !== undefined ? tour._route_index : index;
                const tourColor = tour._tour_color || getTourColor(baseTourId, routeIndex);
                
                // Border-Farbe f√ºr Sub-Routen
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // Status-Zeile mit Zahlen (wenn vorhanden)
                const statusText = routeNumber 
                    ? `${okCount} OK, ${warnCount} Warn, ${badCount} Bad ${routeNumber}`
                    : `${okCount} OK, ${warnCount} Warn, ${badCount} Bad`;
                
                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${cleanTourName}</strong>${barBadge}
                                <div class="small text-muted">${statusText}</div>
                            </div>
                            <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = Object.keys(groupedTours).length ? `match-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
            
            // Sub-Routen Button aktualisieren
            updateSubRouteButtonVisibility();
            
            // Synchronisiere mit Panels nach Rendering
            setTimeout(() => {
                syncToursToPanel();
                syncMapToPanel();
            }, 100);
        }

        // ============================================
        // NEUE FUNKTION: renderTourListOnly()
        // Rendert NUR die Tour-Liste, OHNE allTourCustomers zu √§ndern
        // Wird von updateToursWithSubRoutes() aufgerufen statt renderToursFromMatch()
        // ============================================
        /**
         * Rendert NUR die Tour-Liste, OHNE allTourCustomers zu √§ndern
         * Wird von updateToursWithSubRoutes() aufgerufen statt renderToursFromMatch()
         */
        function renderTourListOnly() {
            console.log('[RENDER-LIST] Rendere nur Tour-Liste, OHNE State zu √§ndern');
            
            const tourList = document.getElementById('tourList');
            if (!tourList) {
                console.error('[RENDER-LIST] tourList Element nicht gefunden');
                return;
            }
            
            // Hole Touren aus allTourCustomers (NICHT aus workflowResult!)
            const tourEntries = Object.entries(allTourCustomers);
            
            if (tourEntries.length === 0) {
                tourList.innerHTML = '<div class="text-muted p-3">Keine Touren</div>';
                document.getElementById('tourSummary').textContent = 'Keine Touren';
                return;
            }
            
            // Berechne Statistiken
            let totalStops = 0;
            tourEntries.forEach(([key, tour]) => {
                totalStops += (tour.customers || []).length;
            });
            
            document.getElementById('tourSummary').textContent = 
                `${tourEntries.length} Touren ¬∑ ${totalStops} Stops`;
            
            // Sortiere Touren (W-Touren zuerst, dann nach Zeit)
            tourEntries.sort((a, b) => {
                const [keyA, tourA] = a;
                const [keyB, tourB] = b;
                
                const nameA = tourA.name || '';
                const nameB = tourB.name || '';
                
                // W-Touren zuerst (h√∂chste Priorit√§t)
                const isWA = /^W-\d+\.\d+/.test(nameA);
                const isWB = /^W-\d+\.\d+/.test(nameB);
                if (isWA && !isWB) return -1;
                if (!isWA && isWB) return 1;
                
                // Bei W-Touren: Nach Zeit sortieren
                if (isWA && isWB) {
                    const timeA = extractTimeFromTourName(nameA);
                    const timeB = extractTimeFromTourName(nameB);
                    if (timeA !== timeB) return timeA - timeB;
                }
                
                // Fallback: Alphabetisch
                return nameA.localeCompare(nameB);
            });
            
            // Rendere Tour-Liste
            tourList.innerHTML = tourEntries.map(([key, tour]) => {
                const customerCount = (tour.customers || []).length;
                const isBar = tour.isBarTour || false;
                
                // BAR-Badge
                const barCustomerCount = (tour.customers || []).filter(c => c.bar_flag === true).length;
                const barBadge = isBar && barCustomerCount > 0
                    ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCustomerCount} BAR</span>`
                    : '';
                
                // CSS-Klassen
                const isWTour = /^W-\d+\.\d+/.test(tour.name || '');
                const wTourClass = isWTour ? 'w-tour-highlight' : '';
                const barClass = isBar ? 'bar-tour-highlight' : '';
                const combinedClass = `${wTourClass} ${barClass}`.trim();
                
                // Sub-Route-Detection
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const isSubRoute = !!routeLetter;
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                
                // Farbe f√ºr Sub-Routen
                const tourColor = tour._tour_color || '#2196F3';
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // Stops-Text
                const stopsText = routeNumber 
                    ? `${customerCount} Stops ${routeNumber}`
                    : `${customerCount} Stops`;
                
                // Zeit-Info (falls vorhanden)
                let timeInfo = '';
                if (tour.total_time_minutes) {
                    const totalTime = tour.total_time_minutes;
                    const returnTime = tour.return_time_minutes || 0;
                    const totalWithReturn = totalTime + returnTime;
                    timeInfo = `<div class="small text-muted">${totalWithReturn.toFixed(0)} Min (inkl. R√ºckfahrt)</div>`;
                }
                
                return `
                    <button class="list-group-item list-group-item-action ${combinedClass}" 
                            id="tour-${key}" 
                            data-tour-key="${key}" 
                            style="${borderColor}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${tour.name || 'Unbekannt'}</strong>${barBadge}
                                <div class="small text-muted">${stopsText}</div>
                                ${timeInfo}
                            </div>
                            <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">
                                ${customerCount}
                            </span>
                        </div>
                    </button>
                `;
            }).join('');
            
            // Binde Events neu
            bindTourListEvents();
            
            console.log(`[RENDER-LIST] ${tourEntries.length} Touren gerendert`);
            
            // Clear-Button aktualisieren
            updateClearButtonVisibility();
            
            // Sub-Routen Button aktualisieren
            updateSubRouteButtonVisibility();
        }

        function renderToursFromWorkflow() {
            console.log('renderToursFromWorkflow aufgerufen, workflowResult:', workflowResult);
            
            // Neue Datenstruktur: workflow_results.final_results.routes.routes
            const routes = workflowResult?.final_results?.routes;
            const tourRoutes = routes?.routes || [];
            
            if (!tourRoutes.length) {
                console.log('Keine Touren gefunden in workflowResult');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${tourRoutes.length} Touren aus Workflow`);
            const totalAddresses = tourRoutes.reduce((sum, t) => sum + (t.customers?.length || 0), 0);
            document.getElementById('tourSummary').textContent = `${routes.total_routes} Touren ¬∑ ${totalAddresses} Adressen`;

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = tourRoutes.map((tour, index) => {
                const key = `workflow-${index}`;
                const customerCount = tour.customers?.length || 0;
                const barCount = tour.is_bar_tour ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>` : '';
                
                // Kunden mit Koordinaten f√ºr die Karte vorbereiten
                const customers = (tour.customers || []).map(c => ({
                    customer_number: c.customer_number || c.kdnr || '',
                    name: c.name || c.customer_name || 'Unbekannt',
                    street: c.street || c.address || '',
                    postal_code: c.postal_code || c.zip || '',
                    city: c.city || '',
                    bar_flag: !!(c.bar_flag || c.bar),
                    latitude: c.coordinates?.lat || c.latitude,
                    longitude: c.coordinates?.lon || c.longitude,
                    address: c.resolved_address || c.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [c.street || c.address || '', c.postal_code || c.zip || '', c.city || ''].map(clean).filter(Boolean);
                    return parts.join(', ') || '';
                })()
                }));

                // Kunden f√ºr diese Tour speichern
                allTourCustomers[key] = {
                    name: tour.name || `Tour ${index + 1}`,
                    type: tour.tour_type || 'Workflow',
                    time: tour.time || '',
                    customers,
                    _route_index: tour._route_index !== undefined ? tour._route_index : index  // Route-Index f√ºr Farbzuweisung
                };

                // BAR-Status: Pr√ºfe Tour-Level und individuelle Kunden
                const hasBarCustomers = customers.some(c => c.bar_flag === true);
                const tourIsBar = tour.is_bar_tour || hasBarCustomers;
                const barCustomerCount = customers.filter(c => c.bar_flag === true).length;
                const barBadge = tourIsBar 
                    ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCustomerCount > 0 ? barCustomerCount + ' ' : ''}BAR</span>` 
                    : '';

                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const isSubRoute = !!routeLetter;
                
                // Tourname: Verwende vollst√§ndigen Namen (inkl. Sub-Route-Buchstabe) f√ºr Konsistenz
                // Der vollst√§ndige Name wird sowohl in Sidebar als auch im Detail-Bereich verwendet
                const displayTourName = tour.name || `Tour ${index + 1}`;
                
                // F√ºr CSS-Klassen: Basis-Name ohne Buchstaben
                const baseTourName = routeLetter ? (tour.name || '').replace(/\s([A-Z])$/, '').trim() : (tour.name || `Tour ${index + 1}`);
                
                const baseTourId = tour._base_tour_id || baseTourName?.split(' ')[0] || '';
                const routeIndex = tour._route_index !== undefined ? tour._route_index : index;
                const tourColor = tour._tour_color || getTourColor(baseTourId, routeIndex);
                
                // BAR-Badge auch f√ºr Sub-Routen anzeigen
                const subRouteBarCount = isSubRoute && tourIsBar ? barCustomerCount : 0;
                const subRouteBarBadge = isSubRoute && subRouteBarCount > 0 
                    ? `<span class="badge ms-1" style="background-color: #ff9800; color: #000; font-size: 0.75em;">${subRouteBarCount} BAR</span>` 
                    : '';
                
                // Border-Farbe f√ºr Sub-Routen
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // CSS-Klassen auch f√ºr Workflow-Touren (basierend auf Basis-Name)
                const isWTour = /^W-\d+\.\d+/.test(baseTourName || '');
                const wTourClass = isWTour ? 'w-tour-highlight' : '';
                const barClass = tourIsBar ? 'bar-tour-highlight' : '';
                const combinedClass = `${wTourClass} ${barClass}`.trim();
                
                // Stops-Zeile mit Zahlen (wenn vorhanden)
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const stopsText = routeNumber 
                    ? `${customerCount} Stops ${routeNumber} ¬∑ ${tour.tour_type || 'Workflow'}`
                    : `${customerCount} Stops ¬∑ ${tour.tour_type || 'Workflow'}`;

                return `
                    <button class="list-group-item list-group-item-action ${combinedClass}" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${displayTourName}</strong>${barBadge}${subRouteBarBadge}
                                <div class="small text-muted">${stopsText}</div>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                                <button class="btn btn-sm btn-link p-0 text-secondary optimize-tour-btn" 
                                        data-tour-key="${key}" 
                                        data-tour-name="${tour.name || `Tour ${index + 1}`}"
                                        data-stop-count="${customerCount}"
                                        title="Tour mit AI optimieren"
                                        onclick="event.stopPropagation(); optimizeTour('${key}', '${tour.name || `Tour ${index + 1}`}');">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = tourRoutes.length ? `workflow-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
            
            // Sub-Routen Button aktualisieren
            updateSubRouteButtonVisibility();
            
            // Synchronisiere mit Panels nach Rendering
            setTimeout(() => {
                syncToursToPanel();
                syncMapToPanel();
            }, 100);
        }

        function renderCustomerList(customers) {
            if (!customers || !customers.length) {
                return '<span class="text-muted">Keine Kunden vorhanden.</span>';
            }

            const SERVICE_TIME_MINUTES = 2.0; // Entladezeit pro Kunde
            const SPEED_KMH = 50.0; // Durchschnittsgeschwindigkeit
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;
            
            let totalDistanceKm = 0;
            let totalTimeMinutes = 0;
            let cumulativeTimeMinutes = 0;
            const rows = [];
            
            // WICHTIG: Depot als ersten Eintrag hinzuf√ºgen
            const depotRow = `
                <tr style="background-color: #e1bee7; font-weight: bold;">
                    <td>0</td>
                    <td>FAMO Depot <span class="badge ms-1" style="background-color: #9c27b0; color: #fff;">DEPOT</span></td>
                    <td>Gittersee, Dresden</td>
                    <td>‚Äî</td>
                    <td>
                        <div class="small">
                            <div class="text-muted">Start</div>
                            <div class="text-primary fw-bold">0.0 Min</div>
                        </div>
                    </td>
                </tr>
            `;
            rows.push(depotRow);
            
            // Hilfsfunktion: Haversine-Distanz
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371.0; // Erdradius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            // Berechne Daten f√ºr jeden Kunden
            for (let idx = 0; idx < customers.length; idx++) {
                const c = customers[idx];
                const key = `${c.customer_number || idx}-${idx}`;
                c._geoKey = key;
                const hasCoords = c.has_coordinates !== undefined ? c.has_coordinates : hasCoordinates(c);
                
                // Gelbe Ausrufezeichen nur wenn KEINE Koordinaten vorhanden
                const showGeoIcon = !hasCoords;
                
                // Berechne Distanz und Zeit
                let distanceKm = 0;
                let driveTimeMinutes = 0;
                let timeText = '‚Äî';
                let fromText = '';
                
                if (hasCoords) {
                    const currLat = parseFloat(c.latitude);
                    const currLon = parseFloat(c.longitude);
                    
                    if (!isNaN(currLat) && !isNaN(currLon)) {
                        if (idx === 0) {
                            // Erster Kunde: Vom Depot
                            distanceKm = haversineDistance(depotLat, depotLon, currLat, currLon) * 1.3;
                            fromText = '<small class="text-muted">Depot</small>';
                        } else {
                            // Weitere Kunden: Vom vorherigen Kunden
                            const prevLat = parseFloat(customers[idx-1].latitude);
                            const prevLon = parseFloat(customers[idx-1].longitude);
                            
                            if (!isNaN(prevLat) && !isNaN(prevLon)) {
                                distanceKm = haversineDistance(prevLat, prevLon, currLat, currLon) * 1.3;
                                fromText = `<small class="text-muted">${idx}</small>`; // Nummer des vorherigen Kunden
                            }
                        }
                        
                        // Fahrtzeit berechnen (Distanz / Geschwindigkeit * 60)
                        driveTimeMinutes = (distanceKm / SPEED_KMH) * 60;
                        
                        // Kumulative Zeit: Fahrtzeit + Entladezeit (2 Min)
                        cumulativeTimeMinutes += driveTimeMinutes + SERVICE_TIME_MINUTES;
                        
                        totalDistanceKm += distanceKm;
                        totalTimeMinutes = cumulativeTimeMinutes;
                        
                        // Zeit-Text: Fahrtzeit + Entladezeit = Gesamt, kumulativ
                        timeText = `
                            <div class="small">
                                <div>${driveTimeMinutes.toFixed(1)} Min <span class="text-muted">(Fahrt)</span></div>
                                <div class="text-muted">+ ${SERVICE_TIME_MINUTES} Min (Entladung)</div>
                                <div class="text-primary fw-bold">= ${cumulativeTimeMinutes.toFixed(1)} Min <span class="text-muted">(kumulativ)</span></div>
                            </div>
                        `;
                    }
                }
                
                const rowClass = hasCoords ? '' : ' class="table-warning"';  // Gelb f√ºr Warnungen
                const warningBadge = c.warning ? `<br><small class="text-danger"><i class="fas fa-exclamation-triangle"></i> ${c.warning}</small>` : '';
                // BAR-Badge: Pr√ºfe explizit auf true (nicht nur truthy)
                const barBadge = (c.bar_flag === true || c.bar_flag === 'true' || c.bar_flag === 1) 
                    ? ' <span class="badge ms-1" style="background-color: #ff9800; color: #000; font-weight: bold;">BAR</span>' 
                    : '';
                
                // BAR-Zeile zus√§tzlich hervorheben
                const barRowClass = barBadge ? ' style="background-color: #fff3e0;"' : '';
                
                // Markiere ersten Kunden als aktiv (wird sp√§ter per CSS hervorgehoben)
                const isFirstRow = idx === 0;
                const activeClass = isFirstRow ? ' active-row' : '';
                
                rows.push(`
                    <tr${rowClass}${barRowClass} class="${activeClass}" data-customer-index="${idx}" data-customer-key="${key}">
                        <td><span class="badge rounded-pill" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff;">${idx + 1}</span></td>
                        <td><strong>${c.name}</strong>${barBadge}${warningBadge}</td>
                        <td>${c.resolved_address || c.address || (() => {
                            const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                            const parts = [c.street, c.postal_code, c.city].map(clean).filter(Boolean);
                            return parts.join(', ') || '‚Äî';
                        })()}</td>
                        <td><span class="badge bg-secondary">${c.customer_number || '‚Äî'}</span></td>
                        <td class="text-center">
                            ${fromText ? `<div>${fromText}</div>` : ''}
                            ${distanceKm > 0 ? `<div class="small text-primary fw-bold">${distanceKm.toFixed(1)} km</div>` : '<span class="text-muted">‚Äî</span>'}
                        </td>
                        <td class="text-center small">${timeText}</td>
                        <td class="text-center">
                            ${showGeoIcon ? `<span class="geo-status" data-geokey="${key}" title="${c.warning || (hasCoords ? 'Koordinaten vorhanden' : 'Keine Koordinaten')}">${getGeoStatusIcon(hasCoords)}</span>` : '<span class="text-success" title="Auf Karte sichtbar"><i class="fas fa-check-circle"></i></span>'}
                        </td>
                    </tr>
                `);
            }
            
            // WICHTIG: Berechne R√ºckfahrt zum Depot (vom letzten Kunden)
            let returnDistanceKm = 0;
            let returnTimeMinutes = 0;
            if (customers.length > 0) {
                const lastCustomer = customers[customers.length - 1];
                const lastLat = parseFloat(lastCustomer.latitude);
                const lastLon = parseFloat(lastCustomer.longitude);
                
                if (!isNaN(lastLat) && !isNaN(lastLon)) {
                    returnDistanceKm = haversineDistance(lastLat, lastLon, depotLat, depotLon) * 1.3;
                    returnTimeMinutes = (returnDistanceKm / SPEED_KMH) * 60;
                    totalDistanceKm += returnDistanceKm;
                    cumulativeTimeMinutes += returnTimeMinutes;
                    totalTimeMinutes = cumulativeTimeMinutes;
                    
                    // WICHTIG: Depot als letzten Eintrag hinzuf√ºgen (R√ºckfahrt)
                    const depotReturnRow = `
                        <tr style="background-color: #e1bee7; font-weight: bold;">
                            <td>${customers.length + 1}</td>
                            <td>FAMO Depot <span class="badge ms-1" style="background-color: #9c27b0; color: #fff;">DEPOT</span></td>
                            <td>Gittersee, Dresden</td>
                            <td>DEPOT</td>
                            <td>
                                <div class="small">
                                    <div>${returnDistanceKm.toFixed(2)} km</div>
                                    <div class="text-muted">von ${customers[customers.length - 1].name}</div>
                                </div>
                            </td>
                            <td>
                                <div class="small">
                                    <div>${returnTimeMinutes.toFixed(1)} Min <span class="text-muted">(R√ºckfahrt)</span></div>
                                    <div class="text-primary fw-bold">= ${totalTimeMinutes.toFixed(1)} Min <span class="text-muted">(gesamt)</span></div>
                                </div>
                            </td>
                            <td class="text-center">
                                <span class="text-success" title="Depot"><i class="fas fa-warehouse"></i></span>
                            </td>
                        </tr>
                    `;
                    rows.push(depotReturnRow);
                }
            }
            
            return `
                <div class="table-responsive" style="max-height: 60vh; overflow-y: auto;">
                    <table class="table table-sm align-middle table-hover">
                        <thead class="table-light" style="position: sticky; top: 0; z-index: 10; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);">
                            <tr>
                                <th style="width: 50px;">#</th>
                                <th>Kunde</th>
                                <th>Adresse</th>
                                <th style="width: 100px;">KdNr</th>
                                <th class="text-center" style="width: 120px;">Distanz</th>
                                <th class="text-center" style="width: 150px;">Zeit</th>
                                <th class="text-center" style="width: 60px;">Geo</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows.join('')}
                        </tbody>
                        <tfoot class="table-info" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); position: sticky; bottom: 0;">
                            <tr>
                                <td colspan="4" class="text-end fw-bold">GESAMT (inkl. R√ºckfahrt):</td>
                                <td class="text-center fw-bold"><span class="badge bg-primary">${totalDistanceKm.toFixed(2)} km</span></td>
                                <td class="text-center fw-bold">
                                    <div class="small">
                                        <div>Fahrzeit: ${(totalTimeMinutes - ((customers.length + 1) * SERVICE_TIME_MINUTES)).toFixed(1)} Min</div>
                                        <div>Service: ${((customers.length + 1) * SERVICE_TIME_MINUTES).toFixed(1)} Min</div>
                                        <div>R√ºckfahrt: ${returnTimeMinutes.toFixed(1)} Min</div>
                                        <div class="text-primary fw-bold">Gesamt: ${totalTimeMinutes.toFixed(1)} Min</div>
                                    </div>
                                </td>
                                <td class="text-center">
                                    <span class="badge bg-primary">${customers.length + 1} Stopps</span>
                                    <small class="text-muted d-block">(${customers.length} Kunden + Depot)</small>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                </div>`;
        }

        function hasCoordinates(customer) {
            // Pr√ºfe zuerst has_coordinates Flag (vom Backend), dann lat/lon
            if (customer?.has_coordinates !== undefined) {
                return customer.has_coordinates;
            }
            const lat = parseFloat(customer?.latitude);
            const lon = parseFloat(customer?.longitude);
            return !isNaN(lat) && !isNaN(lon);
        }

        function getGeoStatusIcon(customerOrFlag) {
            const hasCoords = typeof customerOrFlag === 'boolean' ? customerOrFlag : hasCoordinates(customerOrFlag);
            if (hasCoords) {
                return '<i class="fas fa-check-circle text-success"></i>';
            }
            return '<i class="fas fa-exclamation-triangle text-warning"></i>';  // Warnung-Icon statt Fehler
        }

        function updateGeoIndicator(customer, hasCoords) {
            if (!customer || !customer._geoKey) {
                return;
            }
            const el = document.querySelector(`.geo-status[data-geokey="${customer._geoKey}"]`);
            if (el) {
                el.innerHTML = getGeoStatusIcon(hasCoords);
            }
        }

        function bindTourListEvents() {
            const buttons = document.querySelectorAll('#tourList .list-group-item');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const key = btn.getAttribute('data-tour-key');
                    selectTour(key);
                });
            });
        }

        function selectTour(key) {
            return safeExecute(() => {
                console.log('[SELECT-TOUR] Key:', key);
                console.log('[SELECT-TOUR] allTourCustomers keys:', Object.keys(allTourCustomers));
                
                if (!key) {
                    console.warn('[SELECT-TOUR] Kein Key angegeben');
                    return;
                }
                
                // Versuche 1: Exakter Match
                if (allTourCustomers[key]) {
                    activeTourKey = key;
                    window.currentTourKey = key;
                    updateTourListSelection(key);
                    renderTourDetails(allTourCustomers[key]);
                    syncTourSelectionToPanels(key);
                    return;
                }
                
                // Versuche 2: √Ñhnlicher Key (normalisiert f√ºr Vergleich - BEHALTE Punkt!)
                // WICHTIG: Behalte Punkt (.) f√ºr Zeit-Format, normalisiere nur problematische Zeichen
                let normalizedKey = key.replace(/[^a-zA-Z0-9.\-]/g, '_');
                normalizedKey = normalizedKey.replace(/_+/g, '_').replace(/^_+|_+$/g, '');
                
                // Pr√ºfe ob Key eine Haupttour ist (ohne Sub-Route-Suffix)
                const isMainTourKey = !key.match(/-[A-Z]$/);
                
                const similarKey = Object.keys(allTourCustomers).find(k => {
                    let normalizedK = k.replace(/[^a-zA-Z0-9.\-]/g, '_');
                    normalizedK = normalizedK.replace(/_+/g, '_').replace(/^_+|_+$/g, '');
                    
                    // Exakte √úbereinstimmung nach Normalisierung
                    if (normalizedK === normalizedKey) return true;
                    
                    // Teilstring-Match (f√ºr Sub-Routen: "W-07.00" sollte "W-07.00-A" finden)
                    if (normalizedK.includes(normalizedKey) || normalizedKey.includes(normalizedK)) return true;
                    
                    // Fallback: Ignoriere Punkt f√ºr Vergleich (wenn alles andere gleich)
                    const keyWithoutDot = normalizedKey.replace(/\./g, '');
                    const kWithoutDot = normalizedK.replace(/\./g, '');
                    return kWithoutDot === keyWithoutDot || 
                           kWithoutDot.includes(keyWithoutDot) || 
                           keyWithoutDot.includes(kWithoutDot);
                });
                
                if (similarKey) {
                    // Wenn Haupttour auf Sub-Route gemappt wurde, ist das normal (keine Warnung)
                    if (isMainTourKey && similarKey.match(/-[A-Z]$/)) {
                        console.log(`[SELECT-TOUR] Tour aufgeteilt: "${key}" ‚Üí erste Sub-Route "${similarKey}" (normal)`);
                    } else {
                        console.warn(`[SELECT-TOUR] ‚ö†Ô∏è Key-Mismatch erkannt: "${key}" ‚Üí "${similarKey}"`);
                    }
                    activeTourKey = similarKey;
                    window.currentTourKey = similarKey;
                    updateTourListSelection(similarKey);
                    renderTourDetails(allTourCustomers[similarKey]);
                    syncTourSelectionToPanels(similarKey);
                    return;
                }
                
                // Versuche 3: Erste Tour mit √§hnlichem Base-ID
                try {
                    const baseId = extractBaseTourId({ tour_id: key.replace('workflow-', '').replace(/-[A-Z]$/, '') });
                    if (baseId) {
                        const matchingKey = Object.keys(allTourCustomers).find(k => {
                            const tour = allTourCustomers[k];
                            const tourBaseId = extractBaseTourId(tour);
                            // Exakte √úbereinstimmung
                            if (tourBaseId === baseId) return true;
                            // Normalisiere f√ºr Vergleich (ignoriere Punkt-Unterschiede)
                            const normalizedBaseId = baseId.replace(/\./g, '');
                            const normalizedTourBaseId = tourBaseId.replace(/\./g, '');
                            return normalizedTourBaseId === normalizedBaseId;
                        });
                        
                        if (matchingKey) {
                            // Wenn Haupttour auf Sub-Route gemappt wurde, ist das normal (keine Warnung)
                            if (isMainTourKey && matchingKey.match(/-[A-Z]$/)) {
                                console.log(`[SELECT-TOUR] Tour aufgeteilt: "${key}" ‚Üí erste Sub-Route "${matchingKey}" (normal)`);
                            } else {
                                console.warn(`[SELECT-TOUR] ‚ö†Ô∏è Fallback: Erste Tour mit Base-ID "${baseId}": "${matchingKey}"`);
                            }
                            activeTourKey = matchingKey;
                            window.currentTourKey = matchingKey;
                            updateTourListSelection(matchingKey);
                            renderTourDetails(allTourCustomers[matchingKey]);
                            syncTourSelectionToPanels(matchingKey);
                            return;
                        }
                    }
                } catch (e) {
                    console.warn('[SELECT-TOUR] Fehler bei Base-ID-Extraktion:', e);
                }
                
                // Versuche 4: Erste verf√ºgbare Tour
                const firstKey = Object.keys(allTourCustomers)[0];
                if (firstKey) {
                    console.warn(`[SELECT-TOUR] ‚ö†Ô∏è Fallback: Erste verf√ºgbare Tour: "${firstKey}"`);
                    activeTourKey = firstKey;
                    window.currentTourKey = firstKey;
                    updateTourListSelection(firstKey);
                    renderTourDetails(allTourCustomers[firstKey]);
                    syncTourSelectionToPanels(firstKey);
                    return;
                }
                
                // Keine Tour gefunden - aber kein Absturz!
                console.error('[SELECT-TOUR] ‚ùå Tour nicht gefunden:', key);
                console.log('[SELECT-TOUR] Verf√ºgbare Keys:', Object.keys(allTourCustomers));
                // Kein Return - Funktion endet einfach (nichts passiert, wie gew√ºnscht)
            }, () => {
                console.warn('[SELECT-TOUR] Fehler in selectTour() - wird √ºbersprungen');
            }, 'selectTour');
        }
        
        // Hilfsfunktion f√ºr Panel-Synchronisation
        function syncTourSelectionToPanels(key) {
            if (window.panelIPC) {
                window.panelIPC.postMessage('tour-select', { tourKey: key });
                syncToursToPanel();
                syncMapToPanel();
            }
        }

        function updateTourListSelection(key) {
            const buttons = document.querySelectorAll('#tourList .list-group-item');
            buttons.forEach(btn => {
                if (btn.getAttribute('data-tour-key') === key) {
                    btn.classList.add('active');
                    // Scroll zu aktiver Tour (sanft)
                    btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Entferne aktive Markierung von allen Kunden-Zeilen
            document.querySelectorAll('.table tbody tr').forEach(row => {
                row.classList.remove('active-row');
            });
            
            // Markiere ersten Kunden als aktiv (nach kurzer Verz√∂gerung f√ºr DOM-Update)
            setTimeout(() => {
                const firstRow = document.querySelector('.table tbody tr[data-customer-index="0"]');
                if (firstRow) {
                    firstRow.classList.add('active-row');
                    firstRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 150);
        }

        function renderTourDetails(tourData) {
            console.log('[RENDER-DETAILS] Tour data:', tourData);
            
            if (!tourData) {
                document.getElementById('tourDetails').innerHTML = '<span class="text-muted">Keine Tour ausgew√§hlt.</span>';
                clearTourMarkers();
                return;
            }

            // WICHTIG: Fallback f√ºr fehlende customers (konvertiere stops zu customers)
            let customers = tourData.customers;
            if (!customers || customers.length === 0) {
                console.warn('[RENDER-DETAILS] Keine customers, versuche stops zu verwenden');
                if (tourData.stops && tourData.stops.length > 0) {
                    customers = tourData.stops.map(s => ({
                        customer_number: s.customer_number || s.order_id || '',
                        name: s.name || s.customer || 'Unbekannt',
                        street: s.street || '',
                        postal_code: s.postal_code || '',
                        city: s.city || '',
                        address: s.address || `${s.street || ''}, ${s.postal_code || ''} ${s.city || ''}`.trim(),
                        latitude: s.lat || s.latitude,
                        longitude: s.lon || s.longitude,
                        lat: s.lat || s.latitude,
                        lon: s.lon || s.longitude,
                        bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tourData.is_bar_tour || false),
                        has_coordinates: !!(s.lat || s.latitude) && !!(s.lon || s.longitude)
                    }));
                    console.log('[RENDER-DETAILS] Konvertierte stops zu customers:', customers.length);
                } else {
                    console.error('[RENDER-DETAILS] Keine customers und keine stops');
                    customers = [];
                }
            }

            const details = document.getElementById('tourDetails');
            if (!details) {
                console.error('[RENDER-DETAILS] tourDetails Element nicht gefunden');
                return;
            }
            
            details.innerHTML = `
                <h5>${tourData.name || 'Unbekannte Tour'}</h5>
                <div class="mb-2 text-muted">${tourData.type || ''} ${tourData.time ? '¬∑ ' + tourData.time : ''}</div>
                ${renderCustomerList(customers)}
            `;

            highlightTourOnMap(customers);
        }

        function renderWorkflowDetails(info) {
            if (!info || !info.ai_result) {
                return '<span class="text-muted">Keine Detaildaten verf√ºgbar.</span>';
            }

            const tours = info.subtours || [];
            if (!tours.length) {
                return '<span class="text-muted">Keine Untertouren erstellt.</span>';
            }

            return tours.map((tour, idx) => `
                <div class="mb-3">
                    <h6>Untertour ${idx + 1}</h6>
                    <pre class="bg-light p-2">${JSON.stringify(tour, null, 2)}</pre>
                </div>`).join('');
        }

        function renderEmptyTours() {
            document.getElementById('tourSummary').textContent = 'Keine Tourdaten';
            document.getElementById('tourList').innerHTML = '';
            document.getElementById('tourDetails').innerHTML = `
                <div class="text-center text-muted py-4">
                    <i class="fas fa-info-circle"></i><br>
                    Noch keine Tourdaten. CSV hochladen oder Workflow starten.
                </div>`;
            clearTourMarkers();
        }

        function passFilter(tour) {
            // Alle Touren werden angezeigt (Filter entfernt)
            return true;
        }

        function passWorkflowFilter(header, info) {
            // Alle Touren werden angezeigt (Filter entfernt)
            return true;
        }

        // Globale Variablen f√ºr Blitzer-Marker
        let speedCameraMarkers = [];
        let showSpeedCameras = true;  // Toggle f√ºr Blitzer-Anzeige (standardm√§√üig an)
        
        // Globale Variablen f√ºr Hindernisse-Marker
        let trafficIncidentMarkers = [];
        let showTrafficIncidents = false;  // Toggle f√ºr Hindernisse-Anzeige (standardm√§√üig aus)

        function clearTourMarkers() {
            if (!map) {
                return;
            }
            // L√∂sche Marker
            if (tourMarkers && Array.isArray(tourMarkers) && tourMarkers.length) {
                tourMarkers.forEach(marker => {
                    try {
                        if (marker && map.hasLayer(marker)) {
                            map.removeLayer(marker);
                        }
                    } catch (e) {
                        console.warn('Fehler beim Entfernen von Marker:', e);
                    }
                });
                tourMarkers = [];
            }
            // L√∂sche Route-Linien
            if (tourRouteLines && Array.isArray(tourRouteLines) && tourRouteLines.length) {
                tourRouteLines.forEach(line => {
                    try {
                        if (line && map.hasLayer(line)) {
                            map.removeLayer(line);
                        }
                    } catch (e) {
                        console.warn('Fehler beim Entfernen von Route-Linie:', e);
                    }
                });
                tourRouteLines = [];
            }
            // L√∂sche Blitzer-Marker
            clearSpeedCameraMarkers();
            // L√∂sche Hindernisse-Marker
            clearTrafficIncidentMarkers();
        }

        function clearSpeedCameraMarkers() {
            if (!map) {
                return;
            }
            if (speedCameraMarkers && Array.isArray(speedCameraMarkers) && speedCameraMarkers.length) {
                speedCameraMarkers.forEach(marker => {
                    try {
                        if (marker && map.hasLayer(marker)) {
                            map.removeLayer(marker);
                        }
                    } catch (e) {
                        console.warn('Fehler beim Entfernen von Blitzer-Marker:', e);
                    }
                });
                speedCameraMarkers = [];
            }
        }

        function toggleSpeedCameras() {
            showSpeedCameras = !showSpeedCameras;
            if (showSpeedCameras) {
                // Zeige alle Blitzer-Marker wieder an
                speedCameraMarkers.forEach(marker => {
                    if (marker && !map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                });
                updateSpeedCameraToggleButton();
            } else {
                // Verstecke alle Blitzer-Marker
                speedCameraMarkers.forEach(marker => {
                    if (marker && map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                });
                updateSpeedCameraToggleButton();
            }
        }

        function updateSpeedCameraToggleButton() {
            const btn = document.getElementById('toggleSpeedCamerasBtn');
            if (btn) {
                if (showSpeedCameras) {
                    btn.innerHTML = '<i class="fas fa-eye-slash"></i> Blitzer ausblenden';
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-warning');
                } else {
                    btn.innerHTML = '<i class="fas fa-eye"></i> Blitzer einblenden';
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-secondary');
                }
            }
        }

        function addSpeedCameraMarker(camera) {
            if (!map || !showSpeedCameras) {
                return null;
            }

            // Bestimme Icon basierend auf Typ
            let iconHtml = '';
            let iconColor = '#ff9800';  // Orange als Standard
            
            switch (camera.type) {
                case 'fixed':
                    iconHtml = '<i class="fas fa-camera" style="font-size: 20px; color: #ff5722;"></i>';
                    iconColor = '#ff5722';  // Rot-Orange f√ºr feste Blitzer
                    break;
                case 'mobile':
                    iconHtml = '<i class="fas fa-van" style="font-size: 18px; color: #ff9800;"></i>';
                    iconColor = '#ff9800';  // Orange f√ºr mobile Blitzer
                    break;
                case 'section_control':
                    iconHtml = '<i class="fas fa-road" style="font-size: 20px; color: #f44336;"></i>';
                    iconColor = '#f44336';  // Rot f√ºr Streckenkontrolle
                    break;
                default:
                    iconHtml = '<i class="fas fa-camera" style="font-size: 20px; color: #ff9800;"></i>';
            }

            const cameraIcon = L.divIcon({
                className: 'speed-camera-marker',
                html: `
                    <div style="
                        position: relative;
                        width: 30px;
                        height: 30px;
                        background-color: rgba(255, 255, 255, 0.9);
                        border: 2px solid ${iconColor};
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    ">
                        ${iconHtml}
                    </div>
                `,
                iconSize: [30, 30],
                iconAnchor: [15, 15],
                popupAnchor: [0, -15]
            });

            const marker = L.marker([camera.lat, camera.lon], {
                icon: cameraIcon,
                zIndexOffset: 500  // √úber Kunden-Markern, unter Depot
            });

            // Popup mit Blitzer-Details
            let popupContent = `<strong><i class="fas fa-camera"></i> Blitzer</strong><br>`;
            
            if (camera.type === 'fixed') {
                popupContent += `<span class="badge badge-danger">Fester Blitzer</span><br>`;
            } else if (camera.type === 'mobile') {
                popupContent += `<span class="badge badge-warning">Mobiler Blitzer</span><br>`;
            } else if (camera.type === 'section_control') {
                popupContent += `<span class="badge badge-danger">Streckenkontrolle</span><br>`;
            }

            if (camera.speed_limit) {
                popupContent += `<strong>Tempolimit:</strong> ${camera.speed_limit} km/h<br>`;
            }

            if (camera.direction) {
                const directionNames = {
                    'north': 'Norden',
                    'south': 'S√ºden',
                    'east': 'Osten',
                    'west': 'Westen',
                    'both': 'Beide Richtungen'
                };
                popupContent += `<strong>Richtung:</strong> ${directionNames[camera.direction] || camera.direction}<br>`;
            }

            if (camera.description) {
                popupContent += `<br>${camera.description}`;
            }

            if (camera.verified) {
                popupContent += `<br><small class="text-success"><i class="fas fa-check-circle"></i> Verifiziert</small>`;
            } else {
                popupContent += `<br><small class="text-muted"><i class="fas fa-exclamation-triangle"></i> Nicht verifiziert</small>`;
            }

            marker.bindPopup(popupContent);
            marker.addTo(map);
            speedCameraMarkers.push(marker);

            return marker;
        }

        async function highlightTourOnMap(customers) {
            if (!map) {
                return;
            }

            clearTourMarkers();

            if (!customers || !customers.length) {
                return;
            }

            // Bestimme Tour-Farbe basierend auf aktueller Tour
            const currentKey = window.currentTourKey || '';
            const baseTourId = currentKey.split(' ')[0] || '';
            // Versuche route_index aus aktueller Tour zu holen
            const currentTour = allTourCustomers[currentKey];
            const routeIndex = currentTour?._route_index;
            const tourColor = getTourColor(baseTourId, routeIndex);
            
            // W√§hle Marker-Farbe basierend auf Tour
            const markerColors = {
                '#2196F3': 'blue',
                '#4CAF50': 'green',
                '#FF9800': 'orange',
                '#9C27B0': 'violet',
                '#F44336': 'red',
                '#00BCD4': 'cyan',
                '#795548': 'brown',
                '#607D8B': 'blue-grey',
                '#E91E63': 'pink',
                '#3F51B5': 'indigo'
            };
            const markerColor = markerColors[tourColor] || 'red';

            const bounds = [];
            const customersWithCoords = [];

            // Nummeriere Kunden basierend auf ihrer Reihenfolge in der Tour
            let customerIndex = 1;
            
            for (const customer of customers) {
                // Koordinaten sind jetzt direkt im Customer-Objekt vom Server
                const hasCoords = hasCoordinates(customer);
                updateGeoIndicator(customer, hasCoords);
                
                if (!hasCoords) {
                    console.warn(`Keine Koordinaten f√ºr ${customer.name}`);
                    continue;
                }

                const lat = parseFloat(customer.latitude);
                const lon = parseFloat(customer.longitude);
                
                customersWithCoords.push(customer);  // F√ºr Route-Zeichnung
                
                // Marker mit Nummer erstellen
                const markerNumber = customerIndex++;
                const marker = L.marker([lat, lon], {
                    icon: L.divIcon({
                        className: 'numbered-marker',
                        html: `
                            <div style="
                                position: relative;
                                width: 35px;
                                height: 35px;
                                background-color: ${tourColor || '#2196F3'};
                                border: 3px solid white;
                                border-radius: 50%;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                font-weight: bold;
                                font-size: 14px;
                                color: white;
                                text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                            ">
                                ${markerNumber}
                            </div>
                        `,
                        iconSize: [35, 35],
                        iconAnchor: [17, 17],
                        popupAnchor: [0, -17]
                    })
                }).addTo(map);
                
                // Popup mit Kunden-Nummer und Reihenfolge
                const customerNumber = customer.customer_number ? `<br><strong>KdNr:</strong> ${customer.customer_number}` : '';
                const address = customer.resolved_address || customer.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [customer.street, customer.postal_code, customer.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '‚Äî';
                })();
                
                marker.bindPopup(`<strong>#${markerNumber - 1}: ${customer.name}</strong>${customerNumber}<br>${address}`);
                tourMarkers.push(marker);
                bounds.push([lat, lon]);
            }

            // WICHTIG: Depot hinzuf√ºgen (Start- und Endpunkt)
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;
            
            // Depot-Marker (lila, gr√∂√üer, mit Warehouse-Icon)
            const depotIcon = L.divIcon({
                className: 'depot-marker',
                html: '<i class="fas fa-warehouse" style="font-size: 24px; color: #9c27b0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);"></i>',
                iconSize: [30, 30],
                iconAnchor: [15, 30]
            });
            
            const depotMarker = L.marker([depotLat, depotLon], {
                icon: depotIcon,
                zIndexOffset: 1000  // Immer oben
            }).addTo(map);
            
            depotMarker.bindPopup('<strong>FAMO Depot</strong><br>Gittersee, Dresden<br><span class="badge" style="background-color: #9c27b0; color: #fff;">HAUPTLAGER</span>');
            tourMarkers.push(depotMarker);
            bounds.push([depotLat, depotLon]);
            
            // Zeichne Routen-Linien zwischen Depot und Kunden (OSRM)
            await drawRouteLines(customersWithCoords, tourColor, true);  // include_depot = true

            if (bounds.length) {
                const featureGroup = L.featureGroup([...tourMarkers, ...tourRouteLines]);
                map.fitBounds(featureGroup.getBounds().pad(0.2));
            }
        }

        // Dekodiere OSRM Polyline (encoded polyline string)
        // Polyline6-Decoder (f√ºr OSRM geometries=polyline6)
        async function decodePolyline6(encoded) {
            try {
                // Dynamischer Import des Polyline6-Moduls
                const { decodePolyline6: decodeP6 } = await import('/static/js/polyline6.js');
                return decodeP6(encoded);
            } catch (error) {
                console.warn('[POLYLINE6] Modul-Import fehlgeschlagen, verwende Inline-Decoder:', error);
                // Inline-Fallback f√ºr Polyline6
                return decodePolyline6Inline(encoded);
            }
        }

        function decodePolyline6Inline(encoded) {
            if (!encoded || typeof encoded !== 'string') return [];
            let index = 0, lat = 0, lon = 0, coords = [];
            const shift = 5;
            
            const next = () => {
                let result = 0, b, i = 0;
                do {
                    if (index >= encoded.length) return null;
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << (i * shift);
                    i++;
                } while (b >= 0x20);
                return (result & 1) ? ~(result >> 1) : (result >> 1);
            };
            
            while (index < encoded.length) {
                const dlat = next();
                const dlon = next();
                if (dlat === null || dlon === null) break;
                lat += dlat;
                lon += dlon;
                coords.push([lat / 1e6, lon / 1e6]);
            }
            return coords;
        }

        function decodePolyline(encoded, usePolyline6 = false) {
            try {
                if (!encoded || typeof encoded !== 'string') {
                    console.error('[POLYLINE] Keine g√ºltige Polyline-String √ºbergeben:', encoded);
                    return null;
                }
                
                // Entferne "polyline(" und ")" falls vorhanden
                let cleanEncoded = encoded.replace(/^polyline\(/i, '').replace(/\)$/i, '').trim();
                
                if (cleanEncoded.length === 0) {
                    console.error('[POLYLINE] Leerer String nach Bereinigung');
                    return null;
                }
                
                console.log(`[POLYLINE] Bereinigte Polyline (${cleanEncoded.length} Zeichen, Polyline6: ${usePolyline6}): ${cleanEncoded.substring(0, 30)}...`);
                
                // Wenn Polyline6 gew√ºnscht, verwende Polyline6-Decoder
                if (usePolyline6) {
                    const decoded = decodePolyline6Inline(cleanEncoded);
                    if (decoded && decoded.length > 0) {
                        console.log(`[POLYLINE] Polyline6 dekodiert: ${decoded.length} Punkte`);
                        return decoded;
                    }
                }
                
                // Pr√ºfe ob @mapbox/polyline verf√ºgbar ist (f√ºr Polyline5)
                if (typeof polyline !== 'undefined' && typeof polyline.decode === 'function') {
                    try {
                        // Verwende @mapbox/polyline Library (OSRM verwendet Precision 5)
                        const decoded = polyline.decode(cleanEncoded);
                        console.log(`[POLYLINE] @mapbox/polyline dekodiert: ${decoded.length} Punkte`);
                        return decoded.map(coord => [coord[0], coord[1]]);
                    } catch (polylineError) {
                        console.warn('[POLYLINE] @mapbox/polyline Fehler, verwende Fallback:', polylineError);
                    }
                }
                
                // Fallback: Eigene Implementierung f√ºr Polyline5 (wenn Library nicht verf√ºgbar)
                console.log('[POLYLINE] Verwende Fallback-Implementierung (Polyline5)');
                const coordinates = [];
                let index = 0;
                const len = cleanEncoded.length;
                let lat = 0;
                let lng = 0;
                
                try {
                    while (index < len) {
                        let b, shift = 0, result = 0;
                        do {
                            if (index >= len) break;
                            b = cleanEncoded.charCodeAt(index++) - 63;
                            result |= (b & 0x1f) << shift;
                            shift += 5;
                        } while (b >= 0x20);
                        
                        const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                        lat += dlat;
                        
                        shift = 0;
                        result = 0;
                        do {
                            if (index >= len) break;
                            b = cleanEncoded.charCodeAt(index++) - 63;
                            result |= (b & 0x1f) << shift;
                            shift += 5;
                        } while (b >= 0x20);
                        
                        const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                        lng += dlng;
                        
                        coordinates.push([lat / 1e5, lng / 1e5]);
                    }
                    
                    console.log(`[POLYLINE] Fallback dekodiert: ${coordinates.length} Punkte`);
                    return coordinates;
                } catch (fallbackError) {
                    console.error('[POLYLINE] Fallback-Implementierung Fehler:', fallbackError);
                    return null;
                }
            } catch (error) {
                console.error('[POLYLINE] Fehler beim Dekodieren:', error);
                return null;
            }
        }

        // Zeichne OSRM-Routen-Linien zwischen Stopps (inkl. Depot)
        async function drawRouteLines(customers, routeColor, includeDepot = false) {
            if (!map || !customers || customers.length < 1) {
                return;
            }

            // Filtere Kunden mit Koordinaten
            const customersWithCoords = customers.filter(c => hasCoordinates(c));
            if (customersWithCoords.length < 1) {
                return;
            }

            // Depot-Koordinaten
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;

            try {
                // Bereite Stopps f√ºr API vor (Backend erwartet nur lat/lon, keine anderen Felder)
                // WICHTIG: Wenn includeDepot, f√ºge Depot am Anfang und Ende hinzu
                let stops = customersWithCoords.map(c => {
                    // Konvertiere latitude/longitude zu lat/lon falls n√∂tig
                    const lat = parseFloat(c.lat || c.latitude);
                    const lon = parseFloat(c.lon || c.longitude);
                    if (isNaN(lat) || isNaN(lon)) {
                        console.warn('[ROUTE-DETAILS] Ung√ºltige Koordinaten:', c);
                        return null;
                    }
                    return { lat: lat, lon: lon };
                }).filter(s => s !== null); // Filtere ung√ºltige Koordinaten
                
                // Depot am Anfang und Ende hinzuf√ºgen (wenn includeDepot)
                if (includeDepot && stops.length > 0) {
                    stops = [
                        { lat: depotLat, lon: depotLon },
                        ...stops,
                        { lat: depotLat, lon: depotLon }
                    ];
                }
                
                // Pr√ºfe ob genug Stopps vorhanden sind
                if (stops.length < 2) {
                    console.warn('[ROUTE-DETAILS] Zu wenige Stopps f√ºr Routing:', stops.length);
                    drawStraightLines(customersWithCoords, routeColor, includeDepot);
                    return;
                }

                // Hole Route-Details vom Backend
                const response = await fetch('/api/tour/route-details', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stops: stops }) // Backend erwartet nur stops, kein include_depot
                });

                if (!response.ok) {
                    console.warn('Route-Details nicht verf√ºgbar, zeichne gerade Linien');
                    // Fallback: Zeichne gerade Linien zwischen Stopps (inkl. Depot)
                    drawStraightLines(customersWithCoords, routeColor, includeDepot);
                    return;
                }

                const routeData = await response.json();
                console.log('[ROUTE-DETAILS] Response erhalten:', routeData);
                
                // Backend gibt ein einzelnes Objekt zur√ºck, nicht ein Array
                // Struktur: { geometry_polyline6, total_distance_m, total_duration_s, source, warnings, degraded }
                const geometry = routeData.geometry_polyline6;
                
                if (!geometry || typeof geometry !== 'string' || geometry.trim().length === 0) {
                    console.warn('[ROUTE-VIS] Keine Geometrie erhalten, verwende Fallback (gerade Linien)');
                    drawStraightLines(customersWithCoords, routeColor, includeDepot);
                    return;
                }

                // Zeichne die Route mit der erhaltenen Polyline6-Geometrie
                try {
                    const startTime = performance.now();
                    console.log(`[ROUTE-VIS] Versuche Polyline6 zu dekodieren (L√§nge: ${geometry.length} Zeichen)`);
                    
                    // Backend liefert immer Polyline6
                    const decodedCoordinates = decodePolyline6Inline(geometry);
                    
                    const decodeTime = performance.now() - startTime;
                    console.log(`[ROUTE-VIS] Dekodierung dauerte ${decodeTime.toFixed(2)}ms`);
                    
                    if (decodedCoordinates && decodedCoordinates.length > 0) {
                        // Zeichne stra√üenbasierte Route mit dekodierten Koordinaten
                        console.log(`[ROUTE-VIS] ‚úÖ Dekodierung erfolgreich: ${decodedCoordinates.length} Koordinaten-Punkte`);
                        console.log(`[ROUTE-VIS] Erste Koordinate: [${decodedCoordinates[0][0]}, ${decodedCoordinates[0][1]}]`);
                        console.log(`[ROUTE-VIS] Letzte Koordinate: [${decodedCoordinates[decodedCoordinates.length-1][0]}, ${decodedCoordinates[decodedCoordinates.length-1][1]}]`);
                        
                        const polyline = L.polyline(decodedCoordinates, {
                            color: routeColor || '#2196F3',
                            weight: 4,
                            opacity: 0.7
                        });
                        
                        // Popup mit Distanz und Dauer
                        const distanceKm = (routeData.total_distance_m || 0) / 1000;
                        const durationMin = (routeData.total_duration_s || 0) / 60;
                        const popupText = `
                            <strong>Route</strong><br>
                            Distanz: ${distanceKm.toFixed(1)} km<br>
                            Dauer: ${durationMin.toFixed(1)} Min<br>
                            Quelle: ${routeData.source || 'unbekannt'}
                            ${routeData.degraded ? '<br><span class="text-warning">‚ö† Degradiert</span>' : ''}
                        `;
                        polyline.bindPopup(popupText);
                        polyline.addTo(map);
                        tourRouteLines.push(polyline);
                        console.log(`[ROUTE-VIS] OSRM-Route gezeichnet: ${decodedCoordinates.length} Punkte`);
                    } else {
                        console.warn(`[ROUTE-VIS] ‚ùå Dekodierung gab keine Koordinaten zur√ºck`);
                        // Fallback: Gerade Linien
                        drawStraightLines(customersWithCoords, routeColor, includeDepot);
                    }
                } catch (error) {
                    console.error('[ROUTE-VIS] Fehler beim Dekodieren der Polyline:', error);
                    console.error('[ROUTE-VIS] Error details:', error.message, error.stack);
                    // Fallback: Gerade Linien
                    drawStraightLines(customersWithCoords, routeColor, includeDepot);
                }

                console.log(`[ROUTE-VIS] Route gezeichnet (Source: ${routeData.source || 'unbekannt'})`);

                // Zeige Blitzer entlang der Route (falls vorhanden)
                // TODO: Blitzer-Integration sp√§ter hinzuf√ºgen wenn Backend das unterst√ºtzt
                // Das Backend liefert aktuell keine speed_cameras in der route-details Response
                // if (routeData.speed_cameras && Array.isArray(routeData.speed_cameras) && routeData.speed_cameras.length > 0) {
                //     console.log(`[ROUTE-VIS] ${routeData.speed_cameras.length} Blitzer entlang der Route gefunden`);
                //     clearSpeedCameraMarkers();
                //     routeData.speed_cameras.forEach(camera => {
                //         addSpeedCameraMarker(camera);
                //     });
                //     showSpeedCameraInfo(routeData.speed_camera_count || routeData.speed_cameras.length);
                // } else {
                //     clearSpeedCameraMarkers();
                // }
                
                // TODO: Hindernisse-Integration sp√§ter hinzuf√ºgen wenn Backend das unterst√ºtzt
                // if (routeData.traffic_incidents && Array.isArray(routeData.traffic_incidents) && routeData.traffic_incidents.length > 0) {
                //     console.log(`[ROUTE-VIS] ${routeData.traffic_incidents.length} Hindernisse entlang der Route gefunden`);
                //     clearTrafficIncidentMarkers();
                //     routeData.traffic_incidents.forEach(incident => {
                //         addTrafficIncidentMarker(incident);
                //     });
                //     showTrafficIncidentInfo(routeData.traffic_incident_count || routeData.traffic_incidents.length);
                // } else {
                //     clearTrafficIncidentMarkers();
                // }
            } catch (error) {
                console.error('Fehler beim Zeichnen der Routen:', error);
                // Fallback: Gerade Linien (inkl. Depot)
                drawStraightLines(customersWithCoords, routeColor, includeDepot);
            }
        }

        function showSpeedCameraInfo(count) {
            // Entferne vorhandenes Banner
            const existingBanner = document.getElementById('speedCameraInfoBanner');
            if (existingBanner) {
                existingBanner.remove();
            }

            // Erstelle Info-Banner
            const banner = document.createElement('div');
            banner.id = 'speedCameraInfoBanner';
            banner.className = 'alert alert-warning alert-dismissible fade show';
            banner.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 1000; max-width: 300px;';
            banner.innerHTML = `
                <strong><i class="fas fa-camera"></i> ${count} Blitzer entlang der Route</strong>
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            `;

            document.body.appendChild(banner);

            // Auto-Close nach 5 Sekunden
            setTimeout(() => {
                if (banner.parentNode) {
                    banner.remove();
                }
            }, 5000);
        }

        function clearTrafficIncidentMarkers() {
            if (!map) {
                return;
            }
            if (trafficIncidentMarkers && Array.isArray(trafficIncidentMarkers) && trafficIncidentMarkers.length) {
                trafficIncidentMarkers.forEach(marker => {
                    try {
                        if (marker && map.hasLayer(marker)) {
                            map.removeLayer(marker);
                        }
                    } catch (e) {
                        console.warn('Fehler beim Entfernen von Hindernis-Marker:', e);
                    }
                });
                trafficIncidentMarkers = [];
            }
        }

        function toggleTrafficIncidents() {
            showTrafficIncidents = !showTrafficIncidents;
            if (showTrafficIncidents) {
                // Zeige alle Hindernisse-Marker wieder an
                trafficIncidentMarkers.forEach(marker => {
                    if (marker && !map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                });
                updateTrafficIncidentToggleButton();
            } else {
                // Verstecke alle Hindernisse-Marker
                trafficIncidentMarkers.forEach(marker => {
                    if (marker && map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                });
                updateTrafficIncidentToggleButton();
            }
        }

        function updateTrafficIncidentToggleButton() {
            const btn = document.getElementById('toggleTrafficIncidentsBtn');
            if (btn) {
                if (showTrafficIncidents) {
                    btn.innerHTML = '<i class="fas fa-eye-slash"></i> Hindernisse ausblenden';
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-danger');
                } else {
                    btn.innerHTML = '<i class="fas fa-eye"></i> Hindernisse einblenden';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-secondary');
                }
            }
        }

        function addTrafficIncidentMarker(incident) {
            if (!map || !showTrafficIncidents) {
                return null;
            }

            // Bestimme Icon und Farbe basierend auf Typ und Severity
            let iconHtml = '';
            let iconColor = '#ff9800';  // Orange als Standard
            
            switch (incident.type) {
                case 'construction':
                    iconHtml = '<i class="fas fa-hard-hat" style="font-size: 18px; color: #ff9800;"></i>';
                    iconColor = '#ff9800';  // Orange f√ºr Baustellen
                    break;
                case 'accident':
                    iconHtml = '<i class="fas fa-car-crash" style="font-size: 18px; color: #f44336;"></i>';
                    iconColor = '#f44336';  // Rot f√ºr Unf√§lle
                    break;
                case 'closure':
                    iconHtml = '<i class="fas fa-road" style="font-size: 18px; color: #9c27b0;"></i>';
                    iconColor = '#9c27b0';  // Lila f√ºr Sperrungen
                    break;
                default:
                    iconHtml = '<i class="fas fa-exclamation-triangle" style="font-size: 18px; color: #ff9800;"></i>';
            }
            
            // Severity-basierte Gr√∂√üe
            let markerSize = 30;
            if (incident.severity === 'critical') {
                markerSize = 35;
                iconColor = '#d32f2f';  // Dunkleres Rot f√ºr kritisch
            } else if (incident.severity === 'high') {
                markerSize = 32;
            }

            const incidentIcon = L.divIcon({
                className: 'traffic-incident-marker',
                html: `
                    <div style="
                        position: relative;
                        width: ${markerSize}px;
                        height: ${markerSize}px;
                        background-color: rgba(255, 255, 255, 0.95);
                        border: 3px solid ${iconColor};
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
                    ">
                        ${iconHtml}
                    </div>
                `,
                iconSize: [markerSize, markerSize],
                iconAnchor: [markerSize/2, markerSize/2],
                popupAnchor: [0, -markerSize/2]
            });

            const marker = L.marker([incident.lat, incident.lon], {
                icon: incidentIcon,
                zIndexOffset: 400  // √úber Kunden-Markern, unter Blitzern
            });

            // Popup mit Hindernis-Details
            let popupContent = `<strong>`;
            
            if (incident.type === 'construction') {
                popupContent += `<i class="fas fa-hard-hat"></i> Baustelle`;
            } else if (incident.type === 'accident') {
                popupContent += `<i class="fas fa-car-crash"></i> Unfall`;
            } else if (incident.type === 'closure') {
                popupContent += `<i class="fas fa-road"></i> Sperrung`;
            } else {
                popupContent += `<i class="fas fa-exclamation-triangle"></i> Hindernis`;
            }
            
            popupContent += `</strong><br>`;
            
            // Severity-Badge
            const severityBadges = {
                'low': '<span class="badge badge-info">Niedrig</span>',
                'medium': '<span class="badge badge-warning">Mittel</span>',
                'high': '<span class="badge badge-danger">Hoch</span>',
                'critical': '<span class="badge badge-danger" style="background-color: #d32f2f;">Kritisch</span>'
            };
            popupContent += severityBadges[incident.severity] || '<span class="badge badge-secondary">Unbekannt</span>';
            popupContent += `<br>`;
            
            if (incident.delay_minutes > 0) {
                popupContent += `<strong>Verz√∂gerung:</strong> ~${incident.delay_minutes} Min<br>`;
            }
            
            if (incident.description) {
                popupContent += `<br>${incident.description}`;
            }
            
            if (incident.affected_roads && incident.affected_roads.length > 0) {
                popupContent += `<br><small><strong>Betroffene Stra√üen:</strong> ${incident.affected_roads.join(', ')}</small>`;
            }
            
            if (incident.radius_km) {
                popupContent += `<br><small><i class="fas fa-info-circle"></i> Radius: ${incident.radius_km} km</small>`;
            }

            marker.bindPopup(popupContent);
            marker.addTo(map);
            trafficIncidentMarkers.push(marker);

            return marker;
        }

        function showTrafficIncidentInfo(count) {
            // Entferne vorhandenes Banner
            const existingBanner = document.getElementById('trafficIncidentInfoBanner');
            if (existingBanner) {
                existingBanner.remove();
            }

            // Erstelle Info-Banner
            const banner = document.createElement('div');
            banner.id = 'trafficIncidentInfoBanner';
            banner.className = 'alert alert-danger alert-dismissible fade show';
            banner.style.cssText = 'position: fixed; top: 140px; right: 20px; z-index: 1000; max-width: 300px;';
            banner.innerHTML = `
                <strong><i class="fas fa-exclamation-triangle"></i> ${count} Hindernisse entlang der Route</strong>
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            `;

            document.body.appendChild(banner);

            // Auto-Close nach 5 Sekunden
            setTimeout(() => {
                if (banner.parentNode) {
                    banner.remove();
                }
            }, 5000);
        }

        // Fallback: Zeichne gerade Linien zwischen Stopps (inkl. Depot)
        function drawStraightLines(customersWithCoords, routeColor, includeDepot = false) {
            if (!map || customersWithCoords.length < 1) {
                return;
            }

            // Depot-Koordinaten
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;

            // Wenn includeDepot, f√ºge Depot am Anfang und Ende hinzu
            let points = customersWithCoords.map(c => ({
                lat: parseFloat(c.latitude),
                lon: parseFloat(c.longitude)
            }));

            if (includeDepot) {
                points = [
                    { lat: depotLat, lon: depotLon },
                    ...points,
                    { lat: depotLat, lon: depotLon }
                ];
            }

            if (points.length < 2) {
                return;
            }

            for (let i = 0; i < points.length - 1; i++) {
                const from = points[i];
                const to = points[i + 1];
                
                const fromLat = from.lat;
                const fromLon = from.lon;
                const toLat = to.lat;
                const toLon = to.lon;

                if (isNaN(fromLat) || isNaN(fromLon) || isNaN(toLat) || isNaN(toLon)) {
                    continue;
                }

                const polyline = L.polyline(
                    [[fromLat, fromLon], [toLat, toLon]],
                    {
                        color: routeColor || '#2196F3',
                        weight: 3,
                        opacity: 0.6,
                        dashArray: '10, 5'  // Gestrichelt f√ºr Fallback
                    }
                );
                polyline.addTo(map);
                tourRouteLines.push(polyline);
            }
        }

        async function resolveCustomerCoordinates(customer) {
            const lat = parseFloat(customer.latitude);
            const lon = parseFloat(customer.longitude);
            if (!isNaN(lat) && !isNaN(lon)) {
                return [lat, lon];
            }

            const key = `${customer.street || ''}|${customer.postal_code || ''}|${customer.city || ''}`;
            if (geoCache[key]) {
                return geoCache[key];
            }

            const parts = [customer.street, customer.postal_code, customer.city].filter(Boolean);
            if (!parts.length) {
                return null;
            }

            const address = encodeURIComponent(parts.join(', '));
            try {
                const response = await fetch(`/api/geocode?address=${address}`);
                if (!response.ok) {
                    return null;
                }
                const result = await response.json();
                if (result.lat !== undefined && result.lon !== undefined) {
                    const coords = [parseFloat(result.lat), parseFloat(result.lon)];
                    if (!isNaN(coords[0]) && !isNaN(coords[1])) {
                        geoCache[key] = coords;
                        customer.latitude = coords[0];
                        customer.longitude = coords[1];
                        return coords;
                    }
                }
            } catch (error) {
                console.warn('Geocoding fehlgeschlagen:', error);
            }

            return null;
        }
        
        // KI-Status aktualisieren
        function updateAIStatus(message, type = 'info') {
            const statusField = document.getElementById('aiStatusField');
            const statusText = document.getElementById('aiStatusText');
            
            if (!statusField || !statusText) return;
            
            // Typ-basierte Klassen
            statusField.className = 'alert mb-3';
            if (type === 'success') {
                statusField.classList.add('alert-success');
            } else if (type === 'warning') {
                statusField.classList.add('alert-warning');
            } else if (type === 'error' || type === 'danger') {
                statusField.classList.add('alert-danger');
            } else {
                statusField.classList.add('alert-info');
            }
            
            statusText.textContent = message;
        }
        
        // Automatische Optimierung f√ºr Touren mit > 4 Kunden
        async function autoOptimizeLargeTours(tours) {
            const MIN_CUSTOMERS_FOR_OPTIMIZATION = 4;
            const toursToOptimize = tours.filter(t => {
                const stops = t.stops || [];
                return stops.length > MIN_CUSTOMERS_FOR_OPTIMIZATION;
            });
            
            if (toursToOptimize.length === 0) {
                console.log('[AUTO-OPTIMIZE] Keine Touren mit > 4 Kunden gefunden');
                return;
            }
            
            console.log(`[AUTO-OPTIMIZE] Starte automatische Optimierung f√ºr ${toursToOptimize.length} Tour(en) mit > ${MIN_CUSTOMERS_FOR_OPTIMIZATION} Kunden`);
            updateAIStatus(`Automatische Optimierung: ${toursToOptimize.length} Tour(en) mit > ${MIN_CUSTOMERS_FOR_OPTIMIZATION} Kunden`, 'info');
            
            let optimizedCount = 0;
            let errorCount = 0;
            
            for (const tour of toursToOptimize) {
                try {
                    const stops = tour.stops || [];
                    const stopsWithCoords = stops.filter(s => s.lat && s.lon);
                    
                    if (stopsWithCoords.length === 0) {
                        console.warn(`[AUTO-OPTIMIZE] Tour ${tour.tour_id}: Keine Stopps mit Koordinaten`);
                        continue;
                    }
                    
                    const stopsForAPI = stopsWithCoords.map(s => ({
                        customer_number: s.order_id || s.customer_number || '',
                        name: s.customer || s.name || 'Unbekannt',
                        address: s.address || '',
                        lat: s.lat,
                        lon: s.lon,
                        street: s.street || '',
                        postal_code: s.postal_code || '',
                        city: s.city || '',
                        bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)  // BAR-Flag √ºbertragen
                    }));
                    
                    const response = await fetch('/api/tour/optimize', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            tour_id: tour.tour_id || 'Tour',
                            is_bar_tour: tour.is_bar_tour || false,  // WICHTIG: BAR-Status mitgeben
                            stops: stopsForAPI
                        })
                    });
                    
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const responseText = await response.text();
                    
                    if (response.ok) {
                        let result;
                        try {
                            result = JSON.parse(responseText);
                        } catch (e) {
                            console.error(`[AUTO-OPTIMIZE] JSON Parsing Fehler f√ºr Tour ${tour.tour_id}:`, e, 'Rohe Antwort:', responseText);
                            errorCount++;
                            continue;
                        }
                        if (result.success !== false) {
                            // WICHTIG: Aktualisiere Tour mit optimierter Reihenfolge
                            // Stelle sicher, dass sowohl stops als auch customers aktualisiert werden
                            const optimizedStops = result.optimized_stops || tour.stops;
                            
                            // Aktualisiere stops
                            tour.stops = optimizedStops;
                            
                            // Aktualisiere customers (f√ºr Frontend-Kompatibilit√§t)
                            tour.customers = optimizedStops.map(s => ({
                                customer_number: s.order_id || s.customer_number || '',
                                name: s.customer || s.name || 'Unbekannt',
                                street: s.street || '',
                                postal_code: s.postal_code || '',
                                city: s.city || '',
                                latitude: s.lat,
                                longitude: s.lon,
                                bar_flag: s.bar_flag || false,
                                address: s.address || (() => {
                                    const parts = [s.street, s.postal_code, s.city].filter(Boolean);
                                    return parts.join(', ') || '';
                                })(),
                                has_coordinates: !!(s.lat && s.lon)
                            }));
                            
                            tour.optimized = true;
                            tour.estimated_total_time = result.estimated_total_time_minutes;
                            tour.estimated_driving_time_minutes = result.estimated_driving_time_minutes;
                            tour.estimated_service_time_minutes = result.estimated_service_time_minutes;
                            tour.estimated_return_time_minutes = result.estimated_return_time_minutes || 0;
                            tour.reasoning = result.reasoning;
                            tour.optimization_method = result.optimization_method;
                            
                            optimizedCount++;
                            console.log(`[AUTO-OPTIMIZE] Tour ${tour.tour_id} optimiert (${result.estimated_total_time_minutes} Min, ${optimizedStops.length} Stopps)`);
                        }
                    } else {
                        // responseText wurde bereits gelesen
                        let errorText = responseText;
                        try {
                            const errorData = JSON.parse(responseText);
                            errorText = errorData.error || errorData.detail || responseText;
                        } catch (e) {
                            // Kein JSON, verwende rohen Text
                        }
                        console.warn(`[AUTO-OPTIMIZE] Tour ${tour.tour_id}: API-Fehler (${response.status}): ${errorText.substring(0, 100)}`);
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`[AUTO-OPTIMIZE] Fehler bei Tour ${tour.tour_id}:`, error);
                    errorCount++;
                }
            }
            
            if (optimizedCount > 0) {
                console.log(`[AUTO-OPTIMIZE] ${optimizedCount} Tour(en) optimiert, rendere UI neu...`);
                updateAIStatus(`Automatische Optimierung abgeschlossen: ${optimizedCount} Tour(en) optimiert${errorCount > 0 ? `, ${errorCount} Fehler` : ''}`, 'success');
                
                // WICHTIG: Stelle sicher, dass workflowResult vorhanden ist und aktualisiert wird
                if (workflowResult && workflowResult.tours) {
                    // Touren neu rendern mit optimierten Daten
                    // Dies aktualisiert allTourCustomers und die Tour-Liste
                    renderToursFromMatch(workflowResult);
                    
                    // State speichern
                    saveToursToStorage();
                    
                    console.log('[AUTO-OPTIMIZE] UI erfolgreich aktualisiert');
                } else {
                    console.warn('[AUTO-OPTIMIZE] workflowResult nicht verf√ºgbar, kann UI nicht aktualisieren');
                }
            } else if (errorCount > 0) {
                updateAIStatus(`Automatische Optimierung: ${errorCount} Fehler`, 'warning');
            } else {
                console.log('[AUTO-OPTIMIZE] Keine Touren optimiert (alle bereits optimal oder < 5 Kunden)');
            }
        }
        
        // Optimierung f√ºr einzelne Tour (von Zahnrad-Button)
        async function optimizeTour(tourKey, tourName) {
            const tourData = allTourCustomers[tourKey];
            if (!tourData || !tourData.customers || tourData.customers.length === 0) {
                alert('Keine Kunden f√ºr diese Tour gefunden.');
                return;
            }
            
            const customers = tourData.customers;
            const stopsWithCoords = customers.filter(c => hasCoordinates(c));
            
            if (stopsWithCoords.length === 0) {
                alert('Keine Kunden mit Koordinaten gefunden. Optimierung nicht m√∂glich.');
                return;
            }
            
            // Pr√ºfe ob Tour eine BAR-Tour ist
            const isBarTour = tourData.is_bar_tour || tourName.toUpperCase().includes('BAR');
            
            const stopsForAPI = stopsWithCoords.map(c => ({
                customer_number: c.customer_number || '',
                name: c.name || 'Unbekannt',
                address: c.address || c.resolved_address || '',
                lat: parseFloat(c.latitude),
                lon: parseFloat(c.longitude),
                street: c.street || '',
                postal_code: c.postal_code || '',
                city: c.city || '',
                bar_flag: c.bar_flag !== undefined ? c.bar_flag : isBarTour  // BAR-Flag √ºbertragen
            }));
            
            // Zeige Loading-Modal
            const modal = document.getElementById('optimizationModal');
            const modalBody = modal.querySelector('.modal-body');
            modalBody.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-2x"></i><br>Optimierung l√§uft...</div>';
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
            
            try {
                const response = await fetch('/api/tour/optimize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tour_id: tourName,
                        is_bar_tour: isBarTour,  // WICHTIG: BAR-Status mitgeben
                        stops: stopsForAPI
                    })
                });
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${responseText}`);
                }
                
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (e) {
                    console.error('[OPTIMIZE] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                    throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                }
                
                if (result.success === false) {
                    throw new Error(result.error || 'Optimierung fehlgeschlagen');
                }
                
                // Zeige Ergebnisse im Modal
                modalBody.innerHTML = `
                    <h6>Tour: ${tourName}</h6>
                    <p><strong>Optimierungsmethode:</strong> ${result.optimization_method || 'Unknown'}</p>
                    <p><strong>Gesch√§tzte Fahrzeit:</strong> ${result.estimated_driving_time_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    <p><strong>Service-Zeit:</strong> ${result.estimated_service_time_minutes || 0} Minuten (2 Min/Kunde √ó ${stopsWithCoords.length})</p>
                    <p><strong>Gesamtzeit:</strong> ${result.estimated_total_time_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    <p><strong>R√ºckfahrt zum Depot:</strong> ${result.estimated_return_time_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    <p><strong>Gesamt inkl. R√ºckfahrt:</strong> ${result.estimated_total_with_return_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    ${result.estimated_time_exceeds_one_hour ? '<p class="text-danger"><strong>‚ö†Ô∏è WARNUNG: Tour √ºberschreitet 60 Minuten!</strong></p>' : ''}
                    ${result.warnings && result.warnings.length > 0 ? `<div class="alert alert-warning"><strong>Warnungen:</strong><ul>${result.warnings.map(w => `<li>${w}</li>`).join('')}</ul></div>` : ''}
                    <div class="mt-3">
                        <button class="btn btn-primary" onclick="applyOptimization('${tourKey}', ${JSON.stringify(result.optimized_stops).replace(/"/g, '&quot;')})">
                            Optimierte Route √ºbernehmen
                        </button>
                    </div>
                `;
            } catch (error) {
                console.error('Optimierung Fehler:', error);
                modalBody.innerHTML = `<div class="alert alert-danger">Fehler: ${error.message}</div>`;
            }
        }
        
        // Wende optimierte Route an
        function applyOptimization(tourKey, optimizedStops) {
            const tourData = allTourCustomers[tourKey];
            if (!tourData) return;
            
            // Erstelle Mapping von customer_number zu optimiertem Stop
            const stopMap = new Map();
            optimizedStops.forEach((stop, idx) => {
                const key = stop.customer_number || stop.name;
                stopMap.set(key, { ...stop, optimized_index: idx });
            });
            
            // Sortiere Kunden nach optimierter Reihenfolge
            tourData.customers = tourData.customers.map(c => {
                const key = c.customer_number || c.name;
                const optimized = stopMap.get(key);
                return optimized ? { ...c, ...optimized } : c;
            }).sort((a, b) => {
                const aIdx = a.optimized_index ?? 9999;
                const bIdx = b.optimized_index ?? 9999;
                return aIdx - bIdx;
            });
            
            // Schlie√üe Modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('optimizationModal'));
            if (modal) modal.hide();
            
            // Aktualisiere Anzeige
            renderTourDetails(tourData);
            updateAIStatus(`Tour optimiert: Reihenfolge wurde aktualisiert`, 'success');
            
            // Speichere State
            saveToursToStorage();
        }
        
        // Sub-Routen Generator: Generiert Sub-Touren aus W-Touren
        async function generateSubRoutes() {
            const btn = document.getElementById('btnGenerateSubRoutes');
            const status = document.getElementById('subRouteStatus');
            
            if (!workflowResult || !workflowResult.tours || workflowResult.tours.length === 0) {
                updateAIStatus('Bitte zuerst eine CSV-Datei hochladen und den Workflow ausf√ºhren.', 'warning');
                alert('Bitte zuerst eine CSV-Datei hochladen und den Workflow ausf√ºhren.');
                return;
            }
            
            // Finde alle Touren, die optimiert werden m√ºssen
            // Regel: NUR Touren mit > 4 Kunden (keine Spezialbehandlung f√ºr W-Touren mehr)
            const MIN_CUSTOMERS_FOR_SUB_ROUTES = 4;
            
            const toursToOptimize = workflowResult.tours.filter(t => {
                const stops = t.stops || [];
                const customerCount = stops.length;
                
                // NUR Touren mit mehr als 4 Kunden aufteilen
                return customerCount > MIN_CUSTOMERS_FOR_SUB_ROUTES;
            });
            
            if (toursToOptimize.length === 0) {
                updateAIStatus(`Keine Touren zum Optimieren gefunden. (Touren mit > ${MIN_CUSTOMERS_FOR_SUB_ROUTES} Kunden)`, 'warning');
                alert(`Keine Touren zum Optimieren gefunden.\n\nGesucht werden Touren mit mehr als ${MIN_CUSTOMERS_FOR_SUB_ROUTES} Kunden.`);
                return;
            }
            
            console.log(`[SUB-ROUTES] Gefunden: ${toursToOptimize.length} Tour(en) zum Optimieren (alle mit > ${MIN_CUSTOMERS_FOR_SUB_ROUTES} Kunden)`);
            
            // UI: Zeige Fortschritt
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> L√§uft...';
            status.style.display = 'block';
            status.className = 'small text-info mb-3';
            status.innerHTML = `<i class="fas fa-info-circle"></i> Starte Optimierung f√ºr ${toursToOptimize.length} Tour(en)...`;
            
            // Progress Bar initialisieren
            const progressContainer = document.getElementById('subRouteProgress');
            const progressBar = document.getElementById('subRouteProgressBar');
            const progressText = document.getElementById('subRouteProgressText');
            const progressDetails = document.getElementById('subRouteProgressDetails');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);
            progressText.textContent = '0%';
            progressDetails.textContent = `Starte Optimierung...`;
            
            updateAIStatus(`Starte Optimierung f√ºr ${toursToOptimize.length} Tour(en) (${wTours.length} W-Touren)...`, 'info');
            
            try {
                // WICHTIG: Parallele Verarbeitung mit Batching (Semaphore-Pattern)
                const allSubRoutes = [];
                let successCount = 0;
                let errorCount = 0;
                
                // Batch-Gr√∂√üe: 3 Touren parallel (verhindert √úberlastung)
                const BATCH_SIZE = 3;
                const totalTours = toursToOptimize.length;
                
                // Hilfsfunktion: Verarbeite eine einzelne Tour
                async function processTour(tour, tourIndex) {
                    const stops = tour.stops || [];
                    if (stops.length === 0) {
                        return { success: false, skipped: true };
                    }
                    
                    // Bereite Stopps f√ºr API vor (inkl. BAR-Flag!)
                    const stopsForAPI = stops.map(s => ({
                        customer_number: s.order_id || s.customer_number || '',
                        name: s.customer || s.name || 'Unbekannt',
                        address: s.address || '',
                        lat: s.lat,
                        lon: s.lon,
                        street: s.street || '',
                        postal_code: s.postal_code || '',
                        city: s.city || '',
                        bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false) // BAR-Flag √ºbertragen!
                    }));
                    
                    // Filtere Stopps mit Koordinaten
                    const stopsWithCoords = stopsForAPI.filter(s => s.lat && s.lon);
                    
                    if (stopsWithCoords.length === 0) {
                        console.warn(`[SUB-ROUTES] Tour ${tour.tour_id}: Keine Stopps mit Koordinaten (${stopsForAPI.length} ohne Koords)`);
                        return { success: false, skipped: true, reason: 'no_coords' };
                    }
                    
                    console.log(`[SUB-ROUTES] Verarbeite Tour ${tour.tour_id} (${tourIndex + 1}/${totalTours}): ${stopsWithCoords.length}/${stopsForAPI.length} Stopps mit Koordinaten`);
                    
                    // API-Call f√ºr diese Tour
                    console.log(`[SUB-ROUTES] Sende Anfrage f√ºr Tour ${tour.tour_id} mit ${stopsWithCoords.length} Stopps:`, {
                        tour_id: tour.tour_id,
                        stops_sample: stopsWithCoords.slice(0, 2).map(s => ({
                            name: s.name,
                            lat: s.lat,
                            lon: s.lon,
                            has_coords: !!(s.lat && s.lon)
                        }))
                    });
                    
                    let response;
                    try {
                        response = await fetch('/api/tour/optimize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                tour_id: tour.tour_id || 'W-Tour',
                                is_bar_tour: tour.is_bar_tour || false,  // WICHTIG: BAR-Status mitgeben
                                stops: stopsWithCoords
                            })
                        });
                    } catch (fetch_error) {
                        console.error(`[SUB-ROUTES] Fetch-Fehler f√ºr Tour ${tour.tour_id}:`, fetch_error);
                        return { success: false, error: fetch_error.message, tour_id: tour.tour_id };
                    }
                    
                    // Hole Trace-ID aus Response-Header
                    const traceId = response.headers.get('X-Request-ID') || 'unknown';
                    
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const responseText = await response.text();
                    
                    if (!response.ok) {
                        let errorText = responseText;
                        let errorDetail = null;
                        try {
                            errorDetail = JSON.parse(responseText);
                            errorText = errorDetail.error || errorDetail.detail || responseText;
                        } catch (e) {
                            // Nicht JSON, verwende Text
                        }
                        
                        const errorInfo = {
                            status: response.status,
                            statusText: response.statusText,
                            error: errorText.substring(0, 500),
                            errorDetail: errorDetail,
                            trace_id: errorDetail?.trace_id || traceId,
                            stopsCount: stopsWithCoords.length,
                            tour_id: tour.tour_id,
                            stops_sample: stopsWithCoords.slice(0, 3).map(s => ({
                                name: s.name,
                                lat: s.lat,
                                lon: s.lon,
                                has_coords: !!(s.lat && s.lon)
                            }))
                        };
                        
                        console.error(`[SUB-ROUTES] API-Fehler f√ºr Tour ${tour.tour_id}:`, errorInfo);
                        
                        // Detaillierte Fehlermeldung anzeigen (mit Trace-ID)
                        const detailMsg = errorDetail?.error_detail || errorDetail?.detail || errorDetail?.error || errorText.substring(0, 100);
                        const traceIdMsg = errorInfo.trace_id ? ` (Trace: ${errorInfo.trace_id})` : '';
                        updateAIStatus(`Fehler bei Tour ${tour.tour_id}: ${response.status} - ${detailMsg}${traceIdMsg}`, 'warning');
                        
                        // Zeige Toast mit Trace-ID (falls verf√ºgbar)
                        if (errorInfo.trace_id && errorInfo.trace_id !== 'unknown') {
                            console.warn(`[SUB-ROUTES] Serverfehler ‚Äì Trace-ID: ${errorInfo.trace_id}`);
                        }
                        
                        return { success: false, error: errorText, tour_id: tour.tour_id, status: response.status };
                    }
                    
                    // responseText wurde bereits gelesen
                    let result;
                    try {
                        result = JSON.parse(responseText);
                        console.log(`[SUB-ROUTES] Tour ${tour.tour_id} optimiert:`, result);
                    } catch (e) {
                        console.error(`[SUB-ROUTES] JSON-Parse-Fehler f√ºr Tour ${tour.tour_id}:`, e, 'Rohe Antwort:', responseText);
                        return { success: false, error: 'JSON-Parse-Fehler', tour_id: tour.tour_id };
                    }
                    
                    // Pr√ºfe ob Erfolg
                    if (result.success === false) {
                        console.error(`[SUB-ROUTES] Optimierung fehlgeschlagen f√ºr Tour ${tour.tour_id}:`, result.error);
                        return { success: false, error: result.error || 'Optimierung fehlgeschlagen', tour_id: tour.tour_id };
                    }
                    
                    if (!result.optimized_stops || result.optimized_stops.length === 0) {
                        console.warn(`[SUB-ROUTES] Tour ${tour.tour_id}: Keine optimierten Stopps zur√ºckgegeben`);
                        return { success: false, error: 'Keine optimierten Stopps', tour_id: tour.tour_id };
                    }
                    
                    // Sammle Sub-Routen f√ºr diese Tour
                    const tourSubRoutes = [];
                    
                    // WICHTIG: Pr√ºfe ob Backend bereits Sub-Touren zur√ºckgegeben hat
                    if (result.is_split && result.sub_tours && result.sub_tours.length > 0) {
                        console.log(`[SUB-ROUTES] Backend hat ${result.sub_tours.length} Sub-Touren zur√ºckgegeben f√ºr Tour ${tour.tour_id}`);
                        
                        // WICHTIG: Entferne urspr√ºngliche Tour aus allTourCustomers (wird durch Sub-Touren ersetzt)
                        const originalTourKey = Object.keys(allTourCustomers).find(key => {
                            const t = allTourCustomers[key];
                            return t && (t.name === tour.tour_id || key.includes(tour.tour_id));
                        });
                        if (originalTourKey) {
                            console.log(`[SUB-ROUTES] Entferne urspr√ºngliche Tour ${originalTourKey} (wird durch Sub-Touren ersetzt)`);
                            delete allTourCustomers[originalTourKey];
                        }
                        
                        // Verwende Sub-Touren vom Backend
                        for (let subIdx = 0; subIdx < result.sub_tours.length; subIdx++) {
                            const subTour = result.sub_tours[subIdx];
                            const subRouteLetter = subTour.sub_route_letter || String.fromCharCode(65 + subIdx);
                            const subTourName = `${tour.tour_id} ${subRouteLetter}`;
                            
                            // Konvertiere Sub-Tour-Stopps in das Frontend-Format
                            const subCustomers = (subTour.optimized_stops || []).map(s => ({
                                customer_number: s.order_id || s.customer_number || '',
                                name: s.customer || s.name || 'Unbekannt',
                                street: s.street || '',
                                postal_code: s.postal_code || '',
                                city: s.city || '',
                                latitude: s.lat,
                                longitude: s.lon,
                                bar_flag: s.bar_flag || false,
                                address: s.address || (() => {
                                    const parts = [s.street, s.postal_code, s.city].filter(Boolean);
                                    return parts.join(', ') || '';
                                })(),
                                has_coordinates: !!(s.lat && s.lon)
                            }));
                            
                            // WICHTIG: Verwende generateTourKey() f√ºr konsistente Keys!
                            const tourMeta = {
                                tour_id: tour.tour_id,
                                _base_tour_id: tour._base_tour_id || extractBaseTourId(tour),
                                _sub_route: subRouteLetter
                            };
                            const subRouteKey = generateTourKey(tourMeta);
                            console.log(`[SUB-ROUTES] Generiere Key f√ºr Sub-Route: "${subRouteKey}" (Tour: ${tour.tour_id}, Sub-Route: ${subRouteLetter})`);
                            
                            allTourCustomers[subRouteKey] = {
                                name: subTourName,
                                type: tour.type || 'Workflow',
                                time: tour.time || '',
                                customers: subCustomers,
                                stops: subTour.optimized_stops || [],
                                optimization_method: result.optimization_method || 'deterministic',
                                estimated_driving_time_minutes: subTour.estimated_driving_time_minutes || 0,
                                estimated_service_time_minutes: subTour.estimated_service_time_minutes || 0,
                                estimated_total_time_minutes: subTour.estimated_total_time_minutes || 0,
                                estimated_return_time_minutes: subTour.estimated_return_time_minutes || 0,
                                estimated_total_with_return_minutes: subTour.estimated_total_with_return_minutes || 0,
                                _is_sub_route: true,
                                _parent_tour_id: tour.tour_id,
                                _sub_route_index: subIdx,
                                _sub_route_letter: subRouteLetter
                            };
                            
                            allSubRoutes.push({
                                tour_id: subTourName,
                                sub_route: subRouteLetter,
                                stops: subTour.optimized_stops || [],
                                driving_time: subTour.estimated_driving_time_minutes || 0,
                                service_time: subTour.estimated_service_time_minutes || 0,
                                return_time: subTour.estimated_return_time_minutes || 0,
                                total_time: subTour.estimated_total_with_return_minutes || 0,
                                reasoning: subTour.reasoning || `Sub-Route ${subRouteLetter}`
                            });
                        }
                        
                        console.log(`[SUB-ROUTES] ${result.sub_tours.length} Sub-Touren vom Backend verarbeitet und in allTourCustomers gespeichert`);
                        
                        // WICHTIG: NICHT hier rendern! Das w√ºrde die Sub-Routen √ºberschreiben.
                        // Stattdessen: Nur in allTourCustomers speichern, Rendering passiert am Ende in updateToursWithSubRoutes()
                        // renderToursFromCustomers(); // ‚ùå ENTFERNT - verursacht √úberschreibung!
                        // saveToursToStorage(); // ‚ùå ENTFERNT - wird am Ende gemacht
                        
                        return { success: true, sub_routes: tourSubRoutes, tour_id: tour.tour_id };
                    }
                    
                    // WICHTIG: Pr√ºfe OHNE R√ºckfahrt (R√ºckfahrt z√§hlt nicht in die 60-65 Min Regel)
                    // Regeln: Fahrzeit + Servicezeit ‚â§ 60-65 Minuten (ohne R√ºckfahrt)
                    const timeWithoutReturn = (result.estimated_driving_time_minutes || 0) + (result.estimated_service_time_minutes || 0);
                    const MAX_TIME_WITHOUT_RETURN = 65; // Minuten (inkl. Servicezeit, OHNE R√ºckfahrt!)
                    
                    // HINWEIS: Das Backend sollte bereits beim initialen Clustering die Touren korrekt aufteilen
                    // Diese Splitting-Logik ist nur ein Fallback f√ºr den Fall, dass das Backend-Clustering versagt hat
                    // Wenn Tour > 65 Minuten ‚Üí sollte eigentlich beim Clustering bereits in mehrere Touren (A, B, C) aufgeteilt worden sein
                    if (timeWithoutReturn > MAX_TIME_WITHOUT_RETURN) {
                        console.warn(`[SUB-ROUTES] WARNUNG: Tour ${tour.tour_id} √ºberschreitet Zeit-Constraint: ${timeWithoutReturn.toFixed(1)} Min > ${MAX_TIME_WITHOUT_RETURN} Min`);
                        console.warn(`[SUB-ROUTES] Diese Tour sollte beim initialen Clustering bereits in mehrere Touren (A, B, C) aufgeteilt worden sein!`);
                        console.warn(`[SUB-ROUTES] Verwende Fallback-Splitting als Notl√∂sung...`);
                        
                        // Fallback: Splitte in Sub-Touren (nur als Notl√∂sung)
                        const subTours = splitTourIntoSubRoutes(tour, result);
                        if (subTours && subTours.length > 0) {
                            tourSubRoutes.push(...subTours);
                            console.log(`[SUB-ROUTES] Tour ${tour.tour_id} in ${subTours.length} Sub-Routen aufgeteilt`);
                            return { success: true, sub_routes: tourSubRoutes, tour_id: tour.tour_id };
                        } else {
                            console.warn(`[SUB-ROUTES] Tour ${tour.tour_id}: splitTourIntoSubRoutes gab keine Routen zur√ºck`);
                            // Fallback: Als einzelne Route behandeln - WICHTIG: R√ºckfahrt zum Depot + BAR-Flags
                            const returnTime = result.estimated_return_time_minutes || 0;
                            const totalTimeWithReturn = (result.estimated_total_time_minutes || 0) + returnTime;
                            
                            // WICHTIG: Stelle sicher, dass BAR-Flags aus urspr√ºnglichen Stopps erhalten bleiben
                            const optimizedStopsWithBarFlags = result.optimized_stops.map(optStop => {
                                // Finde urspr√ºnglichen Stop mit gleicher customer_number oder name
                                const originalStop = stops.find(s => 
                                    (s.customer_number || s.order_id) === (optStop.customer_number || optStop.order_id) ||
                                    (s.customer || s.name) === (optStop.customer || optStop.name)
                                );
                                
                                // BAR-Flag: Erst vom optimierten Stop, dann vom urspr√ºnglichen Stop, dann Tour-Level
                                const barFlag = optStop.bar_flag !== undefined 
                                    ? !!optStop.bar_flag 
                                    : (originalStop && originalStop.bar_flag !== undefined 
                                        ? !!originalStop.bar_flag 
                                        : (tour.is_bar_tour || false));
                                
                                return {
                                    ...optStop,
                                    bar_flag: barFlag  // WICHTIG: BAR-Flag explizit setzen
                                };
                            });
                            
                            tourSubRoutes.push({
                                tour_id: tour.tour_id,
                                sub_route: 'A',
                                stops: optimizedStopsWithBarFlags,  // WICHTIG: Stopps mit BAR-Flags
                                driving_time: result.estimated_driving_time_minutes,
                                service_time: result.estimated_service_time_minutes,
                                return_time: returnTime,  // WICHTIG: R√ºckfahrt zum Depot
                                total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                                reasoning: result.reasoning || `Fallback Route (Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                            });
                            return { success: true, sub_routes: tourSubRoutes, tour_id: tour.tour_id };
                        }
                    } else {
                        // Tour passt in eine Route - WICHTIG: R√ºckfahrt zum Depot ber√ºcksichtigen + BAR-Flags
                        const returnTime = result.estimated_return_time_minutes || 0;
                        const totalTimeWithReturn = (result.estimated_total_time_minutes || 0) + returnTime;
                        
                        // WICHTIG: Stelle sicher, dass BAR-Flags aus urspr√ºnglichen Stopps erhalten bleiben
                        const optimizedStopsWithBarFlags = result.optimized_stops.map(optStop => {
                            // Finde urspr√ºnglichen Stop mit gleicher customer_number oder name
                            const originalStop = stops.find(s => 
                                (s.customer_number || s.order_id) === (optStop.customer_number || optStop.order_id) ||
                                (s.customer || s.name) === (optStop.customer || optStop.name)
                            );
                            
                            // BAR-Flag: Erst vom optimierten Stop, dann vom urspr√ºnglichen Stop, dann Tour-Level
                            const barFlag = optStop.bar_flag !== undefined 
                                ? !!optStop.bar_flag 
                                : (originalStop && originalStop.bar_flag !== undefined 
                                    ? !!originalStop.bar_flag 
                                    : (tour.is_bar_tour || false));
                            
                            return {
                                ...optStop,
                                bar_flag: barFlag  // WICHTIG: BAR-Flag explizit setzen
                            };
                        });
                        
                        tourSubRoutes.push({
                            tour_id: tour.tour_id,
                            sub_route: 'A',
                            stops: optimizedStopsWithBarFlags,  // WICHTIG: Stopps mit BAR-Flags
                            driving_time: result.estimated_driving_time_minutes,
                            service_time: result.estimated_service_time_minutes,
                            return_time: returnTime,  // WICHTIG: R√ºckfahrt zum Depot
                            total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                            reasoning: result.reasoning || `Tour passt in eine Route (Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                        });
                        console.log(`[SUB-ROUTES] Tour ${tour.tour_id} passt in eine Route: ${result.estimated_driving_time_minutes.toFixed(1)} Min Fahrt + ${result.estimated_service_time_minutes.toFixed(1)} Min Service + ${returnTime.toFixed(1)} Min R√ºckfahrt = ${totalTimeWithReturn.toFixed(1)} Min gesamt`);
                        return { success: true, sub_routes: tourSubRoutes, tour_id: tour.tour_id };
                    }
                }
                
                // WICHTIG: Parallele Batch-Verarbeitung mit Promise.allSettled
                console.log(`[SUB-ROUTES] Starte parallele Verarbeitung: ${totalTours} Touren in Batches von ${BATCH_SIZE}`);
                
                for (let batchStart = 0; batchStart < totalTours; batchStart += BATCH_SIZE) {
                    const batch = toursToOptimize.slice(batchStart, batchStart + BATCH_SIZE);
                    const batchNum = Math.floor(batchStart / BATCH_SIZE) + 1;
                    const totalBatches = Math.ceil(totalTours / BATCH_SIZE);
                    
                    console.log(`[SUB-ROUTES] Verarbeite Batch ${batchNum}/${totalBatches}: ${batch.length} Touren`);
                    updateAIStatus(`Verarbeite Batch ${batchNum}/${totalBatches} (${batch.length} Touren parallel)...`, 'info');
                    
                    // Aktualisiere Progress Bar
                    const progressPercent = Math.round((batchStart / totalTours) * 100);
                    progressBar.style.width = `${progressPercent}%`;
                    progressBar.setAttribute('aria-valuenow', progressPercent);
                    progressText.textContent = `${progressPercent}%`;
                    progressDetails.textContent = `Batch ${batchNum}/${totalBatches}: ${batch.length} Touren parallel`;
                    
                    // Parallele Verarbeitung des Batches
                    const batchPromises = batch.map((tour, idx) => processTour(tour, batchStart + idx));
                    const batchResults = await Promise.allSettled(batchPromises);
                    
                    // Verarbeite Ergebnisse
                    for (let i = 0; i < batchResults.length; i++) {
                        const result = batchResults[i];
                        const tour = batch[i];
                        
                        if (result.status === 'fulfilled') {
                            const tourResult = result.value;
                            if (tourResult.success) {
                                if (tourResult.sub_routes && tourResult.sub_routes.length > 0) {
                                    allSubRoutes.push(...tourResult.sub_routes);
                                }
                                successCount++;
                            } else if (tourResult.skipped) {
                                // √úbersprungen (z.B. keine Koordinaten)
                                console.log(`[SUB-ROUTES] Tour ${tour.tour_id} √ºbersprungen: ${tourResult.reason || 'unbekannt'}`);
                            } else {
                                // Fehler
                                console.error(`[SUB-ROUTES] Tour ${tour.tour_id} fehlgeschlagen:`, tourResult.error);
                                updateAIStatus(`Fehler bei Tour ${tour.tour_id}: ${tourResult.error || 'Unbekannt'}`, 'warning');
                                errorCount++;
                            }
                        } else {
                            // Promise rejected
                            console.error(`[SUB-ROUTES] Tour ${tour.tour_id} Promise rejected:`, result.reason);
                            updateAIStatus(`Fehler bei Tour ${tour.tour_id}: ${result.reason}`, 'warning');
                            errorCount++;
                        }
                    }
                    
                    // Aktualisiere Progress Bar nach Batch
                    const progressPercentAfter = Math.round(((batchStart + batch.length) / totalTours) * 100);
                    progressBar.style.width = `${progressPercentAfter}%`;
                    progressBar.setAttribute('aria-valuenow', progressPercentAfter);
                    progressText.textContent = `${progressPercentAfter}%`;
                    progressDetails.textContent = `Abgeschlossen: ${successCount} erfolgreich, ${errorCount} Fehler`;
                }
                
                console.log(`[SUB-ROUTES] Verarbeitung abgeschlossen: ${successCount} erfolgreich, ${errorCount} Fehler`);
                
                // Zeige Ergebnisse
                console.log(`[SUB-ROUTES] Zusammenfassung: ${successCount} erfolgreich, ${errorCount} Fehler, ${allSubRoutes.length} Routen generiert`);
                
                if (allSubRoutes.length > 0) {
                    status.innerHTML = `<i class="fas fa-check text-success"></i> ${allSubRoutes.length} Route(n) generiert! (${successCount} erfolgreich, ${errorCount} Fehler)`;
                    status.className = 'small text-success mb-3';
                    updateAIStatus(`${allSubRoutes.length} Route(n) erfolgreich generiert (${successCount} Touren verarbeitet)`, 'success');
                    
                    // Aktualisiere Tour-Liste mit Sub-Routen
                    updateToursWithSubRoutes(allSubRoutes);
                    
                    // Optional: Navigiere zur erweiterten Ansicht
                    localStorage.setItem('subRoutes', JSON.stringify(allSubRoutes));
                } else {
                    // Detaillierte Fehlermeldung
                    let errorDetails = [];
                    if (toursToOptimize.length === 0) {
                        errorDetails.push('Keine Touren zum Optimieren gefunden');
                    } else {
                        const toursWithoutCoords = toursToOptimize.filter(t => {
                            const stops = t.stops || [];
                            return stops.filter(s => s.lat && s.lon).length === 0;
                        });
                        if (toursWithoutCoords.length > 0) {
                            errorDetails.push(`${toursWithoutCoords.length} Tour(en) ohne Koordinaten`);
                        }
                        const processedTours = toursToOptimize.length - toursWithoutCoords.length;
                        if (processedTours > 0 && allSubRoutes.length === 0) {
                            errorDetails.push(`API-Fehler bei allen ${processedTours} Tour(en)`);
                        }
                        if (errorCount > 0) {
                            errorDetails.push(`${errorCount} Tour(en) konnten nicht verarbeitet werden`);
                        }
                    }
                    
                    const errorMsg = errorDetails.length > 0 
                        ? `Keine Sub-Routen generiert: ${errorDetails.join(', ')}`
                        : 'Keine Sub-Routen konnten generiert werden.';
                    
                    progressDetails.textContent = `Fehler: ${errorMsg}`;
                    progressBar.classList.remove('progress-bar-animated');
                    progressBar.classList.add('bg-danger');
                    throw new Error(errorMsg);
                }
                
                // Progress Bar auf 100% setzen
                progressBar.style.width = '100%';
                progressBar.setAttribute('aria-valuenow', 100);
                progressText.textContent = '100%';
                progressBar.classList.remove('progress-bar-animated');
                if (allSubRoutes.length > 0) {
                    progressDetails.textContent = `Fertig! ${allSubRoutes.length} Route(n) generiert (${successCount} erfolgreich, ${errorCount} Fehler)`;
                }
                
            } catch (error) {
                console.error('Sub-Routen Generator Fehler:', error);
                status.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> Fehler: ${error.message}`;
                status.className = 'small text-danger mb-3';
                progressDetails.textContent = `Fehler: ${error.message}`;
                progressBar.classList.remove('progress-bar-animated');
                progressBar.classList.add('bg-danger');
                updateAIStatus(`Fehler: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-magic"></i> Routen optimieren (W-Touren & >4 Kunden)';
                // Progress Bar nach 3 Sekunden ausblenden (wenn erfolgreich) oder nach 5 Sekunden (bei Fehler)
                const progressContainer = document.getElementById('subRouteProgress');
                if (progressBar.classList.contains('bg-danger')) {
                    // Bei Fehler: Nach 5 Sekunden ausblenden
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 5000);
                } else {
                    // Bei Erfolg: Nach 3 Sekunden ausblenden
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 3000);
                }
            }
        }
        
        // Splitte Tour in Sub-Routen wenn > 60 Minuten
        function splitTourIntoSubRoutes(tour, optimizationResult) {
            console.log('[SPLIT] Starte Split f√ºr Tour:', tour.tour_id, optimizationResult);
            
            const stops = optimizationResult.optimized_stops || [];
            if (!stops || stops.length === 0) {
                console.warn('[SPLIT] Keine Stopps zum Aufteilen');
                return [];
            }
            
            // WICHTIG: Regeln - OHNE R√ºckfahrt z√§hlen!
            // Fahrzeit + Servicezeit ‚â§ 65 Minuten (ohne R√ºckfahrt)
            // R√ºckfahrt kommt DANACH und z√§hlt NICHT in die 60-65 Minuten!
            const maxTimePerRoute = 65; // Minuten (OHNE R√ºckfahrt zum Depot!)
            const serviceTimePerStop = 2; // Minuten
            const estimatedDrivingTime = optimizationResult.estimated_driving_time_minutes || 0;
            const estimatedServiceTime = optimizationResult.estimated_service_time_minutes || (stops.length * serviceTimePerStop);
            const estimatedReturnTime = optimizationResult.estimated_return_time_minutes || 0;
            
            // WICHTIG: Zeit OHNE R√ºckfahrt (f√ºr Pr√ºfung)
            const timeWithoutReturn = estimatedDrivingTime + estimatedServiceTime;
            // Gesamtzeit MIT R√ºckfahrt (nur f√ºr Anzeige)
            const totalTimeWithReturn = timeWithoutReturn + estimatedReturnTime;
            
            console.log(`[SPLIT] Tour ${tour.tour_id}: ${stops.length} Stopps`);
            console.log(`[SPLIT] Zeit OHNE R√ºckfahrt: ${timeWithoutReturn.toFixed(1)} Min (Fahrt: ${estimatedDrivingTime.toFixed(1)}, Service: ${estimatedServiceTime.toFixed(1)})`);
            console.log(`[SPLIT] R√ºckfahrt: ${estimatedReturnTime.toFixed(1)} Min ‚Üí Gesamt: ${totalTimeWithReturn.toFixed(1)} Min`);
            console.log(`[SPLIT] Regel: ${timeWithoutReturn.toFixed(1)} Min ‚â§ ${maxTimePerRoute} Min (ohne R√ºckfahrt)`);
            
            // WICHTIG: Pr√ºfe OHNE R√ºckfahrt (R√ºckfahrt z√§hlt nicht in die 60-65 Min Regel)
            if (timeWithoutReturn <= maxTimePerRoute) {
                console.log(`[SPLIT] Tour ${tour.tour_id} passt in eine Route (${timeWithoutReturn.toFixed(1)} Min ohne R√ºckfahrt <= ${maxTimePerRoute} Min)`);
                // WICHTIG: Stelle sicher, dass alle Stopps bar_flag haben
                const stopsWithBarFlags = stops.map(s => ({
                    ...s,
                    bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)
                }));
                return [{
                    tour_id: tour.tour_id,
                    sub_route: 'A',
                    stops: stopsWithBarFlags,  // Stopps mit BAR-Flags
                    driving_time: estimatedDrivingTime,
                    service_time: estimatedServiceTime,
                    return_time: estimatedReturnTime,  // WICHTIG: R√ºckfahrt zum Depot
                    total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                    reasoning: optimizationResult.reasoning || `Tour passt in eine Route (Depot ‚Üí ${stops.length} Kunden ‚Üí Depot, ${timeWithoutReturn.toFixed(1)} Min ohne R√ºckfahrt, ${totalTimeWithReturn.toFixed(1)} Min gesamt)`
                }];
            }
            
            // Berechne Anzahl der ben√∂tigten Routen (basierend auf Zeit OHNE R√ºckfahrt)
            const timePerStop = timeWithoutReturn / stops.length;
            const estimatedRoutes = Math.ceil(timeWithoutReturn / maxTimePerRoute);
            const stopsPerRoute = Math.ceil(stops.length / estimatedRoutes);
            
            console.log(`[SPLIT] Ben√∂tige ca. ${estimatedRoutes} Route(n), ${stopsPerRoute} Stopps pro Route`);
            
            const subRoutes = [];
            let currentRoute = [];
            let currentDrivingTime = 0;
            let currentServiceTime = 0;
            let routeLetter = 'A';
            
            // VARIABLE Splitting-Logik: Verwende tats√§chliche Distanzen zwischen Stopps
            // Entweder aus segment_distances (vom Backend) oder berechnet aus Koordinaten
            const segmentDistances = optimizationResult.segment_distances || [];
            // Depot-Koordinaten: FAMO Dresden (Gittersee)
            const depotCoords = optimizationResult.depot_coordinates || { lat: 51.01127, lon: 13.70161 };
            const speedKmh = 50.0; // Durchschnittsgeschwindigkeit
            
            // Hilfsfunktion: Haversine-Distanz berechnen
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371.0; // Erdradius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            // Berechne Distanz/Fahrzeit zum n√§chsten Stop
            function getDriveTimeToNextStop(currentIndex, nextIndex) {
                // Versuche segment_distances zu verwenden (vom Backend)
                // segment_distances[0] = Depot ‚Üí Stop 0
                // segment_distances[1] = Stop 0 ‚Üí Stop 1
                // segment_distances[i] = Stop i-1 ‚Üí Stop i
                if (segmentDistances.length > 0) {
                    if (currentIndex === -1 && nextIndex === 0) {
                        // Depot ‚Üí Erster Stop
                        const segment = segmentDistances[0];
                        if (segment && segment.driving_time_minutes !== undefined) {
                            return segment.driving_time_minutes;
                        }
                    } else if (currentIndex >= 0 && nextIndex > currentIndex && nextIndex < segmentDistances.length) {
                        // Stop currentIndex ‚Üí Stop nextIndex (segment_distances[nextIndex] = Stop nextIndex-1 ‚Üí Stop nextIndex)
                        const segment = segmentDistances[nextIndex];
                        if (segment && segment.driving_time_minutes !== undefined) {
                            return segment.driving_time_minutes;
                        }
                    }
                }
                
                // Fallback: Berechne aus Koordinaten
                if (currentIndex >= 0 && currentIndex < stops.length && 
                    nextIndex >= 0 && nextIndex < stops.length) {
                    const currentStop = stops[currentIndex];
                    const nextStop = stops[nextIndex];
                    
                    if (currentStop.lat && currentStop.lon && nextStop.lat && nextStop.lon) {
                        // Distanz berechnen
                        let distanceKm;
                        if (currentIndex === -1 && depotCoords) {
                            // Vom Depot zum ersten Stop
                            distanceKm = haversineDistance(
                                depotCoords.lat, depotCoords.lon,
                                nextStop.lat, nextStop.lon
                            );
                        } else {
                            // Zwischen zwei Stopps
                            distanceKm = haversineDistance(
                                currentStop.lat, currentStop.lon,
                                nextStop.lat, nextStop.lon
                            );
                        }
                        
                        // Faktor 1.3 f√ºr Stadtverkehr (Betriebsordnung ¬ß4)
                        const adjustedDistance = distanceKm * 1.3;
                        const drivingTime = (adjustedDistance / speedKmh) * 60;
                        return drivingTime;
                    }
                }
                
                // Letzter Fallback: 5 Minuten
                return 5.0;
            }
            
            console.log(`[SPLIT] Verwende variable Distanzen (${segmentDistances.length} Segmente vom Backend oder berechnet aus Koordinaten)`);
            
            // WICHTIG: Stelle sicher, dass bar_flag von urspr√ºnglichen Tour-Stopps √ºbernommen wird
            // BAR-Kunden sind immer die gleichen Firmen/Experten, daher muss das Flag IMMER erhalten bleiben
            const originalStops = tour.stops || [];
            const stopBarFlagMap = new Map();
            
            // Erstelle Mapping mit mehreren Schl√ºsseln (customer_number, name, etc.)
            originalStops.forEach(os => {
                // Mehrere Keys f√ºr besseres Matching
                const keys = [
                    os.order_id || '',
                    os.customer_number || '',
                    os.name || '',
                    (os.customer || '').toLowerCase().trim(),
                    (os.name || '').toLowerCase().trim()
                ].filter(k => k);
                
                const barFlag = os.bar_flag !== undefined ? os.bar_flag : (tour.is_bar_tour || false);
                
                keys.forEach(key => {
                    if (key) {
                        stopBarFlagMap.set(key.toLowerCase(), barFlag);
                    }
                });
            });
            
            // Erweitere Stopps mit bar_flag - PRIORIT√ÑT: Original-Stopps haben h√∂chste Priorit√§t
            stops.forEach(stop => {
                // Pr√ºfe mehrere Keys
                const searchKeys = [
                    stop.customer_number || '',
                    stop.name || '',
                    (stop.name || '').toLowerCase().trim(),
                    (stop.customer_number || '').toString()
                ].filter(k => k).map(k => k.toLowerCase());
                
                let foundBarFlag = false;
                for (const key of searchKeys) {
                    if (stopBarFlagMap.has(key)) {
                        stop.bar_flag = stopBarFlagMap.get(key);
                        foundBarFlag = true;
                        console.log(`[SPLIT] BAR-Flag f√ºr ${stop.name || stop.customer_number} √ºbertragen: ${stop.bar_flag}`);
                        break;
                    }
                }
                
                // Falls nicht gefunden, aber Tour ist BAR-Tour: setze auf true
                if (!foundBarFlag && tour.is_bar_tour) {
                    stop.bar_flag = true;
                    console.log(`[SPLIT] BAR-Flag aus Tour-Level f√ºr ${stop.name || stop.customer_number} gesetzt: true`);
                }
                
                // Fallback: Falls Stop bereits bar_flag hat, behalte es
                if (stop.bar_flag === undefined) {
                    stop.bar_flag = false; // Explizit setzen
                }
            });
            
            for (let i = 0; i < stops.length; i++) {
                const stop = stops[i];
                
                // Berechne Fahrzeit zum n√§chsten Stop (variabel!)
                // WICHTIG: Alle Sub-Routen starten am Depot (FAMO Hauptlager)!
                let driveTime;
                if (currentRoute.length === 0) {
                    // Erster Stop einer neuen Route: IMMER vom Depot!
                    // Jede Sub-Route beginnt am Depot (FAMO Hauptlager)
                    driveTime = getDriveTimeToNextStop(-1, i);  // Depot ‚Üí Erster Stop
                    console.log(`[SPLIT] Neue Route ${routeLetter} startet am Depot ‚Üí Stop ${i+1} (${driveTime.toFixed(1)} Min)`);
                } else {
                    // Vom vorherigen Stop in dieser Route
                    const prevIndex = stops.indexOf(currentRoute[currentRoute.length - 1]);
                    driveTime = getDriveTimeToNextStop(prevIndex, i);
                }
                const serviceTime = serviceTimePerStop;
                const totalForStop = driveTime + serviceTime;
                
                // WICHTIG: Berechne R√ºckfahrt-Zeit zum Depot (vom aktuellen Stop, wenn hinzugef√ºgt)
                let returnTimeToDepot = 0;
                if (stop.lat && stop.lon && depotCoords) {
                    const returnDistanceKm = haversineDistance(
                        stop.lat, stop.lon,
                        depotCoords.lat, depotCoords.lon
                    ) * 1.3; // Faktor 1.3 f√ºr Stadtverkehr
                    returnTimeToDepot = (returnDistanceKm / speedKmh) * 60;
                }
                
                console.log(`[SPLIT] Stop ${i+1}: Fahrt ${driveTime.toFixed(1)} Min, Service ${serviceTime} Min, R√ºckfahrt ${returnTimeToDepot.toFixed(1)} Min`);
                
                // WICHTIG: Pr√ºfe OHNE R√ºckfahrt (R√ºckfahrt z√§hlt nicht in die 60-65 Min Regel!)
                // Regel: Fahrzeit + Servicezeit ‚â§ 65 Minuten (ohne R√ºckfahrt)
                const timeWithoutReturn = currentDrivingTime + currentServiceTime + totalForStop;
                const wouldExceed = timeWithoutReturn > maxTimePerRoute;
                
                if (!wouldExceed) {
                    // WICHTIG: Stelle sicher, dass bar_flag beim Hinzuf√ºgen erhalten bleibt
                    const stopWithBarFlag = {
                        ...stop,
                        bar_flag: stop.bar_flag !== undefined ? stop.bar_flag : (tour.is_bar_tour || false)
                    };
                    currentRoute.push(stopWithBarFlag);
                    currentDrivingTime += driveTime;
                    currentServiceTime += serviceTime;
                    console.log(`[SPLIT] Stop ${i+1} (BAR: ${stopWithBarFlag.bar_flag}) hinzugef√ºgt. Route ${routeLetter}: ${currentRoute.length} Stopps, ${(currentDrivingTime + currentServiceTime).toFixed(1)} Min`);
                } else {
                    // Aktuelle Route speichern und neue starten
                    if (currentRoute.length > 0) {
                        // Stelle sicher, dass alle Stopps in dieser Route bar_flag haben
                        const stopsWithBarFlags = currentRoute.map(s => ({
                            ...s,
                            bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)
                        }));
                        
                        // WICHTIG: Berechne R√ºckfahrt zum Depot vom letzten Stop
                        let returnTimeToDepot = 0;
                        const lastStop = currentRoute[currentRoute.length - 1];
                        if (lastStop.lat && lastStop.lon && depotCoords) {
                            const returnDistanceKm = haversineDistance(
                                lastStop.lat, lastStop.lon,
                                depotCoords.lat, depotCoords.lon
                            ) * 1.3; // Faktor 1.3 f√ºr Stadtverkehr
                            returnTimeToDepot = (returnDistanceKm / speedKmh) * 60;
                        }
                        
                        const totalTimeWithReturn = currentDrivingTime + currentServiceTime + returnTimeToDepot;
                        
                        subRoutes.push({
                            tour_id: tour.tour_id,
                            sub_route: routeLetter,
                            stops: stopsWithBarFlags,  // Stopps mit BAR-Flags
                            driving_time: currentDrivingTime,
                            service_time: currentServiceTime,
                            return_time: returnTimeToDepot,  // WICHTIG: R√ºckfahrt zum Depot
                            total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                            reasoning: `Automatisch gesplittet: ${routeLetter} (${currentRoute.length} Stopps, Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                        });
                        console.log(`[SPLIT] Route ${routeLetter} abgeschlossen: ${currentRoute.length} Stopps, ${currentDrivingTime.toFixed(1)} Min Fahrt + ${currentServiceTime.toFixed(1)} Min Service + ${returnTimeToDepot.toFixed(1)} Min R√ºckfahrt = ${totalTimeWithReturn.toFixed(1)} Min gesamt`);
                        routeLetter = String.fromCharCode(routeLetter.charCodeAt(0) + 1);
                    }
                    
                    // Neue Route starten - WICHTIG: BAR-Flag erhalten
                    const newStopWithBarFlag = {
                        ...stop,
                        bar_flag: stop.bar_flag !== undefined ? stop.bar_flag : (tour.is_bar_tour || false)
                    };
                    currentRoute = [newStopWithBarFlag];
                    currentDrivingTime = 0; // Keine Fahrzeit zum ersten Stop (wird erst beim n√§chsten Stop berechnet)
                    currentServiceTime = serviceTime;
                    console.log(`[SPLIT] Neue Route ${routeLetter} gestartet mit Stop ${i+1} (BAR: ${newStopWithBarFlag.bar_flag})`);
                }
            }
            
            // Letzte Route speichern - WICHTIG: BAR-Flags erhalten + R√ºckfahrt zum Depot
            if (currentRoute.length > 0) {
                // Stelle sicher, dass alle Stopps in dieser Route bar_flag haben
                const stopsWithBarFlags = currentRoute.map(s => ({
                    ...s,
                    bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)
                }));
                
                // WICHTIG: Berechne R√ºckfahrt zum Depot vom letzten Stop
                let returnTimeToDepot = 0;
                const lastStop = currentRoute[currentRoute.length - 1];
                if (lastStop.lat && lastStop.lon && depotCoords) {
                    const returnDistanceKm = haversineDistance(
                        lastStop.lat, lastStop.lon,
                        depotCoords.lat, depotCoords.lon
                    ) * 1.3; // Faktor 1.3 f√ºr Stadtverkehr
                    returnTimeToDepot = (returnDistanceKm / speedKmh) * 60;
                }
                
                const totalTimeWithReturn = currentDrivingTime + currentServiceTime + returnTimeToDepot;
                
                subRoutes.push({
                    tour_id: tour.tour_id,
                    sub_route: routeLetter,
                    stops: stopsWithBarFlags,  // Stopps mit BAR-Flags
                    driving_time: currentDrivingTime,
                    service_time: currentServiceTime,
                    return_time: returnTimeToDepot,  // WICHTIG: R√ºckfahrt zum Depot
                    total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                    reasoning: `Automatisch gesplittet: ${routeLetter} (${currentRoute.length} Stopps, Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                });
                console.log(`[SPLIT] Finale Route ${routeLetter}: ${currentRoute.length} Stopps, ${currentDrivingTime.toFixed(1)} Min Fahrt + ${currentServiceTime.toFixed(1)} Min Service + ${returnTimeToDepot.toFixed(1)} Min R√ºckfahrt = ${totalTimeWithReturn.toFixed(1)} Min gesamt`);
            }
            
            // WICHTIG: Validierung nach Erstellen der Sub-Routen
            subRoutes.forEach(subRoute => {
                const barCount = subRoute.stops.filter(s => s.bar_flag === true).length;
                console.log(`[SPLIT] Validierung: Sub-Route ${subRoute.sub_route} hat ${barCount} BAR-Kunden von ${subRoute.stops.length} Stopps`);
                
                // Warnung wenn BAR-Kunden erwartet wurden aber fehlen
                if (tour.is_bar_tour && barCount === 0 && subRoute.stops.length > 0) {
                    console.warn(`[SPLIT] ‚ö†Ô∏è WARNUNG: Sub-Route ${subRoute.sub_route} sollte BAR-Kunden haben (Tour ist BAR-Tour), aber keiner gefunden!`);
                }
                
                // Info wenn BAR-Kunden vorhanden sind
                if (barCount > 0) {
                    const barCustomers = subRoute.stops.filter(s => s.bar_flag === true).map(s => s.name || s.customer_number || 'Unbekannt');
                    console.log(`[SPLIT] ‚úÖ Sub-Route ${subRoute.sub_route} enth√§lt BAR-Kunden: ${barCustomers.join(', ')}`);
                }
            });
            
            return subRoutes;
        }
        
        // Aktualisiere Tour-Liste mit Sub-Routen
        // Farbpalette f√ºr verschiedene Routen (jede Route bekommt eine eindeutige Farbe)
        // Hilfsfunktion: Konvertiert Buchstaben (A, B, C, ...) zu Zahlen (1, 2, 3, ...)
        function letterToNumber(letter) {
            if (!letter || letter.length === 0) return '';
            const charCode = letter.charCodeAt(0);
            if (charCode >= 65 && charCode <= 90) { // A-Z
                return (charCode - 64).toString(); // A=1, B=2, C=3, etc.
            }
            return letter; // Falls kein Buchstabe, unver√§ndert zur√ºckgeben
        }

        function getTourColor(tourId, routeIndex = null) {
            // Wenn routeIndex vorhanden ist (aus Workflow), verwende diesen f√ºr eindeutige Farbzuweisung
            if (routeIndex !== null && routeIndex !== undefined) {
                const colors = [
                    '#2196F3', // Blau
                    '#4CAF50', // Gr√ºn
                    '#FF9800', // Orange
                    '#9C27B0', // Lila
                    '#F44336', // Rot
                    '#00BCD4', // Cyan
                    '#795548', // Braun
                    '#607D8B', // Blau-Grau
                    '#E91E63', // Pink
                    '#3F51B5', // Indigo
                    '#FF5722', // Deep Orange
                    '#009688', // Teal
                    '#673AB7', // Deep Purple
                    '#CDDC39', // Lime
                    '#FFC107', // Amber
                    '#8BC34A', // Light Green
                    '#FF4081', // Pink
                    '#00E676', // Green A400
                    '#FF6D00', // Orange A700
                    '#2962FF', // Blue A700
                    '#AA00FF', // Purple A700
                    '#00BFA5', // Teal A700
                ];
                return colors[routeIndex % colors.length] || '#2196F3'; // Fallback: Blau
            }
            
            // Fallback: Extrahiere Tour-Zeit aus Tour-ID (z.B. "W-07.00" ‚Üí "07")
            const timeMatch = tourId.match(/W-(\d+)\.\d+/);
            if (timeMatch) {
                const hour = parseInt(timeMatch[1]);
                // Verschiedene Farben f√ºr verschiedene Stunden
                const colors = [
                    '#2196F3', // Blau (07:00)
                    '#4CAF50', // Gr√ºn (08:00)
                    '#FF9800', // Orange (09:00)
                    '#9C27B0', // Lila (10:00)
                    '#F44336', // Rot (11:00)
                    '#00BCD4', // Cyan (12:00)
                    '#795548', // Braun (13:00)
                    '#607D8B', // Blau-Grau (14:00)
                    '#E91E63', // Pink (15:00)
                    '#3F51B5', // Indigo (16:00)
                ];
                return colors[hour % colors.length] || '#2196F3'; // Fallback: Blau
            }
            return '#2196F3'; // Standard: Blau
        }
        
        function updateToursWithSubRoutes(subRoutes) {
            // Gruppiere nach urspr√ºnglicher Tour-ID
            const grouped = {};
            subRoutes.forEach(subRoute => {
                const key = subRoute.tour_id;
                if (!grouped[key]) {
                    grouped[key] = [];
                }
                grouped[key].push(subRoute);
            });
            
            // Aktualisiere workflowResult mit Sub-Routen
            if (workflowResult && workflowResult.tours) {
                workflowResult.tours = workflowResult.tours.map(tour => {
                    if (grouped[tour.tour_id]) {
                        // Ersetze Tour mit Sub-Routen
                        const baseTourId = tour.tour_id;
                        const tourColor = getTourColor(baseTourId);
                        
                        return grouped[baseTourId].map((sub, subIndex) => {
                            // WICHTIG: Stelle sicher, dass BAR-Flags in stops erhalten bleiben
                            const stopsWithBarFlags = sub.stops.map(stop => {
                                // BAR-Flag: Erst individuell, dann Tour-Level, dann false
                                const barFlag = stop.bar_flag !== undefined 
                                    ? !!stop.bar_flag 
                                    : (tour.is_bar_tour || false);
                                
                                return {
                                    ...stop,
                                    bar_flag: barFlag,  // WICHTIG: BAR-Flag explizit setzen
                                    // Stelle sicher, dass alle Felder vorhanden sind f√ºr renderToursFromMatch
                                    order_id: stop.order_id || stop.customer_number || '',
                                    customer_number: stop.customer_number || stop.order_id || '',
                                    customer: stop.customer || stop.name || 'Unbekannt',
                                    name: stop.name || stop.customer || 'Unbekannt',
                                    lat: stop.lat || stop.latitude,
                                    lon: stop.lon || stop.longitude,
                                    latitude: stop.latitude || stop.lat,
                                    longitude: stop.longitude || stop.lon,
                                    has_coordinates: !!(stop.lat || stop.latitude) && !!(stop.lon || stop.longitude)
                                };
                            });
                            
                            // WICHTIG: Konvertiere stops zu customers f√ºr Frontend-Anzeige und allTourCustomers
                            const customers = stopsWithBarFlags.map(stop => {
                                return {
                                    customer_number: stop.customer_number || stop.order_id || '',
                                    name: stop.name || stop.customer || 'Unbekannt',
                                    street: stop.street || '',
                                    postal_code: stop.postal_code || '',
                                    city: stop.city || '',
                                    bar_flag: stop.bar_flag,  // WICHTIG: BAR-Flag von stop √ºbernommen
                                    latitude: stop.lat || stop.latitude,
                                    longitude: stop.lon || stop.longitude,
                                    address: stop.address || (() => {
                                        const parts = [stop.street, stop.postal_code, stop.city].filter(Boolean);
                                        return parts.join(', ') || '';
                                    })(),
                                    has_coordinates: stop.has_coordinates
                                };
                            });
                            
                            // Berechne BAR-Count f√ºr diese Sub-Route
                            const barCount = customers.filter(c => c.bar_flag === true).length;
                            const hasBarCustomers = barCount > 0;
                            const tourIsBar = tour.is_bar_tour || hasBarCustomers;
                            
                            console.log(`[UPDATE-TOURS] Sub-Route ${baseTourId} ${sub.sub_route}: ${stopsWithBarFlags.length} Stops, ${barCount} BAR-Kunden`);
                            
                            return {
                                ...tour,
                                tour_id: `${baseTourId} ${sub.sub_route}`,
                                stops: stopsWithBarFlags,  // WICHTIG: F√ºr renderToursFromMatch (erwartet stops)
                                customers: customers,  // WICHTIG: F√ºr Frontend-Anzeige und allTourCustomers
                                driving_time_minutes: sub.driving_time,
                                service_time_minutes: sub.service_time,
                                return_time_minutes: sub.return_time || 0,  // WICHTIG: R√ºckfahrt zum Depot
                                total_time_minutes: sub.total_time,
                                _tour_color: tourColor, // Speichere Farbe f√ºr Rendering
                                _base_tour_id: baseTourId, // Original Tour-ID
                                _sub_route: sub.sub_route, // Sub-Route Buchstabe
                                is_bar_tour: tourIsBar,  // WICHTIG: BAR-Status basierend auf tats√§chlichen Kunden
                                bar_customer_count: barCount  // WICHTIG: Anzahl BAR-Kunden in dieser Sub-Route
                            };
                        });
                    }
                    return tour;
                }).flat();
                
                // ‚úÖ EINFACH: Rendere direkt aus workflowResult
                // renderToursFromMatch() erstellt automatisch allTourCustomers
                // KEINE manuelle Synchronisation n√∂tig - ZIP-Version funktioniert so!
                console.log(`[UPDATE-TOURS] Rendere Sub-Routen: ${workflowResult.tours.length} Touren`);
                renderToursFromMatch(workflowResult);
                saveToursToStorage();
            }
        }
        
        // Zeige Sub-Routen Generator Button wenn W-Touren oder gro√üe Touren vorhanden
        function updateSubRouteButtonVisibility() {
            const btn = document.getElementById('btnGenerateSubRoutes');
            if (!btn) return;
            
            let hasToursToOptimize = false;
            
            // Pr√ºfe workflowResult.tours
            if (workflowResult && workflowResult.tours) {
                hasToursToOptimize = workflowResult.tours.some(t => {
                    const tourId = t.tour_id || t.name || '';
                    const isWTour = /^W-\d+\.\d+/.test(tourId);
                    const stopCount = (t.stops || []).length;
                    const customerCount = (t.customers || []).length;
                    return isWTour || stopCount > 4 || customerCount > 4;
                });
            }
            
            // Fallback: allTourCustomers
            if (!hasToursToOptimize && allTourCustomers) {
                hasToursToOptimize = Object.values(allTourCustomers).some(tour => {
                    const tourName = tour.name || '';
                    const isWTour = /^W-\d+\.\d+/.test(tourName);
                    const customerCount = (tour.customers && tour.customers.length) || 0;
                    return isWTour || customerCount > 4;
                });
            }
            
            btn.style.display = hasToursToOptimize ? 'block' : 'none';
        }
        
        // ============================================
        // Panel-Funktionen (Abdockbare Fenster)
        // ============================================
        
        // Layout-Persistenz: Panel-Positionen speichern/laden
        function savePanelLayout(type, width, height, left, top) {
            try {
                const layout = {
                    width: width,
                    height: height,
                    left: left,
                    top: top,
                    timestamp: Date.now()
                };
                localStorage.setItem(`panel-layout-${type}`, JSON.stringify(layout));
            } catch (e) {
                console.warn('[PANEL] Konnte Layout nicht speichern:', e);
            }
        }
        
        function loadPanelLayout(type, defaults) {
            try {
                const saved = localStorage.getItem(`panel-layout-${type}`);
                if (saved) {
                    const layout = JSON.parse(saved);
                    // Layout ist 7 Tage g√ºltig
                    const maxAge = 7 * 24 * 60 * 60 * 1000;
                    if (Date.now() - layout.timestamp < maxAge) {
                        return {
                            width: layout.width || defaults.width,
                            height: layout.height || defaults.height,
                            left: layout.left || defaults.left,
                            top: layout.top || defaults.top
                        };
                    }
                }
            } catch (e) {
                console.warn('[PANEL] Konnte Layout nicht laden:', e);
            }
            return defaults;
        }
        
        function openMapPanel() {
            if (mapPanelWindow && !mapPanelWindow.closed) {
                mapPanelWindow.focus();
                return;
            }
            
            // Lade gespeichertes Layout oder verwende Defaults
            const defaults = {
                width: 1000,
                height: 700,
                left: (screen.width - 1000) / 2,
                top: (screen.height - 700) / 2
            };
            const layout = loadPanelLayout('map', defaults);
            
            mapPanelWindow = window.open('/panel-map.html', 'mapPanel', 
                `width=${layout.width},height=${layout.height},left=${layout.left},top=${layout.top},resizable=yes,scrollbars=yes`);
            
            if (!mapPanelWindow) {
                alert('Popup wurde blockiert. Bitte Popup-Blocker deaktivieren.');
                return;
            }
            
            // Speichere Layout beim Schlie√üen
            const saveLayoutOnClose = () => {
                if (mapPanelWindow && !mapPanelWindow.closed) {
                    try {
                        // Versuche Fenster-Dimensionen zu lesen (funktioniert nur wenn gleicher Origin)
                        const width = mapPanelWindow.innerWidth || layout.width;
                        const height = mapPanelWindow.innerHeight || layout.height;
                        const left = mapPanelWindow.screenX || layout.left;
                        const top = mapPanelWindow.screenY || layout.top;
                        savePanelLayout('map', width, height, left, top);
                    } catch (e) {
                        // Cross-origin oder Fenster geschlossen - verwende gespeicherte Werte
                        savePanelLayout('map', layout.width, layout.height, layout.left, layout.top);
                    }
                }
            };
            
            // Kontinuierliche Synchronisation (l√§uft solange Panel offen ist)
            const syncInterval = setInterval(() => {
                if (mapPanelWindow.closed) {
                    clearInterval(syncInterval);
                    saveLayoutOnClose();
                    mapPanelWindow = null;
                    if (window.mapPanelSyncInterval === syncInterval) {
                        window.mapPanelSyncInterval = null;
                    }
                    return;
                }
                // Sende aktuelle Karten-Daten
                syncMapToPanel();
            }, 1000); // Alle 1 Sekunde synchronisieren
            
            // Speichere Interval-ID f√ºr sp√§teres Cleanup
            window.mapPanelSyncInterval = syncInterval;
            
            // Speichere Layout beim Schlie√üen des Fensters
            mapPanelWindow.addEventListener('beforeunload', saveLayoutOnClose);
        }
        
        function openToursPanel() {
            if (toursPanelWindow && !toursPanelWindow.closed) {
                toursPanelWindow.focus();
                return;
            }
            
            // Lade gespeichertes Layout oder verwende Defaults
            const defaults = {
                width: 400,
                height: 700,
                left: screen.width - 400 - 50,
                top: (screen.height - 700) / 2
            };
            const layout = loadPanelLayout('tours', defaults);
            
            toursPanelWindow = window.open('/panel-tours.html', 'toursPanel', 
                `width=${layout.width},height=${layout.height},left=${layout.left},top=${layout.top},resizable=yes,scrollbars=yes`);
            
            if (!toursPanelWindow) {
                alert('Popup wurde blockiert. Bitte Popup-Blocker deaktivieren.');
                return;
            }
            
            // Speichere Layout beim Schlie√üen
            const saveLayoutOnClose = () => {
                if (toursPanelWindow && !toursPanelWindow.closed) {
                    try {
                        // Versuche Fenster-Dimensionen zu lesen (funktioniert nur wenn gleicher Origin)
                        const width = toursPanelWindow.innerWidth || layout.width;
                        const height = toursPanelWindow.innerHeight || layout.height;
                        const left = toursPanelWindow.screenX || layout.left;
                        const top = toursPanelWindow.screenY || layout.top;
                        savePanelLayout('tours', width, height, left, top);
                    } catch (e) {
                        // Cross-origin oder Fenster geschlossen - verwende gespeicherte Werte
                        savePanelLayout('tours', layout.width, layout.height, layout.left, layout.top);
                    }
                }
            };
            
            // Kontinuierliche Synchronisation (l√§uft solange Panel offen ist)
            const syncInterval = setInterval(() => {
                if (toursPanelWindow.closed) {
                    clearInterval(syncInterval);
                    saveLayoutOnClose();
                    toursPanelWindow = null;
                    if (window.toursPanelSyncInterval === syncInterval) {
                        window.toursPanelSyncInterval = null;
                    }
                    return;
                }
                // Sende aktuelle Tour-Daten
                syncToursToPanel();
            }, 1000); // Alle 1 Sekunde synchronisieren
            
            // Speichere Interval-ID f√ºr sp√§teres Cleanup
            window.toursPanelSyncInterval = syncInterval;
            
            // Speichere Layout beim Schlie√üen des Fensters
            toursPanelWindow.addEventListener('beforeunload', saveLayoutOnClose);
        }
        
        function syncMapToPanel() {
            if (!window.panelIPC) {
                console.warn('[SYNC] panelIPC nicht verf√ºgbar f√ºr Map');
                return;
            }
            
            // Sammle Route-Daten
            const routes = [];
            const markers = [];
            const bounds = [];
            
            // Route-Linien
            tourRouteLines.forEach((line, index) => {
                const latlngs = line.getLatLngs();
                if (latlngs && latlngs.length > 0) {
                    // Konvertiere zu Polyline6 (vereinfacht - in Produktion sollte echte Geometrie verwendet werden)
                    const color = line.options.color || '#3388ff';
                    routes.push({
                        geometry: null, // Wird sp√§ter aus Route-Details geladen
                        color: color,
                        geometry_type: 'polyline6'
                    });
                }
            });
            
            // Marker
            tourMarkers.forEach(marker => {
                const latlng = marker.getLatLng();
                markers.push({
                    lat: latlng.lat,
                    lon: latlng.lng,
                    name: marker.options.title || marker._popup?.content || 'Unbekannt',
                    color: marker.options.color || '#3388ff'
                });
                bounds.push([latlng.lat, latlng.lng]);
            });
            
            // Sende an Panel
            if (map && bounds.length > 0) {
                const mapBounds = map.getBounds();
                const mapData = {
                    routes: routes,
                    markers: markers,
                    bounds: [[mapBounds.getSouth(), mapBounds.getWest()], [mapBounds.getNorth(), mapBounds.getEast()]]
                };
                console.log('[SYNC] Sende Map-Update:', {
                    routes: routes.length,
                    markers: markers.length
                });
                window.panelIPC.postMessage('route-update', mapData);
            }
        }
        
        function syncToursToPanel() {
            if (!window.panelIPC) {
                console.warn('[SYNC] panelIPC nicht verf√ºgbar');
                return;
            }
            
            // Konvertiere allTourCustomers zu Panel-Format
            const tours = Object.entries(allTourCustomers).map(([key, tour]) => {
                const customers = tour.customers || [];
                return {
                    key: key,
                    name: tour.name || 'Unbekannte Tour',
                    stops: customers.length,
                    distance: 0, // Wird sp√§ter aus Route-Details geladen
                    duration: 0
                };
            });
            
            const syncData = {
                tours: tours,
                activeTourKey: activeTourKey
            };
            
            console.log('[SYNC] Sende Tours-Update:', {
                tourCount: tours.length,
                activeTourKey: activeTourKey,
                tours: tours.map(t => ({ key: t.key, name: t.name, stops: t.stops }))
            });
            
            // Sende via BroadcastChannel
            window.panelIPC.postMessage('tours-update', syncData);
            
            // ZUS√ÑTZLICH: Speichere auch in localStorage als Fallback
            // Panels k√∂nnen dann auch localStorage abfragen
            try {
                localStorage.setItem('panel-sync-tours', JSON.stringify(syncData));
                localStorage.setItem('panel-sync-timestamp', Date.now().toString());
            } catch (e) {
                console.warn('[SYNC] localStorage Fehler:', e);
            }
        }
        
        // IPC-Handler f√ºr Panel-Kommunikation
        if (window.panelIPC) {
            window.panelIPC.on('panel-ready', (data) => {
                console.log('Panel bereit:', data);
                if (data.type === 'map') {
                    syncMapToPanel();
                } else if (data.type === 'tours') {
                    syncToursToPanel();
                }
            });
            
            window.panelIPC.on('tour-selected', (data) => {
                if (data.tourKey && allTourCustomers[data.tourKey]) {
                    selectTour(data.tourKey);
                }
            });
            
            window.panelIPC.on('panel-closed', (data) => {
                if (data.type === 'map') {
                    if (window.mapPanelSyncInterval) {
                        clearInterval(window.mapPanelSyncInterval);
                        window.mapPanelSyncInterval = null;
                    }
                    mapPanelWindow = null;
                } else if (data.type === 'tours') {
                    if (window.toursPanelSyncInterval) {
                        clearInterval(window.toursPanelSyncInterval);
                        window.toursPanelSyncInterval = null;
                    }
                    toursPanelWindow = null;
                }
            });
        }
        
        // Synchronisiere Daten bei √Ñnderungen
        const originalRenderTours = window.renderToursFromWorkflow;
        if (originalRenderTours) {
            window.renderToursFromWorkflow = function(...args) {
                originalRenderTours.apply(this, args);
                // Synchronisiere mit Panels nach Rendering
                setTimeout(() => {
                    syncMapToPanel();
                    syncToursToPanel();
                }, 100);
            };
        }
        
        // Zus√§tzliche Event-Listener f√ºr kontinuierliche Synchronisation
        // Wenn allTourCustomers sich √§ndert, synchronisiere
        let lastTourCount = 0;
        setInterval(() => {
            const currentCount = Object.keys(allTourCustomers).length;
            if (currentCount !== lastTourCount) {
                lastTourCount = currentCount;
                syncToursToPanel();
                syncMapToPanel();
            }
        }, 2000); // Pr√ºfe alle 2 Sekunden auf √Ñnderungen
    </script>
</body>
</html>
