<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAMO TrafficApp</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { background-color: #f8f9fa; }
        #map { height: calc(60vh - 60px); border-radius: 8px; width: 100%; }
        .sidebar { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); max-height: calc(100vh - 120px); overflow-y: auto; }
        .tour-card-layout { display: flex; flex-direction: column; }
        @media (min-width: 768px) { .tour-card-layout { flex-direction: row; } }
        .tour-list-column { flex: 0 0 320px; padding: 1rem 1.5rem 1rem 0; border-right: 1px solid #dee2e6; }
        @media (max-width: 767.98px) {
            .tour-list-column { border-right: none; border-bottom: 1px solid #dee2e6; padding: 1rem 1.5rem; }
        }
        .tour-details-column { flex: 1 1 auto; padding: 1rem 1.5rem; }
        .tour-card-layout .list-group-item { border-radius: 0; }
        /* BAR-Tour Hervorhebung: Orange Hintergrund (wie fr√ºher) */
        .bar-tour-highlight {
            background-color: #ffe0b2 !important; /* Hellorange Hintergrund */
            border-left: 4px solid #ff9800 !important; /* Orange Border */
        }
        .bar-tour-highlight:hover {
            background-color: #ffcc80 !important; /* Mittelorange bei Hover */
        }
        .bar-tour-highlight.active {
            background-color: #ff9800 !important; /* Orange wenn aktiv */
            color: #000 !important;
            font-weight: bold;
        }
        /* W-Tour Hervorhebung: Andere Farbe (z.B. Blau/Gr√ºn) - erscheint GANZ OBEN */
        .w-tour-highlight {
            background-color: #e3f2fd !important; /* Hellblau Hintergrund */
            border-left: 4px solid #2196f3 !important; /* Blau Border */
            font-weight: 500 !important;
        }
        .w-tour-highlight:hover {
            background-color: #bbdefb !important; /* Helleres Blau bei Hover */
        }
        .w-tour-highlight.active {
            background-color: #2196f3 !important; /* Blau wenn aktiv */
            color: #fff !important;
            font-weight: bold;
        }
        /* Kombination: W-Tour + BAR */
        .w-tour-highlight.bar-tour-highlight {
            background-color: #fff3e0 !important; /* Hellorange-Gelb */
            border-left: 4px solid #ff9800 !important; /* Orange Border (BAR hat Priorit√§t) */
        }
        /* Optimierungs-Button Styling */
        .optimize-tour-btn {
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .optimize-tour-btn:hover {
            opacity: 1;
            color: #007bff !important;
        }
        .list-group-item:hover .optimize-tour-btn {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
        <div class="container-fluid">
            <a class="navbar-brand" href="/">FAMO TrafficApp</a>
            
            <!-- Navigation Links -->
            <div class="navbar-nav me-auto">
                <a class="nav-link active" href="/">Hauptseite</a>
                <a class="nav-link" href="/admin.html">
                    <i class="fas fa-cog"></i> Admin
                </a>
                <a class="nav-link" href="/ui/test-dashboard">
                    <i class="fas fa-vial"></i> Test-Dashboard
                </a>
                <a class="nav-link" href="/ui/ai-test">
                    <i class="fas fa-robot"></i> AI Test
                </a>
                <a class="nav-link" href="/docs">API Docs</a>
            </div>
            
            <!-- Status Indicators -->
            <div class="navbar-nav">
                <span class="navbar-text me-3">
                    <i class="fas fa-circle text-success"></i> Server online
                    </span>
                <span class="navbar-text me-3" id="osrmStatus">
                    <i class="fas fa-route text-warning"></i> OSRM pr√ºfe...
                </span>
                <span class="navbar-text me-3" id="llmStatus">
                    <i class="fas fa-circle text-warning"></i> LLM pr√ºfe...
                </span>
                <span class="navbar-text" id="dbStatus">
                    <i class="fas fa-database text-info"></i> DB pr√ºfe...
                </span>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3">
            <div class="sidebar" id="workflowSidebar">
                <h5><i class="fas fa-project-diagram"></i> Workflow</h5>
                <div id="workflowStatus" class="small text-muted mb-3">Noch kein Upload.</div>

                <h5><i class="fas fa-upload"></i> CSV / Workflow</h5>
        <div class="mb-2">
            <label for="csvFile" class="form-label">CSV-Datei ausw√§hlen:</label>
            <input type="file" id="csvFile" class="form-control" accept=".csv,text/csv" onchange="handleFileChange()">
            
            <!-- Upload Status -->
            <div id="uploadInfo" class="small text-muted mt-2"></div>
        </div>
                <button class="btn btn-success w-100" onclick="runWorkflow()">
                    <i class="fas fa-cogs"></i> Kompletter Workflow (Parse + Geocode + Optimize)
                </button>

                <!-- Stats-Box (read-only) mit Toggle -->
                <div id="stats-box" class="card mb-3" style="display: none;">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0"><i class="fas fa-chart-bar"></i> Statistik</h6>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="stats-toggle" checked onchange="toggleStatsBox()">
                            <label class="form-check-label" for="stats-toggle" style="font-size: 0.85em; cursor: pointer;">
                                <span id="stats-toggle-label">An</span>
                            </label>
                        </div>
                    </div>
                    <div class="card-body" id="stats-content" style="font-size: 0.9em;">
                        <div class="row mb-2">
                            <div class="col-8"><span>Touren (Monat):</span></div>
                            <div class="col-4 text-end"><b id="stat-tours-month">‚Äì</b></div>
                        </div>
                        <div class="row mb-2">
                            <div class="col-8"><span>Stops √ò pro Tour:</span></div>
                            <div class="col-4 text-end"><b id="stat-stops-avg">‚Äì</b></div>
                        </div>
                        <div class="row">
                            <div class="col-8"><span>KM (OSRM):</span></div>
                            <div class="col-4 text-end"><b id="stat-km-osrm">‚Äì</b></div>
                        </div>
                    </div>
                </div>
                
                <h5 class="mt-3"><i class="fas fa-robot"></i> KI-Status</h5>
                <div id="aiStatusField" class="alert alert-info mb-3" style="font-size: 0.9em;">
                    <i class="fas fa-info-circle"></i> <span id="aiStatusText">Bereit f√ºr Optimierung</span>
                </div>
                
                
                <h5 class="mt-3"><i class="fas fa-route"></i> Sub-Routen Generator</h5>
                <button class="btn btn-success w-100 mb-2" id="btnGenerateSubRoutes" onclick="generateSubRoutes()" style="display: none;">
                    <i class="fas fa-magic"></i> Routen optimieren (W-Touren & >4 Kunden)
                </button>
                <div id="subRouteStatus" class="small text-muted mb-3" style="display: none;"></div>
                <div id="subRouteProgress" class="mb-3" style="display: none;">
                    <div class="progress" style="height: 25px;">
                        <div id="subRouteProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" style="width: 0%" 
                             aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                            <span id="subRouteProgressText">0%</span>
                        </div>
                    </div>
                    <div id="subRouteProgressDetails" class="small text-muted mt-1 text-center"></div>
                </div>
            </div>
            </div>
            
            <!-- Optimization Modal -->
            <div class="modal fade" id="optimizationModal" tabindex="-1" aria-labelledby="optimizationModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="optimizationModalLabel">Tour-Optimierung</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schlie√üen</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9">
                <div class="card mb-3">
                    <div class="card-header">
                        <h4><i class="fas a-map"></i> Karte</h4>
                    </div>
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div>
                                <h4 class="mb-2"><i class="fas fa-list"></i> Tour-√úbersicht</h4>
                                <button class="btn btn-lg btn-outline-danger" id="clearAllBtn" onclick="clearAllTours()" style="display: none;">
                                    <i class="fas fa-trash"></i> Clear
                                </button>
                            </div>
                            <div class="text-end align-self-center">
                                <div class="small text-muted" id="tourSummary">Keine Daten</div>
                            </div>
                        </div>
                    </div>
                    <div class="card-body tour-card-layout">
                        <div class="tour-list-column">
                            <div id="tourList" class="list-group list-group-flush"></div>
                        </div>
                        <div class="tour-details-column">
                            <div id="tourDetails" class="border rounded p-3 bg-light h-100">
                                <div class="text-center text-muted py-4">
                                    <i class="fas fa-info-circle"></i><br>
                                    Noch keine Tourdaten. CSV hochladen oder Workflow starten.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mapbox/polyline@1.0.1/polyline.js"></script>
    <script type="module" src="/static/js/polyline6.js"></script>
    <script type="module" src="/static/js/panel-ipc.js"></script>
    <script>
        let map;
        let parsedData = null;
        let workflowResult = null;
        let activeTourKey = null;
        let allTourCustomers = {};
        let tourMarkers = [];
        let tourRouteLines = [];  // WICHTIG: F√ºr OSRM-Routen-Linien auf der Karte
        let currentFilename = null;
        let geoCache = {};
        
        // Panel-Fenster-Management
        let mapPanelWindow = null;
        let toursPanelWindow = null;

        // State-Management: Speichere Touren in localStorage
        function saveToursToStorage() {
            try {
                if (workflowResult) {
                    localStorage.setItem('workflowResult', JSON.stringify(workflowResult));
                }
                if (Object.keys(allTourCustomers).length > 0) {
                    localStorage.setItem('allTourCustomers', JSON.stringify(allTourCustomers));
                }
                if (activeTourKey) {
                    localStorage.setItem('activeTourKey', activeTourKey);
                }
                if (currentFilename) {
                    localStorage.setItem('currentFilename', currentFilename);
                }
            } catch (e) {
                console.error('Fehler beim Speichern:', e);
            }
        }
        
        // State-Management: Lade Touren aus localStorage
        function restoreToursFromStorage() {
            try {
                const savedWorkflow = localStorage.getItem('workflowResult');
                const savedCustomers = localStorage.getItem('allTourCustomers');
                const savedTourKey = localStorage.getItem('activeTourKey');
                const savedFilename = localStorage.getItem('currentFilename');
                
                if (savedWorkflow) {
                    workflowResult = JSON.parse(savedWorkflow);
                    console.log('Workflow-Ergebnisse wiederhergestellt:', workflowResult);
                }
                
                if (savedCustomers) {
                    allTourCustomers = JSON.parse(savedCustomers);
                    console.log('Tour-Kunden wiederhergestellt:', Object.keys(allTourCustomers).length, 'Touren');
                    
                    // Rendere Touren neu
                    if (workflowResult && workflowResult.tours && workflowResult.tours.length > 0) {
                        renderToursFromMatch(workflowResult);
                        // Sub-Routen Button aktualisieren nach dem Rendern
                        updateSubRouteButtonVisibility();
                    } else if (Object.keys(allTourCustomers).length > 0) {
                        // Rendere aus allTourCustomers
                        renderToursFromCustomers();
                        // WICHTIG: Button auch hier aktualisieren!
                        updateSubRouteButtonVisibility();
                    }
                    
                }
                
                if (savedTourKey && allTourCustomers[savedTourKey]) {
                    setTimeout(() => {
                        selectTour(savedTourKey);
                    }, 100);
                }
                
                if (savedFilename) {
                    currentFilename = savedFilename;
                    const uploadInfo = document.getElementById('uploadInfo');
                    if (uploadInfo) {
                        uploadInfo.innerHTML = `<i class="fas fa-check text-success"></i> Datei wiederhergestellt: ${savedFilename}`;
                    }
                }
                
                // Clear-Button anzeigen wenn Daten vorhanden
                updateClearButtonVisibility();
                
            } catch (e) {
                console.error('Fehler beim Wiederherstellen:', e);
            }
        }
        
        // Hilfsfunktion: Rendere Touren aus allTourCustomers
        function renderToursFromCustomers() {
            const tourList = document.getElementById('tourList');
            const tours = Object.values(allTourCustomers);
            
            if (tours.length === 0) {
                renderEmptyTours();
                updateSubRouteButtonVisibility();
                return;
            }
            
            let totalCustomers = 0;
            let totalWarnings = 0;
            let totalBad = 0;
            
            tours.forEach(tour => {
                totalCustomers += tour.customers ? tour.customers.length : 0;
                if (tour.customers) {
                    tour.customers.forEach(c => {
                        if (c.warning) totalWarnings++;
                        if (c.status === 'bad') totalBad++;
                    });
                }
            });
            
            document.getElementById('tourSummary').textContent = 
                `${tours.length} Touren ¬∑ ${totalCustomers} Adressen ¬∑ ${totalWarnings} Warnungen ¬∑ ${totalBad} Bad`;
            
            tourList.innerHTML = tours.map((tour, index) => {
                const key = `restored-${index}`;
                const customerCount = tour.customers ? tour.customers.length : 0;
                const barBadge = tour.isBarTour ? '<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>' : '';
                
                return `
                    <button class="list-group-item list-group-item-action position-relative" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${tour.name || `Tour ${index + 1}`}</strong>${barBadge}
                                <div class="small text-muted">${customerCount} Kunden</div>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge bg-primary rounded-pill">${customerCount}</span>
                                <button class="btn btn-sm btn-link p-0 text-secondary optimize-tour-btn" 
                                        data-tour-key="${key}" 
                                        data-tour-name="${tour.name || `Tour ${index + 1}`}"
                                        data-stop-count="${customerCount}"
                                        title="Tour mit AI optimieren"
                                        onclick="event.stopPropagation(); optimizeTour('${key}', '${tour.name || `Tour ${index + 1}`}');">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </button>
                `;
            }).join('');
            
            bindTourListEvents();
            
            // WICHTIG: Button-Sichtbarkeit nach dem Rendern aktualisieren!
            updateSubRouteButtonVisibility();
        }
        
        // Clear-Button: Alle Daten l√∂schen
        function clearAllTours() {
            if (!confirm('M√∂chten Sie wirklich alle Touren und Daten l√∂schen?')) {
                return;
            }
            
            // Variablen zur√ºcksetzen
            workflowResult = null;
            allTourCustomers = {};
            activeTourKey = null;
            currentFilename = null;
            
            // localStorage leeren
            localStorage.removeItem('workflowResult');
            localStorage.removeItem('allTourCustomers');
            localStorage.removeItem('activeTourKey');
            localStorage.removeItem('currentFilename');
            localStorage.removeItem('optimizedTours');
            
            // UI zur√ºcksetzen
            renderEmptyTours();
            const workflowStatus = document.getElementById('workflowStatus');
            if (workflowStatus) {
                workflowStatus.innerHTML = 'Noch kein Upload.';
            }
            const uploadInfo = document.getElementById('uploadInfo');
            if (uploadInfo) {
                uploadInfo.innerHTML = '';
            }
            const csvFile = document.getElementById('csvFile');
            if (csvFile) {
                csvFile.value = '';
            }
            
            // KI-Status zur√ºcksetzen
            updateAIStatus('Bereit f√ºr Optimierung', 'info');
            
            // Clear-Button verstecken
            updateClearButtonVisibility();
        }
        
        // Clear-Button Sichtbarkeit aktualisieren
        function updateClearButtonVisibility() {
            const clearBtn = document.getElementById('clearAllBtn');
            if (!clearBtn) return;
            
            const hasData = (workflowResult && workflowResult.tours && workflowResult.tours.length > 0) || 
                           Object.keys(allTourCustomers).length > 0;
            clearBtn.style.display = hasData ? 'block' : 'none';
        }

        // Initialisierung
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM geladen, starte...');
            initializeMap();
            loadStatusData();
            restoreToursFromStorage();
            
            // Button-Sichtbarkeit nach dem Laden pr√ºfen
            setTimeout(() => {
                updateSubRouteButtonVisibility();
            }, 500);
        });
        
        // State-Management: Beim Verlassen der Seite speichern
        window.addEventListener('beforeunload', function() {
            saveToursToStorage();
        });

        // Karte initialisieren
        function initializeMap() {
            console.log('Initialisiere Karte...');
            
            if (typeof L === 'undefined') {
                console.error('Leaflet nicht geladen!');
                return;
            }
            
            try {
                // Karte auf FAMO Standort zentrieren (Gittersee)
                map = L.map('map').setView([51.01127, 13.70161], 15);
                console.log('Karte erstellt');
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
                
                // FAMO Dresden Marker - Haupt-Depot in kr√§ftigem Lila mit Warehouse-Symbol
                const depotMarker = L.marker([51.01127, 13.70161], {
                    icon: L.divIcon({
                        className: 'custom-depot-marker',
                        html: `
                            <div style="
                                background-color: #9C27B0;
                                border: 3px solid #7B1FA2;
                                border-radius: 8px;
                                width: 45px;
                                height: 45px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                box-shadow: 0 3px 10px rgba(0,0,0,0.3);
                                transform: rotate(-45deg);
                            ">
                                <i class="fas fa-warehouse" style="
                                    color: white;
                                    font-size: 24px;
                                    transform: rotate(45deg);
                                    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
                                "></i>
                            </div>
                            <div style="
                                position: absolute;
                                bottom: -8px;
                                left: 50%;
                                transform: translateX(-50%);
                                width: 0;
                                height: 0;
                                border-left: 10px solid transparent;
                                border-right: 10px solid transparent;
                                border-top: 12px solid #7B1FA2;
                            "></div>
                        `,
                        iconSize: [45, 45],
                        iconAnchor: [22, 45],
                        popupAnchor: [0, -45]
                    })
                }).addTo(map);
                depotMarker.bindPopup(`
                    <div style="text-align: center;">
                        <b style="color: #9C27B0; font-size: 1.2em;">üè≠ FAMO Dresden</b><br>
                        <strong style="color: #7B1FA2; font-size: 1.1em;">HAUPT-DEPOT</strong><br>
                        <hr style="margin: 8px 0;">
                        <i class="fas fa-map-marker-alt"></i> Stuttgarter Str. 33<br>
                        01189 Dresden<br>
                        <small><i class="fas fa-industry"></i> Industriegebiet Gittersee</small>
                    </div>
                `);
                depotMarker.openPopup();
                
                console.log('Karte erfolgreich initialisiert!');
            } catch (error) {
                console.error('Fehler beim Initialisieren der Karte:', error);
            }
        }

        function updateWorkflowStatus(message) {
            document.getElementById('workflowStatus').innerHTML = message;
        }

        window.handleFileChange = function() {
            const input = document.getElementById('csvFile');
            const status = document.getElementById('workflowStatus');
            const uploadInfo = document.getElementById('uploadInfo');
            
            if (!input.files || !input.files.length) {
                currentFilename = null;
                status.innerHTML = 'Noch kein Upload.';
                status.className = 'small text-muted mb-3';
                uploadInfo.innerHTML = '';
                return;
            }
            
            const file = input.files[0];
            currentFilename = file.name;
            
            // Upload √ºber neue API
            uploadCsvFile(file);
        }

        // Neue Upload-API Funktionen
        // State: Pfad nach Upload merken
        let LAST_UPLOAD_PATH = null;

        async function apiUploadCsv(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch('/api/upload/csv', {
                method: 'POST',
                body: formData
            });
            
            // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
            const responseText = await response.text();
            
            if (!response.ok) {
                throw new Error(`Upload fehlgeschlagen: ${response.status} ${responseText}`);
            }
            
            let payload;
            try {
                payload = JSON.parse(responseText);
            } catch (e) {
                console.error('[UPLOAD] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
            }
            
            // WICHTIG: stored_path merken (vereinheitlichtes Feld) - aber nicht hier werfen, 
            // sondern in uploadCsvFile pr√ºfen (kompatibler mit Backup-Version)
            LAST_UPLOAD_PATH = payload.stored_path || payload.staged_path || payload.staging_file || payload.file_path || null;
            
            return payload;
        }

        async function uploadCsvFile(file) {
            const uploadInfo = document.getElementById('uploadInfo');
            const status = document.getElementById('workflowStatus');
            
            // Upload-Status anzeigen
            uploadInfo.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Lade hoch: ${file.name} (${(file.size/1024).toFixed(1)} KB)`;
            uploadInfo.className = 'small text-info mt-2';
            
            try {
                // Upload √ºber API
                const result = await apiUploadCsv(file);
                
                // Erfolg anzeigen - verwende direkte Extraktion wie im Backup (kompatibler)
                const stagedPath = result.stored_path || result.staged_path || result.staging_file || result.filename || null;
                
                // Debug: Logge die Antwort-Struktur
                console.log('[UPLOAD] Upload-Response:', result);
                console.log('[UPLOAD] stagedPath:', stagedPath);
                
                // Aktualisiere LAST_UPLOAD_PATH f√ºr sp√§tere Verwendung
                LAST_UPLOAD_PATH = stagedPath;
                
                if (stagedPath && stagedPath !== 'undefined' && stagedPath !== 'null' && typeof stagedPath === 'string' && stagedPath.trim() !== '') {
                    // Zeige nur Dateiname, nicht den ganzen Pfad (f√ºr bessere Lesbarkeit)
                    const fileName = stagedPath.split(/[/\\]/).pop() || stagedPath;
                    uploadInfo.innerHTML = `<i class="fas fa-check text-success"></i> Upload erfolgreich: ${fileName}`;
                    uploadInfo.className = 'small text-success mt-2';
                    
                    // Workflow-Status aktualisieren
                    status.innerHTML = `<span class="text-success">‚úì Datei hochgeladen: ${file.name}</span>`;
                    status.className = 'small text-success mb-3';
                    
                    // Automatisch Match starten (nur wenn staged_path vorhanden)
                    await loadMatchForFile(stagedPath);
                } else {
                    console.warn('[UPLOAD] Kein g√ºltiger Pfad gefunden in Response:', result);
                    uploadInfo.innerHTML = `<i class="fas fa-check text-success"></i> Upload erfolgreich: ${file.name}`;
                    uploadInfo.className = 'small text-success mt-2';
                    updateWorkflowStatus('‚ö† Upload erfolgreich, aber Match konnte nicht gestartet werden (kein g√ºltiger Pfad in Response)');
                }
                
            } catch (error) {
                console.error('Upload-Fehler:', error);
                uploadInfo.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> Fehler: ${error.message}`;
                uploadInfo.className = 'small text-danger mt-2';
                
                status.innerHTML = `<span class="text-danger">‚úó Upload fehlgeschlagen: ${error.message}</span>`;
                status.className = 'small text-danger mb-3';
            }
        }

        async function loadMatchForFile(filePath) {
            // Pr√ºfe ob filePath vorhanden ist (fr√ºhe Validierung)
            if (!filePath || filePath === 'undefined' || filePath === 'null' || filePath === undefined || typeof filePath !== 'string' || filePath.trim() === '') {
                console.warn('[MATCH] Kein g√ºltiger Dateipfad angegeben, √ºberspringe Match', {filePath});
                updateWorkflowStatus('‚ö† Match √ºbersprungen: Kein g√ºltiger Dateipfad');
                return;
            }
            
            // Fallback: Verwende LAST_UPLOAD_PATH wenn filePath fehlt
            const pathToUse = filePath || LAST_UPLOAD_PATH;
            if (!pathToUse) {
                uiError('Keine hochgeladene Datei im Kontext. Erst CSV hochladen.');
                return;
            }
            
            try {
                // GET-Variante (bestehend)
                const url = '/api/tourplan/match?file=' + encodeURIComponent(pathToUse);
                const response = await fetch(url);
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (!response.ok) {
                    throw new Error(`Match fehlgeschlagen: ${response.status} ${responseText}`);
                }
                
                let matchData;
                try {
                    matchData = JSON.parse(responseText);
                } catch (e) {
                    console.error('[MATCH] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                    throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                }
                
                // Match-Daten verarbeiten (bestehende Logik)
                if (matchData.items && matchData.items.length > 0) {
                    updateWorkflowStatus(`‚úì Match erfolgreich: ${matchData.items.length} Adressen verarbeitet`);
                    console.log('Match-Daten:', matchData);
                    
                    // WICHTIG: Rendere Match-Daten in Tour√ºbersicht
                    renderToursFromMatch(matchData);
                } else {
                    updateWorkflowStatus('‚ö† Match: Keine Adressen gefunden');
                }
                
            } catch (error) {
                console.error('Match-Fehler:', error);
                updateWorkflowStatus(`‚úó Match fehlgeschlagen: ${error.message}`);
            }
        }
        
        // Hilfsfunktion f√ºr UI-Fehler
        function uiError(msg) {
            console.error(msg);
            alert(msg);
        }


        // Live-Geocoding-Progress anzeigen
        let geocodingProgressInterval = null;
        
        function startGeocodingProgress(sessionId) {
            const progressDiv = document.getElementById('geocodingProgress');
            if (!progressDiv) {
                // Progress-Div erstellen falls nicht vorhanden
                const statusDiv = document.getElementById('workflowStatus');
                const newDiv = document.createElement('div');
                newDiv.id = 'geocodingProgress';
                newDiv.className = 'alert alert-info mt-2';
                newDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span id="progressText">Lade...</span>';
                statusDiv.after(newDiv);
            }
            
            // Polling alle 500ms
            geocodingProgressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/api/workflow/geocoding-progress/${sessionId}`);
                    const progress = await response.json();
                    
                    const progressDiv = document.getElementById('geocodingProgress');
                    const progressText = document.getElementById('progressText');
                    
                    if (!progress || progress.status === 'completed' || progress.status === 'idle') {
                        if (geocodingProgressInterval) {
                            clearInterval(geocodingProgressInterval);
                            geocodingProgressInterval = null;
                        }
                        if (progressDiv && progress.status === 'completed') {
                            progressDiv.className = 'alert alert-success mt-2';
                            progressDiv.innerHTML = `<i class="fas fa-check-circle"></i> Geocoding abgeschlossen! ${progress.processed}/${progress.total} verarbeitet (${progress.db_hits || 0} DB, ${progress.geoapify_calls || 0} Geoapify)`;
                            setTimeout(() => {
                                if (progressDiv) {
                                    progressDiv.style.display = 'none';
                                    progressDiv.className = '';
                                    progressDiv.innerHTML = '';
                                }
                            }, 3000);
                        } else if (progressDiv && (progress.status === 'idle' || !progress)) {
                            // Session nicht mehr aktiv oder Progress beendet - verstecken
                            progressDiv.style.display = 'none';
                            progressDiv.className = '';
                            progressDiv.innerHTML = '';
                        }
                        return;
                    }
                    
                    const percentage = progress.total > 0 ? Math.round((progress.processed / progress.total) * 100) : 0;
                    const stats = `DB: ${progress.db_hits || 0} | Geoapify: ${progress.geoapify_calls || 0} | Fehler: ${progress.errors || 0}`;
                    
                    if (progressText) {
                        progressText.innerHTML = `
                            <strong>${progress.current || 'Verarbeite...'}</strong><br>
                            <small>${progress.processed}/${progress.total} (${percentage}%) | ${stats}</small>
                        `;
                    }
                    
                    // Progress-Bar aktualisieren
                    let progressBar = document.getElementById('geocodingProgressBar');
                    if (!progressBar) {
                        progressBar = document.createElement('div');
                        progressBar.id = 'geocodingProgressBar';
                        progressBar.className = 'progress mt-2';
                        progressBar.style.height = '20px';
                        progressBar.innerHTML = '<div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>';
                        progressDiv.appendChild(progressBar);
                    }
                    const bar = progressBar.querySelector('.progress-bar');
                    if (bar) {
                        bar.style.width = `${percentage}%`;
                        bar.textContent = `${percentage}%`;
                    }
                    
                } catch (error) {
                    console.error('Progress-Fehler:', error);
                }
            }, 500); // Alle 500ms aktualisieren
        }
        
        function stopGeocodingProgress() {
            if (geocodingProgressInterval) {
                clearInterval(geocodingProgressInterval);
                geocodingProgressInterval = null;
            }
            // Verstecke und entferne das Progress-Element
            const progressDiv = document.getElementById('geocodingProgress');
            if (progressDiv) {
                progressDiv.style.display = 'none';
                progressDiv.className = '';
                progressDiv.innerHTML = '';
            }
        }

        // Daten aktualisieren
        window.runWorkflow = async function() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Bitte w√§hlen Sie eine CSV-Datei aus.');
                return;
            }

            try {
                updateWorkflowStatus('<span class="text-info">Workflow wird ausgef√ºhrt...</span>');
                
                // Progress-Div anzeigen
                const statusDiv = document.getElementById('workflowStatus');
                let progressDiv = document.getElementById('geocodingProgress');
                if (!progressDiv) {
                    progressDiv = document.createElement('div');
                    progressDiv.id = 'geocodingProgress';
                    progressDiv.className = 'alert alert-info mt-2';
                    progressDiv.style.display = 'block';
                    progressDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span id="progressText">Starte Geocoding...</span>';
                    statusDiv.after(progressDiv);
                } else {
                    progressDiv.style.display = 'block';
                    progressDiv.className = 'alert alert-info mt-2';
                }

                // Verwende den korrekten Workflow-Endpoint
                const formData = new FormData();
                formData.append('file', file);

                // Starte Progress-Polling VOR dem Upload (l√§uft parallel)
                // Die session_id wird im Backend generiert, wir pollen einfach eine generische Session
                // ODER: Wir warten auf die erste Response und starten dann
                
                const response = await fetch('/api/workflow/upload', {
                    method: 'POST',
                    body: formData
                });

                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error("JSON Parsing Fehler:", e, "Rohe Antwort:", responseText);
                    updateWorkflowStatus(`<span class="text-danger">Workflow fehlgeschlagen: Ung√ºltige Server-Antwort (${response.status}). Details: ${responseText.substring(0, 100)}...</span>`);
                    stopGeocodingProgress();
                    return; 
                }

                // Debug: Logge die Antwort-Struktur
                console.log('[WORKFLOW] Backend-Response:', data);
                console.log('[WORKFLOW] Touren gefunden:', data.tours?.length || 0);
                console.log('[WORKFLOW] Erste Tour:', data.tours?.[0]);
                
                // Live-Progress starten falls session_id vorhanden
                // (Auch wenn Upload bereits fertig ist, zeigt es finale Stats)
                if (data.geocoding_session_id && data.counts) {
                    // Nur starten wenn noch nicht alle verarbeitet sind
                    const totalToProcess = (data.counts.ok || 0) + (data.counts.warn || 0) + (data.counts.bad || 0);
                    if (totalToProcess > 0) {
                        console.log('[WORKFLOW] Starte Live-Progress f√ºr Session:', data.geocoding_session_id);
                        startGeocodingProgress(data.geocoding_session_id);
                    } else {
                        // Workflow bereits vollst√§ndig abgeschlossen - kein Progress n√∂tig
                        stopGeocodingProgress();
                    }
                } else {
                    // Keine Session-ID oder bereits abgeschlossen - Progress stoppen
                    stopGeocodingProgress();
                }
                
                if (response.ok && data.tours && data.tours.length > 0) {
                    // Workflow erfolgreich - Progress definitiv stoppen und UI zur√ºcksetzen
                    setTimeout(() => {
                        stopGeocodingProgress();
                    }, 2000); // Kurz warten falls noch finales Update kommt
                    
                    // WICHTIG: Erstelle Deep-Copy der Touren, damit sp√§tere √Ñnderungen nicht die Original-Daten beeintr√§chtigen
                    const toursCopy = JSON.parse(JSON.stringify(data.tours));
                    
                    workflowResult = { 
                        items: [], 
                        tours: toursCopy,  // Verwende Kopie
                        ok: data.counts?.ok || data.ok || 0, 
                        warn: data.counts?.warn || data.warn || 0, 
                        bad: data.counts?.bad || data.bad || 0 
                    };
                    parsedData = null;
                    
                    console.log('[WORKFLOW] Rendere Touren:', workflowResult.tours.length);
                    
                    // Geocoding-Stats anzeigen
                    if (data.geocoding_stats) {
                        const stats = data.geocoding_stats;
                        console.log(`[GEOCODE STATS] DB-Hits: ${stats.db_hits}, Geoapify-Calls: ${stats.geoapify_calls}, Fehler: ${stats.errors}`);
                    }
                    
                    // Erste Renderung mit originalen Daten
                    renderToursFromMatch(workflowResult);
                    
                    // KI-Status aktualisieren
                    updateAIStatus(`Workflow erfolgreich: ${data.tours.length} Touren geladen`, 'info');
                    
                    // WICHTIG: Automatische Optimierung ist DEAKTIVIERT
                    // Die Optimierung erfolgt nur manuell √ºber den Button "Routen optimieren"
                    // await autoOptimizeLargeTours(workflowResult.tours);  // DEAKTIVIERT
                    
                    // Sub-Routen Generator Button anzeigen wenn W-Touren vorhanden
                    updateSubRouteButtonVisibility();
                    
                    // Optimierte Touren im localStorage speichern f√ºr Tour-Management-Seite
                    // WICHTIG: Verwende workflowResult.tours (enth√§lt bereits optimierte Touren)
                    localStorage.setItem('optimizedTours', JSON.stringify({
                        tours: workflowResult.tours,  // Aktualisierte Touren (inkl. Optimierungen)
                        filename: file.name,
                        timestamp: new Date().toISOString(),
                        counts: {
                            ok: data.counts?.ok || data.ok || 0,
                            warn: data.counts?.warn || data.warn || 0,
                            bad: data.counts?.bad || data.bad || 0
                        }
                    }));
                    console.log('[WORKFLOW] Optimierte Touren im localStorage gespeichert f√ºr Tour-Management');
                    
                    // Speichere State f√ºr Wiederherstellung (nach Optimierung)
                    saveToursToStorage();
                    
                    // Clear-Button anzeigen
                    updateClearButtonVisibility();
                    
                    const consolidatedInfo = data.tours_consolidated 
                        ? ` (${data.tours_before_consolidation - data.tour_count} T-Touren zusammengelegt)`
                        : '';
                    
                    updateWorkflowStatus(`<span class="text-success">Workflow erfolgreich. ${data.counts?.ok || data.ok || 0} OK, ${data.counts?.warn || data.warn || 0} Warn, ${data.counts?.bad || data.bad || 0} Bad - ${workflowResult.tours.length} Touren generiert${consolidatedInfo}</span>`);
                } else if (response.ok) {
                    stopGeocodingProgress();
                    // Keine Touren gefunden - zeige detaillierte Fehler
                    let errorMsg = 'Keine Touren gefunden';
                    if (data.errors && data.errors.length > 0) {
                        errorMsg = data.errors[0];
                    } else if (data.detail) {
                        errorMsg = data.detail;
                    } else if (data.error) {
                        errorMsg = data.error;
                    }
                    
                    // Zeige auch Warnings falls vorhanden
                    if (data.warnings && data.warnings.length > 0) {
                        errorMsg += ` (${data.warnings.length} Warnungen)`;
                    }
                    
                    updateWorkflowStatus(`<span class="text-warning">Workflow abgeschlossen, aber keine Touren gefunden: ${errorMsg}</span>`);
                    console.error('Workflow Details:', data);
                } else {
                    updateWorkflowStatus(`<span class="text-danger">Workflow fehlgeschlagen: ${data.detail || data.error || 'HTTP ' + response.status}</span>`);
                }
            } catch (error) {
                console.error('Workflow Fehler:', error);
                stopGeocodingProgress();
                updateWorkflowStatus(`<span class="text-danger">Workflow Fehler: ${error.message}. Details in der Konsole.</span>`);
            }
        }

        // Stats-Box Toggle-Funktion
        function toggleStatsBox() {
            const toggle = document.getElementById('stats-toggle');
            const statsBox = document.getElementById('stats-box');
            const statsContent = document.getElementById('stats-content');
            const toggleLabel = document.getElementById('stats-toggle-label');
            
            if (!toggle || !statsBox) return;
            
            const isEnabled = toggle.checked;
            
            // Speichere Einstellung in localStorage
            localStorage.setItem('stats-box-enabled', isEnabled ? 'true' : 'false');
            
            if (isEnabled) {
                // An: Zeige Box und lade Daten
                statsBox.style.display = 'block';
                if (statsContent) {
                    statsContent.style.opacity = '1';
                    statsContent.style.filter = 'none';
                }
                toggleLabel.textContent = 'An';
                toggleLabel.style.color = '';
                loadStatsBox();
            } else {
                // Aus: Verstecke Inhalt (Box bleibt sichtbar, aber grau)
                if (statsContent) {
                    statsContent.style.opacity = '0.4';
                    statsContent.style.filter = 'grayscale(100%)';
                }
                toggleLabel.textContent = 'Aus';
                toggleLabel.style.color = '#6c757d';
            }
        }
        
        // Lade Toggle-Status beim Start
        function initStatsToggle() {
            const toggle = document.getElementById('stats-toggle');
            const savedState = localStorage.getItem('stats-box-enabled');
            
            if (toggle) {
                // Standard: An (wenn nicht gespeichert)
                toggle.checked = savedState !== 'false';
                toggleStatsBox();
            }
        }

        // Stats-Box laden
        async function loadStatsBox() {
            // Pr√ºfe ob Toggle aktiviert ist
            const toggle = document.getElementById('stats-toggle');
            const statsBox = document.getElementById('stats-box');
            
            if (toggle && !toggle.checked) {
                // Toggle aus: Box verstecken
                if (statsBox) {
                    statsBox.style.display = 'none';
                }
                return; // Nicht laden wenn ausgeschaltet
            }
            
            // Toggle an: Box anzeigen
            if (statsBox) {
                statsBox.style.display = 'block';
            }
            
            try {
                const response = await fetch('/api/stats/overview');
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (!response.ok) {
                    // Bei Fehler: Zeige Fehlermeldung in der Box
                    const statsContent = document.getElementById('stats-content');
                    if (statsContent) {
                        let errorData = { error: 'Unbekannter Fehler' };
                        try {
                            errorData = JSON.parse(responseText);
                        } catch (e) {
                            // Fallback wenn kein JSON
                            errorData = { error: responseText.substring(0, 100) || 'Unbekannter Fehler' };
                        }
                        statsContent.innerHTML = `
                            <div class="alert alert-warning mb-0" style="font-size: 0.85em;">
                                <i class="fas fa-exclamation-triangle"></i> 
                                <strong>Fehler:</strong> ${errorData.error || 'Stats-Aggregation fehlgeschlagen'}<br>
                                <small>${errorData.detail || 'Bitte Server-Logs pr√ºfen'}</small>
                            </div>
                        `;
                    }
                    console.error('[STATS] Stats-API Fehler:', response.status, errorData);
                    return;
                }
                
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error('[STATS] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                    throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                }
                
                // Pr√ºfe ob Fehler in Response (sollte nicht vorkommen bei 200, aber sicherheitshalber)
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Stelle normale Stats-Anzeige wieder her (falls sie durch Fehler √ºberschrieben wurde)
                const statsContent = document.getElementById('stats-content');
                if (statsContent && !statsContent.querySelector('.row')) {
                    statsContent.innerHTML = `
                        <div class="row mb-2">
                            <div class="col-8"><span>Touren (Monat):</span></div>
                            <div class="col-4 text-end"><b id="stat-tours-month">‚Äì</b></div>
                        </div>
                        <div class="row mb-2">
                            <div class="col-8"><span>Stops √ò pro Tour:</span></div>
                            <div class="col-4 text-end"><b id="stat-stops-avg">‚Äì</b></div>
                        </div>
                        <div class="row">
                            <div class="col-8"><span>KM (OSRM):</span></div>
                            <div class="col-4 text-end"><b id="stat-km-osrm">‚Äì</b></div>
                        </div>
                    `;
                }
                
                // F√ºlle Daten ein
                const toursEl = document.querySelector('#stat-tours-month');
                const stopsEl = document.querySelector('#stat-stops-avg');
                const kmEl = document.querySelector('#stat-km-osrm');
                
                if (toursEl) toursEl.textContent = data.monthly_tours ?? '0';
                if (stopsEl) stopsEl.textContent = data.avg_stops?.toFixed(1) ?? '0';
                if (kmEl) kmEl.textContent = data.km_osrm_month?.toFixed(1) ?? '0';
                
                // Box anzeigen (sollte bereits angezeigt sein, aber sicherheitshalber)
                if (statsBox && toggle && toggle.checked) {
                    statsBox.style.display = 'block';
                }
            } catch (e) {
                // Bei unerwarteten Fehlern: Zeige Fehlermeldung
                const statsContent = document.getElementById('stats-content');
                if (statsContent) {
                    statsContent.innerHTML = `
                        <div class="alert alert-danger mb-0" style="font-size: 0.85em;">
                            <i class="fas fa-times-circle"></i> 
                            <strong>Fehler:</strong> ${e.message || 'Unbekannter Fehler beim Laden der Statistiken'}
                        </div>
                    `;
                }
                console.error('[STATS] Fehler beim Laden der Stats:', e);
            }
        }

        // Status-Daten laden (OSRM + LLM + DB)
        async function loadStatusData() {
            try {
                // Stats-Toggle initialisieren
                initStatsToggle();
                // Stats-Box laden (wenn aktiviert)
                await loadStatsBox();
                
                // OSRM-Status abfragen
                try {
                    const osrmResponse = await fetch('/health/osrm');
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const osrmResponseText = await osrmResponse.text();
                    let osrmData = {};
                    try {
                        osrmData = JSON.parse(osrmResponseText);
                    } catch (e) {
                        console.error('[STATUS] OSRM-Response JSON Parsing Fehler:', e);
                    }
                    
                    if (osrmResponse.ok) {
                        updateOSRMStatus({
                            available: osrmData.status === 'ok',
                            message: osrmData.message || 'OSRM erreichbar',
                            url: osrmData.url || 'unknown'
                        });
                    } else {
                        updateOSRMStatus({
                            available: false,
                            message: osrmData.message || 'OSRM nicht erreichbar',
                            url: osrmData.url || 'unknown'
                        });
                    }
                } catch (e) {
                    updateOSRMStatus({
                        available: false,
                        message: 'OSRM-Pr√ºfung fehlgeschlagen',
                        url: 'unknown'
                    });
                }
                
                // LLM-Status abfragen
                try {
                    const llmResponse = await fetch('/api/workflow/status');
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const llmResponseText = await llmResponse.text();
                    let llmData = {};
                    try {
                        llmData = JSON.parse(llmResponseText);
                    } catch (e) {
                        console.error('[STATUS] LLM-Response JSON Parsing Fehler:', e);
                    }
                    
                    if (llmResponse.ok) {
                        // LLM ist verf√ºgbar wenn enabled (status kann "enabled" oder "No calls made" sein wenn enabled)
                        const llmAvailable = llmData.llm_status === 'enabled' || (llmData.llm_model && llmData.llm_model !== 'N/A');
                        updateLLMStatus({
                            available: llmAvailable,
                            provider: llmData.llm_model || 'OpenAI'
                        });
                    } else {
                        updateLLMStatus({available: false, provider: 'offline'});
                    }
                } catch (e) {
                    updateLLMStatus({available: false, provider: 'offline'});
                }
                
                // DB-Status abfragen
                const dbResponse = await fetch('/health/db');
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const dbResponseText = await dbResponse.text();
                let dbData;
                try {
                    dbData = JSON.parse(dbResponseText);
                } catch (e) {
                    console.error('[STATUS] DB-Response JSON Parsing Fehler:', e, 'Rohe Antwort:', dbResponseText);
                    dbData = { status: 'offline', error: 'Ung√ºltige Server-Antwort' };
                }
                updateDBStatus(dbData);
            } catch (error) {
                console.error('Fehler beim Laden der Status-Daten:', error);
                updateOSRMStatus({available: false, message: 'Fehler', url: 'unknown'});
                updateLLMStatus({available: false, provider: 'offline'});
                updateDBStatus({status: 'offline', error: error.message});
            }
        }

        // OSRM-Status aktualisieren
        function updateOSRMStatus(data) {
            const osrmStatus = document.getElementById('osrmStatus');
            if (!osrmStatus) return;
            
            if (data.available) {
                osrmStatus.innerHTML = `<i class="fas fa-route text-success"></i> OSRM online`;
                osrmStatus.title = `OSRM: ${data.message} (${data.url})`;
            } else {
                osrmStatus.innerHTML = `<i class="fas fa-route text-danger"></i> OSRM offline`;
                osrmStatus.title = `OSRM: ${data.message} (${data.url})`;
            }
        }

        // LLM-Status aktualisieren
        function updateLLMStatus(data) {
            const llmStatus = document.getElementById('llmStatus');
            if (data.available) {
                llmStatus.innerHTML = `<i class="fas fa-circle text-success"></i> LLM ${data.provider}`;
                } else {
                llmStatus.innerHTML = `<i class="fas fa-circle text-danger"></i> LLM offline`;
            }
        }

        // DB-Status aktualisieren
        function updateDBStatus(data) {
            const dbStatus = document.getElementById('dbStatus');
            if (data.status === 'online') {
                // Tabellen-Liste formatieren (nur Anzahl anzeigen, nicht alle Namen)
                let tablesInfo = '';
                if (data.tables) {
                    if (typeof data.tables === 'string') {
                        const tableList = data.tables.split(', ');
                        tablesInfo = `${tableList.length} Tabellen`;
                    } else if (Array.isArray(data.tables)) {
                        tablesInfo = `${data.tables.length} Tabellen`;
                    } else {
                        tablesInfo = 'online';
                    }
                } else {
                    tablesInfo = 'online';
                }
                dbStatus.innerHTML = `<i class="fas fa-database text-success"></i> DB online (${tablesInfo})`;
            } else {
                dbStatus.innerHTML = `<i class="fas fa-database text-danger"></i> DB offline`;
            }
        }

        // CSV Tour Processor
        async function processAllCSV() {
            try {
                console.log('Starte CSV Tour Processing...');
                
                const response = await fetch('/api/tourplan/bulk-process-all', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (response.ok) {
                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (e) {
                        console.error('[CSV-PROCESS] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                        throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                    }
                    console.log('CSV Tour Processing erfolgreich:', result);
                    alert(`[OK] CSV Tour Processing erfolgreich!\n\n` +
                          `Kunden verarbeitet: ${result.total_customers || 0}\n` +
                          `Eindeutige Kunden: ${result.unique_customers || 0}\n` +
                          `In DB gespeichert: ${result.saved_customers || 0}\n` +
                          `Touren gefunden: ${result.tours_found || 0}\n` +
                          `Touren gespeichert: ${result.saved_tours || 0}\n` +
                          `BAR-Touren: ${result.bar_tours || 0}\n` +
                          `Normale Touren: ${result.normal_tours || 0}\n` +
                          `Geocoding Erfolg: ${result.geocoding_success || 0}\n` +
                          `Geocoding Fehler: ${result.geocoding_failed || 0}\n` +
                          `Geocoding Rate: ${result.geocoding_rate || '0%'}\n` +
                          `Dateien verarbeitet: ${result.files_processed || 0}`);
                    await refreshData();
                } else {
                    // responseText wurde bereits gelesen
                    let errorText = responseText;
                    try {
                        const errorData = JSON.parse(responseText);
                        errorText = errorData.error || errorData.detail || responseText;
                    } catch (e) {
                        // Kein JSON, verwende rohen Text
                    }
                    console.error('Fehler beim CSV Tour Processing:', errorText);
                    alert(`[FEHLER] Fehler beim CSV Tour Processing:\n${errorText}`);
                }
            } catch (error) {
                console.error('Fehler beim CSV Tour Processing:', error);
                alert(`[FEHLER] Fehler beim CSV Tour Processing:\n${error.message}`);
            }
        }

        // Touren-Details laden
        function renderToursFromParsedData() {
            if (!parsedData || !parsedData.tours) {
                renderEmptyTours();
                return;
            }

            // Touren nach Zeit sortieren
            const tours = (parsedData.tours || []).filter(passFilter);
            
            // Sortierung nach Zeit hinzuf√ºgen
            tours.sort((a, b) => {
                const timeA = extractTime(a.time || a.name || '');
                const timeB = extractTime(b.time || b.name || '');
                return timeA - timeB; // Aufsteigende Sortierung
            });

            if (!tours.length) {
                renderEmptyTours();
                return;
            }

            document.getElementById('tourSummary').textContent = `${tours.length} Touren ¬∑ ${parsedData.stats?.total_customers || 0} Kunden`;

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = tours.map((tour, index) => {
                const key = `parsed-${index}`;
                const barCount = tour.customers.filter(c => c.bar_flag).length;
                const badge = barCount ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCount} BAR</span>` : '';
                const normalizedCustomers = tour.customers.map(customer => ({
                    customer_number: customer.customer_number,
                    name: customer.name,
                    street: customer.street,
                    postal_code: customer.postal_code,
                    city: customer.city,
                    bar_flag: customer.bar_flag,
                    latitude: customer.latitude,
                    longitude: customer.longitude,
                    address: customer.resolved_address || customer.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [customer.street, customer.postal_code, customer.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '';
                })()
                }));

                allTourCustomers[key] = {
                    name: tour.name,
                    type: tour.tour_type,
                    time: tour.time,
                    customers: normalizedCustomers
                };
                
                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const cleanTourName = routeLetter ? (tour.name || '').replace(/\s[A-Z]$/, '').trim() : (tour.name || '');
                const stopsText = routeNumber 
                    ? `${tour.customer_count} Kunden ${routeNumber} ¬∑ ${tour.tour_type} ¬∑ ${tour.time || 'Zeit n/a'}`
                    : `${tour.customer_count} Kunden ¬∑ ${tour.tour_type} ¬∑ ${tour.time || 'Zeit n/a'}`;
                
                return `
                    <button class="list-group-item list-group-item-action position-relative" id="tour-${key}" data-tour-key="${key}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${cleanTourName}</strong>${badge}
                                <div class="small text-muted">${stopsText}</div>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge bg-primary rounded-pill">${tour.customer_count}</span>
                                <button class="btn btn-sm btn-link p-0 text-secondary optimize-tour-btn" 
                                        data-tour-key="${key}" 
                                        data-tour-name="${tour.name}"
                                        data-stop-count="${tour.customer_count}"
                                        title="Tour mit AI optimieren"
                                        onclick="event.stopPropagation(); optimizeTour('${key}', '${tour.name}');">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = tours.length ? `parsed-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        // Hilfsfunktion zum Extrahieren der Zeit aus Tour-Namen
        function extractTime(timeString) {
            if (!timeString) return 9999; // Fallback f√ºr Touren ohne Zeit
            
            // Suche nach Zeit-Pattern: HH.MM oder HH:MM
            const timeMatch = timeString.match(/(\d{1,2})[.:](\d{2})/);
            if (timeMatch) {
                const hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                return hours * 60 + minutes; // Minuten seit Mitternacht
            }
            
            return 9999; // Fallback f√ºr unbekannte Formate
        }

        // Rendert Touren basierend auf der urspr√ºnglichen CSV-Struktur
        function renderToursFromCSVStructure(matchData, fileName) {
            console.log('renderToursFromCSVStructure aufgerufen, matchData:', matchData);
            
            const items = matchData.items || [];
            if (!items.length) {
                console.log('Keine Items gefunden in matchData');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${items.length} Items aus CSV-Struktur`);
            document.getElementById('tourSummary').textContent = `${matchData.ok} OK, ${matchData.warn} Warn, ${matchData.bad} Bad`;

            // Gruppiere Items nach Tour-Zeit basierend auf der urspr√ºnglichen CSV-Struktur
            const tours = {};
            let currentTour = null;
            
            items.forEach((item, index) => {
                // Erkenne Tour-Zeilen basierend auf dem display_name
                const displayName = item.display_name || '';
                
                if (displayName.includes('Tour') || displayName.includes('BAR') || displayName.includes('Anlief')) {
                    // Das ist eine Tour-Zeile
                    currentTour = displayName;
                    if (!tours[currentTour]) {
                        tours[currentTour] = {
                            name: currentTour,
                            customers: [],
                            isBarTour: displayName.includes('BAR'),
                            time: extractTimeFromTourName(displayName)
                        };
                    }
                } else if (currentTour && displayName.trim()) {
                    // Das ist ein Kunde f√ºr die aktuelle Tour
                    tours[currentTour].customers.push({
                        customer_number: item.customer_number || item.id || '',
                        name: displayName,
                        street: item.resolved_address || '',
                        postal_code: '',
                        city: '',
                        bar_flag: tours[currentTour].isBarTour,
                        latitude: item.lat,
                        longitude: item.lon,
                        address: item.resolved_address || '',
                        status: item.status
                    });
                }
            });

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = Object.values(tours).map((tour, index) => {
                const key = `csv-${index}`;
                const customerCount = tour.customers.length;
                const okCount = tour.customers.filter(c => c.status === 'ok').length;
                const warnCount = tour.customers.filter(c => c.status === 'warn').length;
                const badCount = tour.customers.filter(c => c.status === 'bad').length;
                const barBadge = tour.isBarTour ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>` : '';
                
                allTourCustomers[key] = tour;

                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const isSubRoute = !!routeLetter;
                
                // Tourname ohne Buchstaben (f√ºr Anzeige)
                const cleanTourName = routeLetter ? (tour.name || '').replace(/\s[A-Z]$/, '').trim() : (tour.name || '');
                
                const baseTourId = tour._base_tour_id || cleanTourName?.split(' ')[0] || '';
                const routeIndex = tour._route_index !== undefined ? tour._route_index : index;
                const tourColor = tour._tour_color || getTourColor(baseTourId, routeIndex);
                
                // Border-Farbe f√ºr Sub-Routen
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // Status-Zeile mit Zahlen (wenn vorhanden)
                const statusText = routeNumber 
                    ? `${okCount} OK, ${warnCount} Warn, ${badCount} Bad ${routeNumber}`
                    : `${okCount} OK, ${warnCount} Warn, ${badCount} Bad`;
                
                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${cleanTourName}</strong>${barBadge}
                                <div class="small text-muted">${statusText}</div>
                            </div>
                            <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = Object.keys(tours).length ? `csv-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
        }

        // Hilfsfunktion zum Extrahieren der Zeit aus Tour-Namen
        function extractTimeFromTourName(tourName) {
            const timeMatch = tourName.match(/(\d{1,2})[.:](\d{2})/);
            if (timeMatch) {
                return `${timeMatch[1]}:${timeMatch[2]}`;
            }
            return tourName;
        }

        // Rendert Touren aus dem Match-Endpunkt oder Workflow-Ergebnis
        function renderToursFromMatch(matchData) {
            console.log('renderToursFromMatch aufgerufen, matchData:', matchData);
            
            // WICHTIG: L√∂sche alte allTourCustomers-Eintr√§ge, damit keine veralteten Daten √ºbrig bleiben
            // Nur Touren l√∂schen, die mit 'workflow-' beginnen (Workflow-Touren)
            Object.keys(allTourCustomers).forEach(key => {
                if (key.startsWith('workflow-')) {
                    delete allTourCustomers[key];
                }
            });
            console.log('[RENDER] Alte Workflow-Touren gel√∂scht, aktualisiere mit neuen Daten...');
            
            // Unterst√ºtze sowohl 'tours' (vom Workflow) als auch 'items' (vom Match-Endpoint)
            const tours = matchData.tours || [];
            const items = matchData.items || [];
            
            if (tours.length > 0) {
                // Workflow-Format: Direkt Touren verwenden
                console.log(`Rendering ${tours.length} Touren aus Workflow`);
                const totalAddresses = tours.reduce((sum, t) => sum + (t.stops?.length || 0), 0);
                const okCount = matchData.ok || matchData.counts?.ok || 0;
                const warnCount = matchData.warn || matchData.counts?.warn || 0;
                const badCount = matchData.bad || matchData.counts?.bad || 0;
                document.getElementById('tourSummary').textContent = `${okCount} OK, ${warnCount} Warn, ${badCount} Bad - ${tours.length} Touren`;
                
                // Hilfsfunktion: Extrahiere Basis-Tour-Name f√ºr Gruppierung (z.B. "W-07.00" aus "W-07.00 Uhr BAR" oder "W-07.00 Uhr Tour")
                function getTourBaseName(tourId) {
                    if (!tourId) return '';
                    // Entferne "Uhr BAR", "Uhr Tour", "BAR", "Tour" f√ºr Gruppierung
                    return tourId.replace(/\s*(Uhr\s*)?(BAR|Tour)$/i, '').trim();
                }
                
                // Hilfsfunktion: Pr√ºfe ob Tour eine BAR-Tour ist
                function isBarTour(tourId) {
                    return tourId && /BAR/i.test(tourId);
                }
                
                // Touren f√ºr Gruppierung vorbereiten und sortieren
                const toursWithMeta = tours.map((tour, index) => ({
                    ...tour,
                    index,
                    baseName: getTourBaseName(tour.tour_id),
                    isBar: isBarTour(tour.tour_id),
                    time: extractTimeFromTourName(tour.tour_id || '')
                }));
                
                // Intelligente Sortierung f√ºr verschiedene Tour-Typen
                // Hilfsfunktion: Pr√ºfe ob Tour eine W-Tour ist
                function isWTour(tourId) {
                    return tourId && /^W-\d+\.\d+/.test(tourId);
                }
                
                // Hilfsfunktion: Erkenne Tour-Typ
                function getTourType(tourId) {
                    if (!tourId) return 'other';
                    const upperId = tourId.toUpperCase();
                    
                    if (isWTour(tourId)) return 'w-tour';
                    if (/^T\d+/.test(tourId)) return 't-tour';  // T17, T71, T8
                    if (upperId.startsWith('BZ')) return 'bautzen';  // BZ, BZ-...
                    if (upperId.startsWith('CB')) return 'cottbus';  // CB, CB-...
                    if (upperId === 'DBD') return 'dbd';  // DBD (sollte letzter sein)
                    if (upperId === 'DVD') return 'dvd';  // DVD (Nachtlieferung, unwichtig)
                    
                    return 'other';
                }
                
                // Hilfsfunktion: Extrahiere Tour-Nummer f√ºr Sortierung
                function extractTourNumber(tourId) {
                    if (!tourId) return 9999;
                    
                    // T-Touren: T17 -> 17, T71 -> 71
                    const tMatch = tourId.match(/^T(\d+)/);
                    if (tMatch) return parseInt(tMatch[1]);
                    
                    // W-Touren: W-07.00 -> 7.00
                    const wMatch = tourId.match(/^W-(\d+)\.(\d+)/);
                    if (wMatch) return parseFloat(`${wMatch[1]}.${wMatch[2]}`);
                    
                    // Andere: Extrahiere erste Zahl
                    const numMatch = tourId.match(/(\d+)/);
                    if (numMatch) return parseInt(numMatch[1]);
                    
                    return 9999;
                }
                
                // Hilfsfunktion: Extrahiere Zeit f√ºr Sortierung (Minuten seit Mitternacht)
                function getTimeForSort(tourId) {
                    const timeMatch = tourId.match(/(\d{1,2})[.:](\d{2})/);
                    if (timeMatch) {
                        const hours = parseInt(timeMatch[1]);
                        const minutes = parseInt(timeMatch[2]);
                        return hours * 60 + minutes;
                    }
                    return 9999; // Keine Zeit gefunden = ans Ende
                }
                
                toursWithMeta.sort((a, b) => {
                    const aType = getTourType(a.tour_id);
                    const bType = getTourType(b.tour_id);
                    
                    // 1. W-Touren ZUERST (ganz oben) - unabh√§ngig von Zeit
                    if (aType === 'w-tour' && bType !== 'w-tour') return -1;
                    if (aType !== 'w-tour' && bType === 'w-tour') return 1;
                    
                    // 2. Innerhalb der W-Touren: nach Zeit sortieren
                    if (aType === 'w-tour' && bType === 'w-tour') {
                        const aTime = getTimeForSort(a.tour_id);
                        const bTime = getTimeForSort(b.tour_id);
                        const aHasTime = aTime !== 9999;
                        const bHasTime = bTime !== 9999;
                        
                        // Wenn beide Zeit haben: nach Zeit sortieren
                        if (aHasTime && bHasTime) {
                            if (aTime !== bTime) {
                                return aTime - bTime;  // Aufsteigend: fr√ºhere Zeit zuerst
                            }
                            // Gleiche Zeit: BAR vor normal
                            if (a.isBar && !b.isBar) return -1;
                            if (!a.isBar && b.isBar) return 1;
                            return 0;
                        }
                        
                        // Wenn nur eine Zeit hat: die mit Zeit kommt zuerst
                        if (aHasTime && !bHasTime) return -1;
                        if (!aHasTime && bHasTime) return 1;
                        
                        // Beide ohne Zeit: BAR vor normal, dann alphabetisch
                        if (a.isBar && !b.isBar) return -1;
                        if (!a.isBar && b.isBar) return 1;
                        return (a.tour_id || '').localeCompare(b.tour_id || '');
                    }
                    
                    // 3. Bei anderen Touren (nicht W-Touren): PRIM√ÑR nach Zeit sortieren
                    const aTime = getTimeForSort(a.tour_id);
                    const bTime = getTimeForSort(b.tour_id);
                    const aHasTime = aTime !== 9999;
                    const bHasTime = bTime !== 9999;
                    
                    // Wenn beide eine Zeit haben: Zeit hat absoluten Vorrang
                    if (aHasTime && bHasTime) {
                        if (aTime !== bTime) {
                            return aTime - bTime;  // Aufsteigend: fr√ºhere Zeit zuerst (7:45 vor 18:00)
                        }
                        // Gleiche Zeit: BAR vor normal, dann Typ
                    }
                    
                    // Wenn nur eine Zeit hat: die mit Zeit kommt IMMER zuerst
                    if (aHasTime && !bHasTime) return -1; // Zeit-Tour kommt vor Tour ohne Zeit
                    if (!aHasTime && bHasTime) return 1; // Tour ohne Zeit kommt nach Zeit-Tour
                    
                    // 2. DBD und DVD ans Ende (nur wenn keine Zeit vorhanden)
                    if (aType === 'dbd' && bType !== 'dbd') return 1;
                    if (aType !== 'dbd' && bType === 'dbd') return -1;
                    if (aType === 'dvd' && bType !== 'dvd') return 1;
                    if (aType !== 'dvd' && bType === 'dvd') return -1;
                    
                    // 4. Gleicher Typ: Sortiere nach Nummer oder Name, dann BAR vor normal
                    if (aType === bType) {
                        // F√ºr W-Touren: bereits nach Zeit sortiert (oben)
                        if (aType === 'w-tour') {
                            // Gleiche Zeit: BAR vor normal
                            if (a.isBar && !b.isBar) return -1;
                            if (!a.isBar && b.isBar) return 1;
                            return 0;
                        }
                        
                        // F√ºr T-Touren: nach Nummer sortieren (wenn keine Zeit vorhanden)
                        if (aType === 't-tour' && !aHasTime && !bHasTime) {
                            const aNum = extractTourNumber(a.tour_id);
                            const bNum = extractTourNumber(b.tour_id);
                            if (aNum !== bNum) return aNum - bNum;
                            // Gleiche Nummer: BAR vor normal
                            if (a.isBar && !b.isBar) return -1;
                            if (!a.isBar && b.isBar) return 1;
                            return 0;
                        }
                        
                        // Gleiche Zeit bei gleichem Typ: BAR vor normal, dann alphabetisch
                        if (a.isBar && !b.isBar) return -1;
                        if (!a.isBar && b.isBar) return 1;
                        return (a.tour_id || '').localeCompare(b.tour_id || '');
                    }
                    
                    // 5. Verschiedene Typen (nur wenn keine Zeit vorhanden): Sortiere nach Priorit√§t
                    const typePriority = {
                        'w-tour': 1,
                        't-tour': 2,
                        'bautzen': 3,
                        'cottbus': 3,
                        'other': 4,
                        'dbd': 5,
                        'dvd': 6
                    };
                    const aPriority = typePriority[aType] || 4;
                    const bPriority = typePriority[bType] || 4;
                    if (aPriority !== bPriority) return aPriority - bPriority;
                    
                    // 6. Gleiche Priorit√§t: BAR vor normal, dann alphabetisch
                    if (a.isBar && !b.isBar) return -1;
                    if (!a.isBar && b.isBar) return 1;
                    return (a.tour_id || '').localeCompare(b.tour_id || '');
                });
                
                const tourList = document.getElementById('tourList');
                // WICHTIG: Leere Tour-Liste vor neuem Rendering, um Duplikate zu vermeiden
                tourList.innerHTML = '';
                
                tourList.innerHTML = toursWithMeta.map((tourMeta) => {
                    const key = `workflow-${tourMeta.index}`;
                    const stops = tourMeta.stops || [];
                    const customerCount = stops.length;
                    const isBar = tourMeta.isBar;
                    
                    // Kunden mit Koordinaten f√ºr die Karte vorbereiten
                    // WICHTIG: Verwende individuelles bar_flag pro Kunde (falls vorhanden), sonst Tour-Level bar_flag
                    // BAR-Flag hat Priorit√§t: Erst individuell, dann Tour-Level, dann false
                    const customers = stops.map(stop => {
                        // Bestimme bar_flag: Erst individuell, dann Tour-Level, dann false
                        let barFlag = false;
                        if (stop.bar_flag !== undefined) {
                            barFlag = !!stop.bar_flag; // Individuelles bar_flag hat h√∂chste Priorit√§t
                        } else if (isBar !== undefined) {
                            barFlag = !!isBar; // Tour-Level bar_flag als Fallback
                        }
                        
                        return {
                            customer_number: stop.order_id || stop.customer_number || '',
                            name: stop.customer || stop.name || 'Unbekannt',
                            street: stop.street || '',
                            postal_code: stop.postal_code || '',
                            city: stop.city || '',
                            bar_flag: barFlag,  // Explizit gesetztes bar_flag
                            latitude: stop.lat,
                            longitude: stop.lon,
                            address: stop.address || (() => {
                                const parts = [stop.street, stop.postal_code, stop.city].filter(Boolean);
                                return parts.join(', ') || '';
                            })(),
                            has_coordinates: stop.has_coordinates !== undefined ? stop.has_coordinates : (stop.lat && stop.lon),  // Flag f√ºr Warnungen
                            warning: stop.warning || null  // Warnung direkt beim Kunden
                        };
                    });
                    
                    // Kunden f√ºr diese Tour speichern
                    // WICHTIG: Speichere auch Optimization-Info f√ºr sp√§tere Anzeige
                    allTourCustomers[key] = {
                        name: tourMeta.tour_id || `Tour ${tourMeta.index + 1}`,
                        type: isBar ? 'BAR' : 'Workflow',
                        time: tourMeta.time,
                        customers: customers,
                        optimization_method: tourMeta.optimization_method,  // F√ºr AI-Badge
                        optimized: tourMeta.optimized,
                        reasoning: tourMeta.reasoning
                    };
                    
                    // CSS-Klassen: W-Touren bekommen andere Farbe, BAR-Touren orange
                    const isWTour = /^W-\d+\.\d+/.test(tourMeta.tour_id || '');
                    const wTourClass = isWTour ? 'w-tour-highlight' : '';
                    
                    // BAR-Status: Pr√ºfe ob Tour BAR ist ODER ob einzelne Kunden BAR-Flag haben
                    const hasBarCustomers = customers.some(c => c.bar_flag === true);
                    const tourIsBar = isBar || hasBarCustomers;
                    const barCustomerCount = customers.filter(c => c.bar_flag === true).length;
                    
                    const barClass = tourIsBar ? 'bar-tour-highlight' : '';
                    const combinedClass = `${wTourClass} ${barClass}`.trim();
                    
                    // BAR-Badge: Zeige wenn Tour BAR ist oder BAR-Kunden vorhanden
                    const barBadge = tourIsBar 
                        ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCustomerCount > 0 ? barCustomerCount + ' ' : ''}BAR</span>` 
                        : '';
                    
                    // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                    const routeLetterMatch = (tourMeta.tour_id || '').match(/\s([A-Z])$/);
                    const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                    const isSubRoute = !!routeLetter;
                    
                    // Tourname ohne Buchstaben (f√ºr Anzeige)
                    const cleanTourName = routeLetter 
                        ? (tourMeta.tour_id || '').replace(/\s[A-Z]$/, '').trim() 
                        : (tourMeta.tour_id || `Tour ${tourMeta.index + 1}`);
                    
                    const baseTourId = cleanTourName?.split(' ')[0] || '';
                    const tourColor = getTourColor(baseTourId);
                    const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                    
                    // Stops-Zeile mit Zahlen (wenn vorhanden)
                    const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                    const stopsText = routeNumber 
                        ? `${customerCount} Stops ${routeNumber}`
                        : `${customerCount} Stops`;
                    
                    return `
                        <button class="list-group-item list-group-item-action ${combinedClass}" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                            <div class="d-flex justify-content-between">
                                <div>
                                    <strong>${cleanTourName}</strong>${barBadge}
                                    <div class="small text-muted">${stopsText}</div>
                                </div>
                                <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                            </div>
                        </button>`;
                }).join('');
                
                bindTourListEvents();
                
                // WICHTIG: Aktualisiere Sub-Routen Button nach Rendering
                updateSubRouteButtonVisibility();
                
                // Debug: Logge allTourCustomers nach Update
                const tourCount = Object.keys(allTourCustomers).filter(k => k.startsWith('workflow-')).length;
                console.log(`[RENDER] allTourCustomers aktualisiert: ${tourCount} Workflow-Touren in allTourCustomers`);
                
                if (tours.length > 0) {
                    // Warte kurz, damit DOM aktualisiert ist, dann erste Tour ausw√§hlen
                    setTimeout(() => {
                        selectTour(`workflow-${toursWithMeta[0].index}`);
                    }, 100);
                }
                return;
            }
            
            // Legacy Match-Format: Items verarbeiten
            if (!items.length) {
                console.log('Keine Items oder Touren gefunden in matchData');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${items.length} Items aus Match`);
            document.getElementById('tourSummary').textContent = `${matchData.ok} OK, ${matchData.warn} Warn, ${matchData.bad} Bad`;

            // Gruppiere Items nach Tour-Zeit basierend auf der urspr√ºnglichen CSV-Struktur
            const groupedTours = {};
            let currentTour = null;
            
            items.forEach((item, index) => {
                // Erkenne Tour-Zeilen basierend auf dem display_name
                const displayName = item.display_name || '';
                
                if (displayName.includes('Tour') || displayName.includes('BAR') || displayName.includes('Anlief')) {
                    // Das ist eine Tour-Zeile
                    currentTour = displayName;
                    if (!groupedTours[currentTour]) {
                        groupedTours[currentTour] = {
                            name: currentTour,
                            customers: [],
                            isBarTour: displayName.includes('BAR'),
                            time: extractTimeFromTourName(displayName)
                        };
                    }
                } else if (currentTour && displayName.trim()) {
                    // Das ist ein Kunde f√ºr die aktuelle Tour
                    groupedTours[currentTour].customers.push({
                        customer_number: item.customer_number || item.id || '',
                        name: displayName,
                        street: item.resolved_address || '',
                        postal_code: '',
                        city: '',
                        bar_flag: groupedTours[currentTour].isBarTour,
                        latitude: item.lat,
                        longitude: item.lon,
                        address: item.resolved_address || '',
                        status: item.status
                    });
                }
            });

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = Object.values(groupedTours).map((tour, index) => {
                const key = `match-${index}`;
                const customerCount = tour.customers.length;
                const okCount = tour.customers.filter(c => c.status === 'ok').length;
                const warnCount = tour.customers.filter(c => c.status === 'warn').length;
                const badCount = tour.customers.filter(c => c.status === 'bad').length;
                const barBadge = tour.isBarTour ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>` : '';
                
                allTourCustomers[key] = tour;

                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const isSubRoute = !!routeLetter;
                
                // Tourname ohne Buchstaben (f√ºr Anzeige)
                const cleanTourName = routeLetter ? (tour.name || '').replace(/\s[A-Z]$/, '').trim() : (tour.name || '');
                
                const baseTourId = tour._base_tour_id || cleanTourName?.split(' ')[0] || '';
                const routeIndex = tour._route_index !== undefined ? tour._route_index : index;
                const tourColor = tour._tour_color || getTourColor(baseTourId, routeIndex);
                
                // Border-Farbe f√ºr Sub-Routen
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // Status-Zeile mit Zahlen (wenn vorhanden)
                const statusText = routeNumber 
                    ? `${okCount} OK, ${warnCount} Warn, ${badCount} Bad ${routeNumber}`
                    : `${okCount} OK, ${warnCount} Warn, ${badCount} Bad`;
                
                return `
                    <button class="list-group-item list-group-item-action" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                        <div class="d-flex justify-content-between">
                            <div>
                                <strong>${cleanTourName}</strong>${barBadge}
                                <div class="small text-muted">${statusText}</div>
                            </div>
                            <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = Object.keys(groupedTours).length ? `match-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
            
            // Sub-Routen Button aktualisieren
            updateSubRouteButtonVisibility();
        }

        function renderToursFromWorkflow() {
            console.log('renderToursFromWorkflow aufgerufen, workflowResult:', workflowResult);
            
            // Neue Datenstruktur: workflow_results.final_results.routes.routes
            const routes = workflowResult?.final_results?.routes;
            const tourRoutes = routes?.routes || [];
            
            if (!tourRoutes.length) {
                console.log('Keine Touren gefunden in workflowResult');
                renderEmptyTours();
                return;
            }

            console.log(`Rendering ${tourRoutes.length} Touren aus Workflow`);
            const totalAddresses = tourRoutes.reduce((sum, t) => sum + (t.customers?.length || 0), 0);
            document.getElementById('tourSummary').textContent = `${routes.total_routes} Touren ¬∑ ${totalAddresses} Adressen`;

            const tourList = document.getElementById('tourList');
            tourList.innerHTML = tourRoutes.map((tour, index) => {
                const key = `workflow-${index}`;
                const customerCount = tour.customers?.length || 0;
                const barCount = tour.is_bar_tour ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">BAR</span>` : '';
                
                // Kunden mit Koordinaten f√ºr die Karte vorbereiten
                const customers = (tour.customers || []).map(c => ({
                    customer_number: c.customer_number || c.kdnr || '',
                    name: c.name || c.customer_name || 'Unbekannt',
                    street: c.street || c.address || '',
                    postal_code: c.postal_code || c.zip || '',
                    city: c.city || '',
                    bar_flag: !!(c.bar_flag || c.bar),
                    latitude: c.coordinates?.lat || c.latitude,
                    longitude: c.coordinates?.lon || c.longitude,
                    address: c.resolved_address || c.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [c.street || c.address || '', c.postal_code || c.zip || '', c.city || ''].map(clean).filter(Boolean);
                    return parts.join(', ') || '';
                })()
                }));

                // Kunden f√ºr diese Tour speichern
                allTourCustomers[key] = {
                    name: tour.name || `Tour ${index + 1}`,
                    type: tour.tour_type || 'Workflow',
                    time: tour.time || '',
                    customers,
                    _route_index: tour._route_index !== undefined ? tour._route_index : index  // Route-Index f√ºr Farbzuweisung
                };

                // BAR-Status: Pr√ºfe Tour-Level und individuelle Kunden
                const hasBarCustomers = customers.some(c => c.bar_flag === true);
                const tourIsBar = tour.is_bar_tour || hasBarCustomers;
                const barCustomerCount = customers.filter(c => c.bar_flag === true).length;
                const barBadge = tourIsBar 
                    ? `<span class="badge ms-2" style="background-color: #ff9800; color: #000;">${barCustomerCount > 0 ? barCustomerCount + ' ' : ''}BAR</span>` 
                    : '';

                // Pr√ºfe ob es eine Sub-Route ist (Buchstabe am Ende des Namens)
                const routeLetterMatch = (tour.name || '').match(/\s([A-Z])$/);
                const routeLetter = routeLetterMatch ? routeLetterMatch[1] : '';
                const isSubRoute = !!routeLetter;
                
                // Tourname: Verwende vollst√§ndigen Namen (inkl. Sub-Route-Buchstabe) f√ºr Konsistenz
                // Der vollst√§ndige Name wird sowohl in Sidebar als auch im Detail-Bereich verwendet
                const displayTourName = tour.name || `Tour ${index + 1}`;
                
                // F√ºr CSS-Klassen: Basis-Name ohne Buchstaben
                const baseTourName = routeLetter ? (tour.name || '').replace(/\s([A-Z])$/, '').trim() : (tour.name || `Tour ${index + 1}`);
                
                const baseTourId = tour._base_tour_id || baseTourName?.split(' ')[0] || '';
                const routeIndex = tour._route_index !== undefined ? tour._route_index : index;
                const tourColor = tour._tour_color || getTourColor(baseTourId, routeIndex);
                
                // BAR-Badge auch f√ºr Sub-Routen anzeigen
                const subRouteBarCount = isSubRoute && tourIsBar ? barCustomerCount : 0;
                const subRouteBarBadge = isSubRoute && subRouteBarCount > 0 
                    ? `<span class="badge ms-1" style="background-color: #ff9800; color: #000; font-size: 0.75em;">${subRouteBarCount} BAR</span>` 
                    : '';
                
                // Border-Farbe f√ºr Sub-Routen
                const borderColor = isSubRoute ? `border-left: 4px solid ${tourColor};` : '';
                
                // CSS-Klassen auch f√ºr Workflow-Touren (basierend auf Basis-Name)
                const isWTour = /^W-\d+\.\d+/.test(baseTourName || '');
                const wTourClass = isWTour ? 'w-tour-highlight' : '';
                const barClass = tourIsBar ? 'bar-tour-highlight' : '';
                const combinedClass = `${wTourClass} ${barClass}`.trim();
                
                // Stops-Zeile mit Zahlen (wenn vorhanden)
                const routeNumber = routeLetter ? letterToNumber(routeLetter) : '';
                const stopsText = routeNumber 
                    ? `${customerCount} Stops ${routeNumber} ¬∑ ${tour.tour_type || 'Workflow'}`
                    : `${customerCount} Stops ¬∑ ${tour.tour_type || 'Workflow'}`;

                return `
                    <button class="list-group-item list-group-item-action ${combinedClass}" id="tour-${key}" data-tour-key="${key}" style="${borderColor}">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <strong>${displayTourName}</strong>${barBadge}${subRouteBarBadge}
                                <div class="small text-muted">${stopsText}</div>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge rounded-pill" style="background-color: ${isSubRoute ? tourColor : '#0d6efd'}; color: #fff;">${customerCount}</span>
                                <button class="btn btn-sm btn-link p-0 text-secondary optimize-tour-btn" 
                                        data-tour-key="${key}" 
                                        data-tour-name="${tour.name || `Tour ${index + 1}`}"
                                        data-stop-count="${customerCount}"
                                        title="Tour mit AI optimieren"
                                        onclick="event.stopPropagation(); optimizeTour('${key}', '${tour.name || `Tour ${index + 1}`}');">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </button>`;
            }).join('');

            bindTourListEvents();

            const firstKey = tourRoutes.length ? `workflow-0` : null;
            if (firstKey) {
                selectTour(firstKey);
            }
            
            // Sub-Routen Button aktualisieren
            updateSubRouteButtonVisibility();
        }

        function renderCustomerList(customers) {
            if (!customers || !customers.length) {
                return '<span class="text-muted">Keine Kunden vorhanden.</span>';
            }

            const SERVICE_TIME_MINUTES = 2.0; // Entladezeit pro Kunde
            const SPEED_KMH = 50.0; // Durchschnittsgeschwindigkeit
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;
            
            let totalDistanceKm = 0;
            let totalTimeMinutes = 0;
            let cumulativeTimeMinutes = 0;
            const rows = [];
            
            // WICHTIG: Depot als ersten Eintrag hinzuf√ºgen
            const depotRow = `
                <tr style="background-color: #e1bee7; font-weight: bold;">
                    <td>0</td>
                    <td>FAMO Depot <span class="badge ms-1" style="background-color: #9c27b0; color: #fff;">DEPOT</span></td>
                    <td>Gittersee, Dresden</td>
                    <td>‚Äî</td>
                    <td>
                        <div class="small">
                            <div class="text-muted">Start</div>
                            <div class="text-primary fw-bold">0.0 Min</div>
                        </div>
                    </td>
                </tr>
            `;
            rows.push(depotRow);
            
            // Hilfsfunktion: Haversine-Distanz
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371.0; // Erdradius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            // Berechne Daten f√ºr jeden Kunden
            for (let idx = 0; idx < customers.length; idx++) {
                const c = customers[idx];
                const key = `${c.customer_number || idx}-${idx}`;
                c._geoKey = key;
                const hasCoords = c.has_coordinates !== undefined ? c.has_coordinates : hasCoordinates(c);
                
                // Gelbe Ausrufezeichen nur wenn KEINE Koordinaten vorhanden
                const showGeoIcon = !hasCoords;
                
                // Berechne Distanz und Zeit
                let distanceKm = 0;
                let driveTimeMinutes = 0;
                let timeText = '‚Äî';
                let fromText = '';
                
                if (hasCoords) {
                    const currLat = parseFloat(c.latitude);
                    const currLon = parseFloat(c.longitude);
                    
                    if (!isNaN(currLat) && !isNaN(currLon)) {
                        if (idx === 0) {
                            // Erster Kunde: Vom Depot
                            distanceKm = haversineDistance(depotLat, depotLon, currLat, currLon) * 1.3;
                            fromText = '<small class="text-muted">Depot</small>';
                        } else {
                            // Weitere Kunden: Vom vorherigen Kunden
                            const prevLat = parseFloat(customers[idx-1].latitude);
                            const prevLon = parseFloat(customers[idx-1].longitude);
                            
                            if (!isNaN(prevLat) && !isNaN(prevLon)) {
                                distanceKm = haversineDistance(prevLat, prevLon, currLat, currLon) * 1.3;
                                fromText = `<small class="text-muted">${idx}</small>`; // Nummer des vorherigen Kunden
                            }
                        }
                        
                        // Fahrtzeit berechnen (Distanz / Geschwindigkeit * 60)
                        driveTimeMinutes = (distanceKm / SPEED_KMH) * 60;
                        
                        // Kumulative Zeit: Fahrtzeit + Entladezeit (2 Min)
                        cumulativeTimeMinutes += driveTimeMinutes + SERVICE_TIME_MINUTES;
                        
                        totalDistanceKm += distanceKm;
                        totalTimeMinutes = cumulativeTimeMinutes;
                        
                        // Zeit-Text: Fahrtzeit + Entladezeit = Gesamt, kumulativ
                        timeText = `
                            <div class="small">
                                <div>${driveTimeMinutes.toFixed(1)} Min <span class="text-muted">(Fahrt)</span></div>
                                <div class="text-muted">+ ${SERVICE_TIME_MINUTES} Min (Entladung)</div>
                                <div class="text-primary fw-bold">= ${cumulativeTimeMinutes.toFixed(1)} Min <span class="text-muted">(kumulativ)</span></div>
                            </div>
                        `;
                    }
                }
                
                const rowClass = hasCoords ? '' : ' class="table-warning"';  // Gelb f√ºr Warnungen
                const warningBadge = c.warning ? `<br><small class="text-danger"><i class="fas fa-exclamation-triangle"></i> ${c.warning}</small>` : '';
                // BAR-Badge: Pr√ºfe explizit auf true (nicht nur truthy)
                const barBadge = (c.bar_flag === true || c.bar_flag === 'true' || c.bar_flag === 1) 
                    ? ' <span class="badge ms-1" style="background-color: #ff9800; color: #000; font-weight: bold;">BAR</span>' 
                    : '';
                
                // BAR-Zeile zus√§tzlich hervorheben
                const barRowClass = barBadge ? ' style="background-color: #fff3e0;"' : '';
                
                rows.push(`
                    <tr${rowClass}${barRowClass}>
                        <td>${idx + 1}</td>
                        <td>${c.name}${barBadge}${warningBadge}</td>
                        <td>${c.resolved_address || c.address || (() => {
                            const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                            const parts = [c.street, c.postal_code, c.city].map(clean).filter(Boolean);
                            return parts.join(', ') || '‚Äî';
                        })()}</td>
                        <td>${c.customer_number || '‚Äî'}</td>
                        <td class="text-center">
                            ${fromText ? `<div>${fromText}</div>` : ''}
                            ${distanceKm > 0 ? `<div class="small text-muted">${distanceKm.toFixed(1)} km</div>` : '‚Äî'}
                        </td>
                        <td class="text-center small">${timeText}</td>
                        <td class="text-center">
                            ${showGeoIcon ? `<span class="geo-status" data-geokey="${key}" title="${c.warning || (hasCoords ? 'Koordinaten vorhanden' : 'Keine Koordinaten')}">${getGeoStatusIcon(hasCoords)}</span>` : '<span class="text-success" title="Auf Karte sichtbar"><i class="fas fa-check-circle"></i></span>'}
                        </td>
                    </tr>
                `);
            }
            
            // WICHTIG: Berechne R√ºckfahrt zum Depot (vom letzten Kunden)
            let returnDistanceKm = 0;
            let returnTimeMinutes = 0;
            if (customers.length > 0) {
                const lastCustomer = customers[customers.length - 1];
                const lastLat = parseFloat(lastCustomer.latitude);
                const lastLon = parseFloat(lastCustomer.longitude);
                
                if (!isNaN(lastLat) && !isNaN(lastLon)) {
                    returnDistanceKm = haversineDistance(lastLat, lastLon, depotLat, depotLon) * 1.3;
                    returnTimeMinutes = (returnDistanceKm / SPEED_KMH) * 60;
                    totalDistanceKm += returnDistanceKm;
                    cumulativeTimeMinutes += returnTimeMinutes;
                    totalTimeMinutes = cumulativeTimeMinutes;
                    
                    // WICHTIG: Depot als letzten Eintrag hinzuf√ºgen (R√ºckfahrt)
                    const depotReturnRow = `
                        <tr style="background-color: #e1bee7; font-weight: bold;">
                            <td>${customers.length + 1}</td>
                            <td>FAMO Depot <span class="badge ms-1" style="background-color: #9c27b0; color: #fff;">DEPOT</span></td>
                            <td>Gittersee, Dresden</td>
                            <td>DEPOT</td>
                            <td>
                                <div class="small">
                                    <div>${returnDistanceKm.toFixed(2)} km</div>
                                    <div class="text-muted">von ${customers[customers.length - 1].name}</div>
                                </div>
                            </td>
                            <td>
                                <div class="small">
                                    <div>${returnTimeMinutes.toFixed(1)} Min <span class="text-muted">(R√ºckfahrt)</span></div>
                                    <div class="text-primary fw-bold">= ${totalTimeMinutes.toFixed(1)} Min <span class="text-muted">(gesamt)</span></div>
                                </div>
                            </td>
                            <td class="text-center">
                                <span class="text-success" title="Depot"><i class="fas fa-warehouse"></i></span>
                            </td>
                        </tr>
                    `;
                    rows.push(depotReturnRow);
                }
            }
            
            return `
                <div class="table-responsive">
                    <table class="table table-sm align-middle">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Kunde</th>
                                <th>Adresse</th>
                                <th>KdNr</th>
                                <th class="text-center">Distanz</th>
                                <th class="text-center">Zeit</th>
                                <th class="text-center">Geo</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows.join('')}
                        </tbody>
                        <tfoot class="table-info">
                            <tr>
                                <td colspan="4" class="text-end fw-bold">GESAMT (inkl. R√ºckfahrt):</td>
                                <td class="text-center fw-bold">${totalDistanceKm.toFixed(2)} km</td>
                                <td class="text-center fw-bold">
                                    <div class="small">
                                        <div>Fahrzeit: ${(totalTimeMinutes - ((customers.length + 1) * SERVICE_TIME_MINUTES)).toFixed(1)} Min</div>
                                        <div>Service: ${((customers.length + 1) * SERVICE_TIME_MINUTES).toFixed(1)} Min</div>
                                        <div>R√ºckfahrt: ${returnTimeMinutes.toFixed(1)} Min</div>
                                        <div class="text-primary fw-bold">Gesamt: ${totalTimeMinutes.toFixed(1)} Min</div>
                                    </div>
                                </td>
                                <td class="text-center">
                                    <span class="badge bg-primary">${customers.length + 1} Stopps</span>
                                    <small class="text-muted d-block">(${customers.length} Kunden + Depot)</small>
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                </div>`;
        }

        function hasCoordinates(customer) {
            // Pr√ºfe zuerst has_coordinates Flag (vom Backend), dann lat/lon
            if (customer?.has_coordinates !== undefined) {
                return customer.has_coordinates;
            }
            const lat = parseFloat(customer?.latitude);
            const lon = parseFloat(customer?.longitude);
            return !isNaN(lat) && !isNaN(lon);
        }

        function getGeoStatusIcon(customerOrFlag) {
            const hasCoords = typeof customerOrFlag === 'boolean' ? customerOrFlag : hasCoordinates(customerOrFlag);
            if (hasCoords) {
                return '<i class="fas fa-check-circle text-success"></i>';
            }
            return '<i class="fas fa-exclamation-triangle text-warning"></i>';  // Warnung-Icon statt Fehler
        }

        function updateGeoIndicator(customer, hasCoords) {
            if (!customer || !customer._geoKey) {
                return;
            }
            const el = document.querySelector(`.geo-status[data-geokey="${customer._geoKey}"]`);
            if (el) {
                el.innerHTML = getGeoStatusIcon(hasCoords);
            }
        }

        function bindTourListEvents() {
            const buttons = document.querySelectorAll('#tourList .list-group-item');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const key = btn.getAttribute('data-tour-key');
                    selectTour(key);
                });
            });
        }

        function selectTour(key) {
            if (!key || !allTourCustomers[key]) {
                return;
            }

            activeTourKey = key;
            window.currentTourKey = key; // Setze f√ºr Sub-Route-Erkennung
            updateTourListSelection(key);
            renderTourDetails(allTourCustomers[key]);
        }

        function updateTourListSelection(key) {
            const buttons = document.querySelectorAll('#tourList .list-group-item');
            buttons.forEach(btn => {
                if (btn.getAttribute('data-tour-key') === key) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function renderTourDetails(tourData) {
            if (!tourData) {
                document.getElementById('tourDetails').innerHTML = '<span class="text-muted">Keine Tour ausgew√§hlt.</span>';
                clearTourMarkers();
                return;
            }

            const details = document.getElementById('tourDetails');
            details.innerHTML = `
                <h5>${tourData.name}</h5>
                <div class="mb-2 text-muted">${tourData.type || ''} ${tourData.time ? '¬∑ ' + tourData.time : ''}</div>
                ${renderCustomerList(tourData.customers)}
            `;

            highlightTourOnMap(tourData.customers);
        }

        function renderWorkflowDetails(info) {
            if (!info || !info.ai_result) {
                return '<span class="text-muted">Keine Detaildaten verf√ºgbar.</span>';
            }

            const tours = info.subtours || [];
            if (!tours.length) {
                return '<span class="text-muted">Keine Untertouren erstellt.</span>';
            }

            return tours.map((tour, idx) => `
                <div class="mb-3">
                    <h6>Untertour ${idx + 1}</h6>
                    <pre class="bg-light p-2">${JSON.stringify(tour, null, 2)}</pre>
                </div>`).join('');
        }

        function renderEmptyTours() {
            document.getElementById('tourSummary').textContent = 'Keine Tourdaten';
            document.getElementById('tourList').innerHTML = '';
            document.getElementById('tourDetails').innerHTML = `
                <div class="text-center text-muted py-4">
                    <i class="fas fa-info-circle"></i><br>
                    Noch keine Tourdaten. CSV hochladen oder Workflow starten.
                </div>`;
            clearTourMarkers();
        }

        function passFilter(tour) {
            // Alle Touren werden angezeigt (Filter entfernt)
            return true;
        }

        function passWorkflowFilter(header, info) {
            // Alle Touren werden angezeigt (Filter entfernt)
            return true;
        }

        function clearTourMarkers() {
            if (!map) {
                return;
            }
            // L√∂sche Marker
            if (tourMarkers && Array.isArray(tourMarkers) && tourMarkers.length) {
                tourMarkers.forEach(marker => {
                    try {
                        if (marker && map.hasLayer(marker)) {
                            map.removeLayer(marker);
                        }
                    } catch (e) {
                        console.warn('Fehler beim Entfernen von Marker:', e);
                    }
                });
                tourMarkers = [];
            }
            // L√∂sche Route-Linien
            if (tourRouteLines && Array.isArray(tourRouteLines) && tourRouteLines.length) {
                tourRouteLines.forEach(line => {
                    try {
                        if (line && map.hasLayer(line)) {
                            map.removeLayer(line);
                        }
                    } catch (e) {
                        console.warn('Fehler beim Entfernen von Route-Linie:', e);
                    }
                });
                tourRouteLines = [];
            }
        }

        async function highlightTourOnMap(customers) {
            if (!map) {
                return;
            }

            clearTourMarkers();

            if (!customers || !customers.length) {
                return;
            }

            // Bestimme Tour-Farbe basierend auf aktueller Tour
            const currentKey = window.currentTourKey || '';
            const baseTourId = currentKey.split(' ')[0] || '';
            // Versuche route_index aus aktueller Tour zu holen
            const currentTour = allTourCustomers[currentKey];
            const routeIndex = currentTour?._route_index;
            const tourColor = getTourColor(baseTourId, routeIndex);
            
            // W√§hle Marker-Farbe basierend auf Tour
            const markerColors = {
                '#2196F3': 'blue',
                '#4CAF50': 'green',
                '#FF9800': 'orange',
                '#9C27B0': 'violet',
                '#F44336': 'red',
                '#00BCD4': 'cyan',
                '#795548': 'brown',
                '#607D8B': 'blue-grey',
                '#E91E63': 'pink',
                '#3F51B5': 'indigo'
            };
            const markerColor = markerColors[tourColor] || 'red';

            const bounds = [];
            const customersWithCoords = [];

            // Nummeriere Kunden basierend auf ihrer Reihenfolge in der Tour
            let customerIndex = 1;
            
            for (const customer of customers) {
                // Koordinaten sind jetzt direkt im Customer-Objekt vom Server
                const hasCoords = hasCoordinates(customer);
                updateGeoIndicator(customer, hasCoords);
                
                if (!hasCoords) {
                    console.warn(`Keine Koordinaten f√ºr ${customer.name}`);
                    continue;
                }

                const lat = parseFloat(customer.latitude);
                const lon = parseFloat(customer.longitude);
                
                customersWithCoords.push(customer);  // F√ºr Route-Zeichnung
                
                // Marker mit Nummer erstellen
                const markerNumber = customerIndex++;
                const marker = L.marker([lat, lon], {
                    icon: L.divIcon({
                        className: 'numbered-marker',
                        html: `
                            <div style="
                                position: relative;
                                width: 35px;
                                height: 35px;
                                background-color: ${tourColor || '#2196F3'};
                                border: 3px solid white;
                                border-radius: 50%;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                font-weight: bold;
                                font-size: 14px;
                                color: white;
                                text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                            ">
                                ${markerNumber}
                            </div>
                        `,
                        iconSize: [35, 35],
                        iconAnchor: [17, 17],
                        popupAnchor: [0, -17]
                    })
                }).addTo(map);
                
                // Popup mit Kunden-Nummer und Reihenfolge
                const customerNumber = customer.customer_number ? `<br><strong>KdNr:</strong> ${customer.customer_number}` : '';
                const address = customer.resolved_address || customer.address || (() => {
                    const clean = (v) => String(v ?? '').trim().replace(/^'+|'+$/g, '').replace(/^"+|"+$/g, '');
                    const parts = [customer.street, customer.postal_code, customer.city].map(clean).filter(Boolean);
                    return parts.join(', ') || '‚Äî';
                })();
                
                marker.bindPopup(`<strong>#${markerNumber - 1}: ${customer.name}</strong>${customerNumber}<br>${address}`);
                tourMarkers.push(marker);
                bounds.push([lat, lon]);
            }

            // WICHTIG: Depot hinzuf√ºgen (Start- und Endpunkt)
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;
            
            // Depot-Marker (lila, gr√∂√üer, mit Warehouse-Icon)
            const depotIcon = L.divIcon({
                className: 'depot-marker',
                html: '<i class="fas fa-warehouse" style="font-size: 24px; color: #9c27b0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);"></i>',
                iconSize: [30, 30],
                iconAnchor: [15, 30]
            });
            
            const depotMarker = L.marker([depotLat, depotLon], {
                icon: depotIcon,
                zIndexOffset: 1000  // Immer oben
            }).addTo(map);
            
            depotMarker.bindPopup('<strong>FAMO Depot</strong><br>Gittersee, Dresden<br><span class="badge" style="background-color: #9c27b0; color: #fff;">HAUPTLAGER</span>');
            tourMarkers.push(depotMarker);
            bounds.push([depotLat, depotLon]);
            
            // Zeichne Routen-Linien zwischen Depot und Kunden (OSRM)
            await drawRouteLines(customersWithCoords, tourColor, true);  // include_depot = true

            if (bounds.length) {
                const featureGroup = L.featureGroup([...tourMarkers, ...tourRouteLines]);
                map.fitBounds(featureGroup.getBounds().pad(0.2));
            }
        }

        // Dekodiere OSRM Polyline (encoded polyline string)
        // Polyline6-Decoder (f√ºr OSRM geometries=polyline6)
        async function decodePolyline6(encoded) {
            try {
                // Dynamischer Import des Polyline6-Moduls
                const { decodePolyline6: decodeP6 } = await import('/static/js/polyline6.js');
                return decodeP6(encoded);
            } catch (error) {
                console.warn('[POLYLINE6] Modul-Import fehlgeschlagen, verwende Inline-Decoder:', error);
                // Inline-Fallback f√ºr Polyline6
                return decodePolyline6Inline(encoded);
            }
        }

        function decodePolyline6Inline(encoded) {
            if (!encoded || typeof encoded !== 'string') return [];
            let index = 0, lat = 0, lon = 0, coords = [];
            const shift = 5;
            
            const next = () => {
                let result = 0, b, i = 0;
                do {
                    if (index >= encoded.length) return null;
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << (i * shift);
                    i++;
                } while (b >= 0x20);
                return (result & 1) ? ~(result >> 1) : (result >> 1);
            };
            
            while (index < encoded.length) {
                const dlat = next();
                const dlon = next();
                if (dlat === null || dlon === null) break;
                lat += dlat;
                lon += dlon;
                coords.push([lat / 1e6, lon / 1e6]);
            }
            return coords;
        }

        function decodePolyline(encoded, usePolyline6 = false) {
            try {
                if (!encoded || typeof encoded !== 'string') {
                    console.error('[POLYLINE] Keine g√ºltige Polyline-String √ºbergeben:', encoded);
                    return null;
                }
                
                // Entferne "polyline(" und ")" falls vorhanden
                let cleanEncoded = encoded.replace(/^polyline\(/i, '').replace(/\)$/i, '').trim();
                
                if (cleanEncoded.length === 0) {
                    console.error('[POLYLINE] Leerer String nach Bereinigung');
                    return null;
                }
                
                console.log(`[POLYLINE] Bereinigte Polyline (${cleanEncoded.length} Zeichen, Polyline6: ${usePolyline6}): ${cleanEncoded.substring(0, 30)}...`);
                
                // Wenn Polyline6 gew√ºnscht, verwende Polyline6-Decoder
                if (usePolyline6) {
                    const decoded = decodePolyline6Inline(cleanEncoded);
                    if (decoded && decoded.length > 0) {
                        console.log(`[POLYLINE] Polyline6 dekodiert: ${decoded.length} Punkte`);
                        return decoded;
                    }
                }
                
                // Pr√ºfe ob @mapbox/polyline verf√ºgbar ist (f√ºr Polyline5)
                if (typeof polyline !== 'undefined' && typeof polyline.decode === 'function') {
                    try {
                        // Verwende @mapbox/polyline Library (OSRM verwendet Precision 5)
                        const decoded = polyline.decode(cleanEncoded);
                        console.log(`[POLYLINE] @mapbox/polyline dekodiert: ${decoded.length} Punkte`);
                        return decoded.map(coord => [coord[0], coord[1]]);
                    } catch (polylineError) {
                        console.warn('[POLYLINE] @mapbox/polyline Fehler, verwende Fallback:', polylineError);
                    }
                }
                
                // Fallback: Eigene Implementierung f√ºr Polyline5 (wenn Library nicht verf√ºgbar)
                console.log('[POLYLINE] Verwende Fallback-Implementierung (Polyline5)');
                const coordinates = [];
                let index = 0;
                const len = cleanEncoded.length;
                let lat = 0;
                let lng = 0;
                
                try {
                    while (index < len) {
                        let b, shift = 0, result = 0;
                        do {
                            if (index >= len) break;
                            b = cleanEncoded.charCodeAt(index++) - 63;
                            result |= (b & 0x1f) << shift;
                            shift += 5;
                        } while (b >= 0x20);
                        
                        const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                        lat += dlat;
                        
                        shift = 0;
                        result = 0;
                        do {
                            if (index >= len) break;
                            b = cleanEncoded.charCodeAt(index++) - 63;
                            result |= (b & 0x1f) << shift;
                            shift += 5;
                        } while (b >= 0x20);
                        
                        const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
                        lng += dlng;
                        
                        coordinates.push([lat / 1e5, lng / 1e5]);
                    }
                    
                    console.log(`[POLYLINE] Fallback dekodiert: ${coordinates.length} Punkte`);
                    return coordinates;
                } catch (fallbackError) {
                    console.error('[POLYLINE] Fallback-Implementierung Fehler:', fallbackError);
                    return null;
                }
            } catch (error) {
                console.error('[POLYLINE] Fehler beim Dekodieren:', error);
                return null;
            }
        }

        // Zeichne OSRM-Routen-Linien zwischen Stopps (inkl. Depot)
        async function drawRouteLines(customers, routeColor, includeDepot = false) {
            if (!map || !customers || customers.length < 1) {
                return;
            }

            // Filtere Kunden mit Koordinaten
            const customersWithCoords = customers.filter(c => hasCoordinates(c));
            if (customersWithCoords.length < 1) {
                return;
            }

            // Depot-Koordinaten
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;

            try {
                // Bereite Stopps f√ºr API vor
                // WICHTIG: Wenn includeDepot, f√ºge Depot am Anfang und Ende hinzu
                let stops = customersWithCoords.map(c => ({
                    lat: parseFloat(c.latitude),
                    lon: parseFloat(c.longitude),
                    name: c.name || 'Unbekannt',
                    customer_number: c.customer_number || ''
                }));
                
                // Depot am Anfang und Ende hinzuf√ºgen (wenn includeDepot)
                if (includeDepot) {
                    stops = [
                        { lat: depotLat, lon: depotLon, name: 'FAMO Depot', customer_number: 'DEPOT' },
                        ...stops,
                        { lat: depotLat, lon: depotLon, name: 'FAMO Depot', customer_number: 'DEPOT' }
                    ];
                }

                // Hole Route-Details vom Backend
                const response = await fetch('/api/tour/route-details', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stops: stops, include_depot: includeDepot })
                });

                if (!response.ok) {
                    console.warn('Route-Details nicht verf√ºgbar, zeichne gerade Linien');
                    // Fallback: Zeichne gerade Linien zwischen Stopps (inkl. Depot)
                    drawStraightLines(customersWithCoords, routeColor, includeDepot);
                    return;
                }

                const routeData = await response.json();
                const routes = routeData.routes || [];
                
                console.log(`[ROUTE-VIS] Route-Details erhalten: ${routes.length} Routen-Segmente`);

                if (routes.length === 0) {
                    console.warn('[ROUTE-VIS] Keine Routen erhalten, verwende Fallback (gerade Linien)');
                    drawStraightLines(customersWithCoords, routeColor, includeDepot);
                    return;
                }

                // Zeichne jede Route
                for (const route of routes) {
                    let polyline;
                    
                    // DEBUG: Log was ankommt
                    console.log(`[ROUTE-VIS] Route-Details:`, {
                        from: route.from,
                        to: route.to,
                        has_geometry: !!route.geometry,
                        geometry_type: typeof route.geometry,
                        geometry_preview: route.geometry ? route.geometry.substring(0, 50) + '...' : null,
                        geometry_value: route.geometry,  // Vollst√§ndiger Wert f√ºr Debugging
                        source: route.source
                    });

                    if (route.geometry && typeof route.geometry === 'string' && route.geometry.trim().length > 0) {
                        // OSRM Polyline (encodiert) - dekodiere und zeichne stra√üenbasierte Route
                        try {
                            const startTime = performance.now();
                            console.log(`[ROUTE-VIS] Versuche Polyline zu dekodieren (L√§nge: ${route.geometry.length} Zeichen)`);
                            
                            // Pr√ºfe ob Polyline6 (aus Backend-Konfiguration oder Route-Source)
                            const usePolyline6 = route.source === 'osrm' || route.geometry_type === 'polyline6';
                            const decodedCoordinates = decodePolyline(route.geometry, usePolyline6);
                            
                            const decodeTime = performance.now() - startTime;
                            console.log(`[ROUTE-VIS] Dekodierung dauerte ${decodeTime.toFixed(2)}ms`);
                            
                            if (decodedCoordinates && decodedCoordinates.length > 0) {
                                // Zeichne stra√üenbasierte Route mit dekodierten Koordinaten
                                console.log(`[ROUTE-VIS] ‚úÖ Dekodierung erfolgreich: ${decodedCoordinates.length} Koordinaten-Punkte`);
                                console.log(`[ROUTE-VIS] Erste Koordinate: [${decodedCoordinates[0][0]}, ${decodedCoordinates[0][1]}]`);
                                console.log(`[ROUTE-VIS] Letzte Koordinate: [${decodedCoordinates[decodedCoordinates.length-1][0]}, ${decodedCoordinates[decodedCoordinates.length-1][1]}]`);
                                polyline = L.polyline(decodedCoordinates, {
                                    color: routeColor || '#2196F3',
                                    weight: 4,
                                    opacity: 0.7
                                });
                                console.log(`[ROUTE-VIS] OSRM-Route gezeichnet: ${decodedCoordinates.length} Punkte`);
                            } else {
                                console.warn(`[ROUTE-VIS] ‚ùå Dekodierung gab keine Koordinaten zur√ºck`);
                                // Fallback: Gerade Linie wenn Dekodierung fehlschl√§gt
                                console.warn(`[ROUTE-VIS] Polyline-Dekodierung fehlgeschlagen, verwende gerade Linie`);
                                polyline = L.polyline(
                                    [[route.from.lat, route.from.lon], [route.to.lat, route.to.lon]],
                                    {
                                        color: routeColor || '#2196F3',
                                        weight: 3,
                                        opacity: 0.6,
                                        dashArray: '10, 5'  // Gestrichelt f√ºr Fallback
                                    }
                                );
                            }
                        } catch (error) {
                            console.error('[ROUTE-VIS] Fehler beim Dekodieren der Polyline:', error);
                            console.error('[ROUTE-VIS] Error details:', error.message, error.stack);
                            // Fallback: Gerade Linie
                            polyline = L.polyline(
                                [[route.from.lat, route.from.lon], [route.to.lat, route.to.lon]],
                                {
                                    color: routeColor || '#2196F3',
                                    weight: 3,
                                    opacity: 0.6,
                                    dashArray: '10, 5'  // Gestrichelt f√ºr Fallback
                                }
                            );
                        }
                    } else {
                        // Keine Geometry ‚Üí gerade Linie (Fallback)
                        console.warn(`[ROUTE-VIS] ‚ö†Ô∏è Keine Geometrie f√ºr Route ${route.from.name || 'Start'} ‚Üí ${route.to.name || 'Ziel'}. Source: ${route.source || 'unbekannt'}. Verwende gerade Linie.`);
                        polyline = L.polyline(
                            [[route.from.lat, route.from.lon], [route.to.lat, route.to.lon]],
                            {
                                color: routeColor || '#2196F3',
                                weight: 3,
                                opacity: 0.6,
                                dashArray: '10, 5'  // Gestrichelt f√ºr Fallback
                            }
                        );
                    }

                    // Popup mit Distanz und Dauer
                    const popupText = `
                        <strong>${route.from.name || 'Start'}</strong> ‚Üí <strong>${route.to.name || 'Ziel'}</strong><br>
                        Distanz: ${route.distance_km.toFixed(1)} km<br>
                        Dauer: ${route.duration_minutes.toFixed(1)} Min
                    `;
                    polyline.bindPopup(popupText);
                    polyline.addTo(map);
                    tourRouteLines.push(polyline);
                }

                console.log(`[ROUTE-VIS] ${routes.length} Routen-Segmente gezeichnet`);
            } catch (error) {
                console.error('Fehler beim Zeichnen der Routen:', error);
                // Fallback: Gerade Linien (inkl. Depot)
                drawStraightLines(customersWithCoords, routeColor, includeDepot);
            }
        }

        // Fallback: Zeichne gerade Linien zwischen Stopps (inkl. Depot)
        function drawStraightLines(customersWithCoords, routeColor, includeDepot = false) {
            if (!map || customersWithCoords.length < 1) {
                return;
            }

            // Depot-Koordinaten
            const depotLat = 51.01127;  // FAMO Depot (Gittersee)
            const depotLon = 13.70161;

            // Wenn includeDepot, f√ºge Depot am Anfang und Ende hinzu
            let points = customersWithCoords.map(c => ({
                lat: parseFloat(c.latitude),
                lon: parseFloat(c.longitude)
            }));

            if (includeDepot) {
                points = [
                    { lat: depotLat, lon: depotLon },
                    ...points,
                    { lat: depotLat, lon: depotLon }
                ];
            }

            if (points.length < 2) {
                return;
            }

            for (let i = 0; i < points.length - 1; i++) {
                const from = points[i];
                const to = points[i + 1];
                
                const fromLat = from.lat;
                const fromLon = from.lon;
                const toLat = to.lat;
                const toLon = to.lon;

                if (isNaN(fromLat) || isNaN(fromLon) || isNaN(toLat) || isNaN(toLon)) {
                    continue;
                }

                const polyline = L.polyline(
                    [[fromLat, fromLon], [toLat, toLon]],
                    {
                        color: routeColor || '#2196F3',
                        weight: 3,
                        opacity: 0.6,
                        dashArray: '10, 5'  // Gestrichelt f√ºr Fallback
                    }
                );
                polyline.addTo(map);
                tourRouteLines.push(polyline);
            }
        }

        async function resolveCustomerCoordinates(customer) {
            const lat = parseFloat(customer.latitude);
            const lon = parseFloat(customer.longitude);
            if (!isNaN(lat) && !isNaN(lon)) {
                return [lat, lon];
            }

            const key = `${customer.street || ''}|${customer.postal_code || ''}|${customer.city || ''}`;
            if (geoCache[key]) {
                return geoCache[key];
            }

            const parts = [customer.street, customer.postal_code, customer.city].filter(Boolean);
            if (!parts.length) {
                return null;
            }

            const address = encodeURIComponent(parts.join(', '));
            try {
                const response = await fetch(`/api/geocode?address=${address}`);
                if (!response.ok) {
                    return null;
                }
                const result = await response.json();
                if (result.lat !== undefined && result.lon !== undefined) {
                    const coords = [parseFloat(result.lat), parseFloat(result.lon)];
                    if (!isNaN(coords[0]) && !isNaN(coords[1])) {
                        geoCache[key] = coords;
                        customer.latitude = coords[0];
                        customer.longitude = coords[1];
                        return coords;
                    }
                }
            } catch (error) {
                console.warn('Geocoding fehlgeschlagen:', error);
            }

            return null;
        }
        
        // KI-Status aktualisieren
        function updateAIStatus(message, type = 'info') {
            const statusField = document.getElementById('aiStatusField');
            const statusText = document.getElementById('aiStatusText');
            
            if (!statusField || !statusText) return;
            
            // Typ-basierte Klassen
            statusField.className = 'alert mb-3';
            if (type === 'success') {
                statusField.classList.add('alert-success');
            } else if (type === 'warning') {
                statusField.classList.add('alert-warning');
            } else if (type === 'error' || type === 'danger') {
                statusField.classList.add('alert-danger');
            } else {
                statusField.classList.add('alert-info');
            }
            
            statusText.textContent = message;
        }
        
        // Automatische Optimierung f√ºr Touren mit > 4 Kunden
        async function autoOptimizeLargeTours(tours) {
            const MIN_CUSTOMERS_FOR_OPTIMIZATION = 4;
            const toursToOptimize = tours.filter(t => {
                const stops = t.stops || [];
                return stops.length > MIN_CUSTOMERS_FOR_OPTIMIZATION;
            });
            
            if (toursToOptimize.length === 0) {
                console.log('[AUTO-OPTIMIZE] Keine Touren mit > 4 Kunden gefunden');
                return;
            }
            
            console.log(`[AUTO-OPTIMIZE] Starte automatische Optimierung f√ºr ${toursToOptimize.length} Tour(en) mit > ${MIN_CUSTOMERS_FOR_OPTIMIZATION} Kunden`);
            updateAIStatus(`Automatische Optimierung: ${toursToOptimize.length} Tour(en) mit > ${MIN_CUSTOMERS_FOR_OPTIMIZATION} Kunden`, 'info');
            
            let optimizedCount = 0;
            let errorCount = 0;
            
            for (const tour of toursToOptimize) {
                try {
                    const stops = tour.stops || [];
                    const stopsWithCoords = stops.filter(s => s.lat && s.lon);
                    
                    if (stopsWithCoords.length === 0) {
                        console.warn(`[AUTO-OPTIMIZE] Tour ${tour.tour_id}: Keine Stopps mit Koordinaten`);
                        continue;
                    }
                    
                    const stopsForAPI = stopsWithCoords.map(s => ({
                        customer_number: s.order_id || s.customer_number || '',
                        name: s.customer || s.name || 'Unbekannt',
                        address: s.address || '',
                        lat: s.lat,
                        lon: s.lon,
                        street: s.street || '',
                        postal_code: s.postal_code || '',
                        city: s.city || '',
                        bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)  // BAR-Flag √ºbertragen
                    }));
                    
                    const response = await fetch('/api/tour/optimize', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            tour_id: tour.tour_id || 'Tour',
                            is_bar_tour: tour.is_bar_tour || false,  // WICHTIG: BAR-Status mitgeben
                            stops: stopsForAPI
                        })
                    });
                    
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const responseText = await response.text();
                    
                    if (response.ok) {
                        let result;
                        try {
                            result = JSON.parse(responseText);
                        } catch (e) {
                            console.error(`[AUTO-OPTIMIZE] JSON Parsing Fehler f√ºr Tour ${tour.tour_id}:`, e, 'Rohe Antwort:', responseText);
                            errorCount++;
                            continue;
                        }
                        if (result.success !== false) {
                            // WICHTIG: Aktualisiere Tour mit optimierter Reihenfolge
                            // Stelle sicher, dass sowohl stops als auch customers aktualisiert werden
                            const optimizedStops = result.optimized_stops || tour.stops;
                            
                            // Aktualisiere stops
                            tour.stops = optimizedStops;
                            
                            // Aktualisiere customers (f√ºr Frontend-Kompatibilit√§t)
                            tour.customers = optimizedStops.map(s => ({
                                customer_number: s.order_id || s.customer_number || '',
                                name: s.customer || s.name || 'Unbekannt',
                                street: s.street || '',
                                postal_code: s.postal_code || '',
                                city: s.city || '',
                                latitude: s.lat,
                                longitude: s.lon,
                                bar_flag: s.bar_flag || false,
                                address: s.address || (() => {
                                    const parts = [s.street, s.postal_code, s.city].filter(Boolean);
                                    return parts.join(', ') || '';
                                })(),
                                has_coordinates: !!(s.lat && s.lon)
                            }));
                            
                            tour.optimized = true;
                            tour.estimated_total_time = result.estimated_total_time_minutes;
                            tour.estimated_driving_time_minutes = result.estimated_driving_time_minutes;
                            tour.estimated_service_time_minutes = result.estimated_service_time_minutes;
                            tour.estimated_return_time_minutes = result.estimated_return_time_minutes || 0;
                            tour.reasoning = result.reasoning;
                            tour.optimization_method = result.optimization_method;
                            
                            optimizedCount++;
                            console.log(`[AUTO-OPTIMIZE] Tour ${tour.tour_id} optimiert (${result.estimated_total_time_minutes} Min, ${optimizedStops.length} Stopps)`);
                        }
                    } else {
                        // responseText wurde bereits gelesen
                        let errorText = responseText;
                        try {
                            const errorData = JSON.parse(responseText);
                            errorText = errorData.error || errorData.detail || responseText;
                        } catch (e) {
                            // Kein JSON, verwende rohen Text
                        }
                        console.warn(`[AUTO-OPTIMIZE] Tour ${tour.tour_id}: API-Fehler (${response.status}): ${errorText.substring(0, 100)}`);
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`[AUTO-OPTIMIZE] Fehler bei Tour ${tour.tour_id}:`, error);
                    errorCount++;
                }
            }
            
            if (optimizedCount > 0) {
                console.log(`[AUTO-OPTIMIZE] ${optimizedCount} Tour(en) optimiert, rendere UI neu...`);
                updateAIStatus(`Automatische Optimierung abgeschlossen: ${optimizedCount} Tour(en) optimiert${errorCount > 0 ? `, ${errorCount} Fehler` : ''}`, 'success');
                
                // WICHTIG: Stelle sicher, dass workflowResult vorhanden ist und aktualisiert wird
                if (workflowResult && workflowResult.tours) {
                    // Touren neu rendern mit optimierten Daten
                    // Dies aktualisiert allTourCustomers und die Tour-Liste
                    renderToursFromMatch(workflowResult);
                    
                    // State speichern
                    saveToursToStorage();
                    
                    console.log('[AUTO-OPTIMIZE] UI erfolgreich aktualisiert');
                } else {
                    console.warn('[AUTO-OPTIMIZE] workflowResult nicht verf√ºgbar, kann UI nicht aktualisieren');
                }
            } else if (errorCount > 0) {
                updateAIStatus(`Automatische Optimierung: ${errorCount} Fehler`, 'warning');
            } else {
                console.log('[AUTO-OPTIMIZE] Keine Touren optimiert (alle bereits optimal oder < 5 Kunden)');
            }
        }
        
        // Optimierung f√ºr einzelne Tour (von Zahnrad-Button)
        async function optimizeTour(tourKey, tourName) {
            const tourData = allTourCustomers[tourKey];
            if (!tourData || !tourData.customers || tourData.customers.length === 0) {
                alert('Keine Kunden f√ºr diese Tour gefunden.');
                return;
            }
            
            const customers = tourData.customers;
            const stopsWithCoords = customers.filter(c => hasCoordinates(c));
            
            if (stopsWithCoords.length === 0) {
                alert('Keine Kunden mit Koordinaten gefunden. Optimierung nicht m√∂glich.');
                return;
            }
            
            // Pr√ºfe ob Tour eine BAR-Tour ist
            const isBarTour = tourData.is_bar_tour || tourName.toUpperCase().includes('BAR');
            
            const stopsForAPI = stopsWithCoords.map(c => ({
                customer_number: c.customer_number || '',
                name: c.name || 'Unbekannt',
                address: c.address || c.resolved_address || '',
                lat: parseFloat(c.latitude),
                lon: parseFloat(c.longitude),
                street: c.street || '',
                postal_code: c.postal_code || '',
                city: c.city || '',
                bar_flag: c.bar_flag !== undefined ? c.bar_flag : isBarTour  // BAR-Flag √ºbertragen
            }));
            
            // Zeige Loading-Modal
            const modal = document.getElementById('optimizationModal');
            const modalBody = modal.querySelector('.modal-body');
            modalBody.innerHTML = '<div class="text-center"><i class="fas fa-spinner fa-spin fa-2x"></i><br>Optimierung l√§uft...</div>';
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
            
            try {
                const response = await fetch('/api/tour/optimize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tour_id: tourName,
                        is_bar_tour: isBarTour,  // WICHTIG: BAR-Status mitgeben
                        stops: stopsForAPI
                    })
                });
                
                // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                const responseText = await response.text();
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${responseText}`);
                }
                
                let result;
                try {
                    result = JSON.parse(responseText);
                } catch (e) {
                    console.error('[OPTIMIZE] JSON Parsing Fehler:', e, 'Rohe Antwort:', responseText);
                    throw new Error(`Ung√ºltige Server-Antwort: ${responseText.substring(0, 100)}...`);
                }
                
                if (result.success === false) {
                    throw new Error(result.error || 'Optimierung fehlgeschlagen');
                }
                
                // Zeige Ergebnisse im Modal
                modalBody.innerHTML = `
                    <h6>Tour: ${tourName}</h6>
                    <p><strong>Optimierungsmethode:</strong> ${result.optimization_method || 'Unknown'}</p>
                    <p><strong>Gesch√§tzte Fahrzeit:</strong> ${result.estimated_driving_time_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    <p><strong>Service-Zeit:</strong> ${result.estimated_service_time_minutes || 0} Minuten (2 Min/Kunde √ó ${stopsWithCoords.length})</p>
                    <p><strong>Gesamtzeit:</strong> ${result.estimated_total_time_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    <p><strong>R√ºckfahrt zum Depot:</strong> ${result.estimated_return_time_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    <p><strong>Gesamt inkl. R√ºckfahrt:</strong> ${result.estimated_total_with_return_minutes?.toFixed(1) || 'N/A'} Minuten</p>
                    ${result.estimated_time_exceeds_one_hour ? '<p class="text-danger"><strong>‚ö†Ô∏è WARNUNG: Tour √ºberschreitet 60 Minuten!</strong></p>' : ''}
                    ${result.warnings && result.warnings.length > 0 ? `<div class="alert alert-warning"><strong>Warnungen:</strong><ul>${result.warnings.map(w => `<li>${w}</li>`).join('')}</ul></div>` : ''}
                    <div class="mt-3">
                        <button class="btn btn-primary" onclick="applyOptimization('${tourKey}', ${JSON.stringify(result.optimized_stops).replace(/"/g, '&quot;')})">
                            Optimierte Route √ºbernehmen
                        </button>
                    </div>
                `;
            } catch (error) {
                console.error('Optimierung Fehler:', error);
                modalBody.innerHTML = `<div class="alert alert-danger">Fehler: ${error.message}</div>`;
            }
        }
        
        // Wende optimierte Route an
        function applyOptimization(tourKey, optimizedStops) {
            const tourData = allTourCustomers[tourKey];
            if (!tourData) return;
            
            // Erstelle Mapping von customer_number zu optimiertem Stop
            const stopMap = new Map();
            optimizedStops.forEach((stop, idx) => {
                const key = stop.customer_number || stop.name;
                stopMap.set(key, { ...stop, optimized_index: idx });
            });
            
            // Sortiere Kunden nach optimierter Reihenfolge
            tourData.customers = tourData.customers.map(c => {
                const key = c.customer_number || c.name;
                const optimized = stopMap.get(key);
                return optimized ? { ...c, ...optimized } : c;
            }).sort((a, b) => {
                const aIdx = a.optimized_index ?? 9999;
                const bIdx = b.optimized_index ?? 9999;
                return aIdx - bIdx;
            });
            
            // Schlie√üe Modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('optimizationModal'));
            if (modal) modal.hide();
            
            // Aktualisiere Anzeige
            renderTourDetails(tourData);
            updateAIStatus(`Tour optimiert: Reihenfolge wurde aktualisiert`, 'success');
            
            // Speichere State
            saveToursToStorage();
        }
        
        // Sub-Routen Generator: Generiert Sub-Touren aus W-Touren
        async function generateSubRoutes() {
            const btn = document.getElementById('btnGenerateSubRoutes');
            const status = document.getElementById('subRouteStatus');
            
            if (!workflowResult || !workflowResult.tours || workflowResult.tours.length === 0) {
                updateAIStatus('Bitte zuerst eine CSV-Datei hochladen und den Workflow ausf√ºhren.', 'warning');
                alert('Bitte zuerst eine CSV-Datei hochladen und den Workflow ausf√ºhren.');
                return;
            }
            
            // Finde alle Touren, die optimiert werden m√ºssen
            // Regel: Touren mit > 4 Kunden (inkl. W-Touren und andere gro√üe Touren wie PIR, BZ, CB, etc.)
            const MIN_CUSTOMERS_FOR_SUB_ROUTES = 4;
            
            const toursToOptimize = workflowResult.tours.filter(t => {
                const stops = t.stops || [];
                const customerCount = stops.length;
                
                // W-Touren immer einschlie√üen
                const tourId = t.tour_id || '';
                const isWTour = /^W-\d+\.\d+/.test(tourId);
                
                // Oder andere Touren mit > 4 Kunden
                const isLargeTour = customerCount > MIN_CUSTOMERS_FOR_SUB_ROUTES;
                
                return isWTour || isLargeTour;
            });
            
            if (toursToOptimize.length === 0) {
                updateAIStatus(`Keine Touren zum Optimieren gefunden. (W-Touren oder Touren mit > ${MIN_CUSTOMERS_FOR_SUB_ROUTES} Kunden)`, 'warning');
                alert(`Keine Touren zum Optimieren gefunden.\n\nGesucht werden:\n- W-Touren (z.B. W-07.00, W-09.00)\n- Oder Touren mit mehr als ${MIN_CUSTOMERS_FOR_SUB_ROUTES} Kunden`);
                return;
            }
            
            const wTours = toursToOptimize.filter(t => {
                const tourId = t.tour_id || '';
                return /^W-\d+\.\d+/.test(tourId);
            });
            
            console.log(`[SUB-ROUTES] Gefunden: ${toursToOptimize.length} Tour(en) zum Optimieren (${wTours.length} W-Touren, ${toursToOptimize.length - wTours.length} andere gro√üe Touren)`);
            
            // UI: Zeige Fortschritt
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> L√§uft...';
            status.style.display = 'block';
            status.className = 'small text-info mb-3';
            status.innerHTML = `<i class="fas fa-info-circle"></i> Starte Optimierung f√ºr ${toursToOptimize.length} Tour(en)...`;
            
            // Progress Bar initialisieren
            const progressContainer = document.getElementById('subRouteProgress');
            const progressBar = document.getElementById('subRouteProgressBar');
            const progressText = document.getElementById('subRouteProgressText');
            const progressDetails = document.getElementById('subRouteProgressDetails');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);
            progressText.textContent = '0%';
            progressDetails.textContent = `Starte Optimierung...`;
            
            updateAIStatus(`Starte Optimierung f√ºr ${toursToOptimize.length} Tour(en) (${wTours.length} W-Touren)...`, 'info');
            
            try {
                // F√ºhre Optimierung f√ºr jede Tour durch
                const allSubRoutes = [];
                let successCount = 0;
                let errorCount = 0;
                
                for (let tourIndex = 0; tourIndex < toursToOptimize.length; tourIndex++) {
                    const tour = toursToOptimize[tourIndex];
                    const currentTourNum = tourIndex + 1;
                    const totalTours = toursToOptimize.length;
                    
                    // Aktualisiere Progress Bar
                    const progressPercent = Math.round((tourIndex / totalTours) * 100);
                    progressBar.style.width = `${progressPercent}%`;
                    progressBar.setAttribute('aria-valuenow', progressPercent);
                    progressText.textContent = `${progressPercent}%`;
                    progressDetails.textContent = `Verarbeite Tour ${currentTourNum} von ${totalTours}: ${tour.tour_id || 'Unbekannt'}`;
                    
                    const stops = tour.stops || [];
                    if (stops.length === 0) {
                        // √úberspringe, aber aktualisiere Fortschritt
                        continue;
                    }
                    
                    // Bereite Stopps f√ºr API vor (inkl. BAR-Flag!)
                    const stopsForAPI = stops.map(s => ({
                        customer_number: s.order_id || s.customer_number || '',
                        name: s.customer || s.name || 'Unbekannt',
                        address: s.address || '',
                        lat: s.lat,
                        lon: s.lon,
                        street: s.street || '',
                        postal_code: s.postal_code || '',
                        city: s.city || '',
                        bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false) // BAR-Flag √ºbertragen!
                    }));
                    
                    // Filtere Stopps mit Koordinaten
                    const stopsWithCoords = stopsForAPI.filter(s => s.lat && s.lon);
                    
                    if (stopsWithCoords.length === 0) {
                        console.warn(`[SUB-ROUTES] Tour ${tour.tour_id}: Keine Stopps mit Koordinaten (${stopsForAPI.length} ohne Koords)`);
                        updateAIStatus(`Warnung: Tour ${tour.tour_id} hat keine Stopps mit Koordinaten`, 'warning');
                        continue;
                    }
                    
                    console.log(`[SUB-ROUTES] Verarbeite Tour ${tour.tour_id} (${currentTourNum}/${totalTours}): ${stopsWithCoords.length}/${stopsForAPI.length} Stopps mit Koordinaten`);
                    
                    // API-Call f√ºr diese Tour
                    console.log(`[SUB-ROUTES] Sende Anfrage f√ºr Tour ${tour.tour_id} mit ${stopsWithCoords.length} Stopps:`, {
                        tour_id: tour.tour_id,
                        stops_sample: stopsWithCoords.slice(0, 2).map(s => ({
                            name: s.name,
                            lat: s.lat,
                            lon: s.lon,
                            has_coords: !!(s.lat && s.lon)
                        }))
                    });
                    
                    let response;
                    try {
                        response = await fetch('/api/tour/optimize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                tour_id: tour.tour_id || 'W-Tour',
                                is_bar_tour: tour.is_bar_tour || false,  // WICHTIG: BAR-Status mitgeben
                                stops: stopsWithCoords
                            })
                        });
                    } catch (fetch_error) {
                        console.error(`[SUB-ROUTES] Fetch-Fehler f√ºr Tour ${tour.tour_id}:`, fetch_error);
                        updateAIStatus(`Netzwerk-Fehler bei Tour ${tour.tour_id}: ${fetch_error.message}`, 'warning');
                        errorCount++;
                        continue;
                    }
                    
                    // Hole Trace-ID aus Response-Header
                    const traceId = response.headers.get('X-Request-ID') || 'unknown';
                    
                    // WICHTIG: Response-Text zuerst lesen (kann nur einmal gelesen werden)
                    const responseText = await response.text();
                    
                    if (!response.ok) {
                        let errorText = responseText;
                        let errorDetail = null;
                        try {
                            errorDetail = JSON.parse(responseText);
                            errorText = errorDetail.error || errorDetail.detail || responseText;
                        } catch (e) {
                            // Nicht JSON, verwende Text
                        }
                        
                        const errorInfo = {
                            status: response.status,
                            statusText: response.statusText,
                            error: errorText.substring(0, 500),
                            errorDetail: errorDetail,
                            trace_id: errorDetail?.trace_id || traceId,
                            stopsCount: stopsWithCoords.length,
                            tour_id: tour.tour_id,
                            stops_sample: stopsWithCoords.slice(0, 3).map(s => ({
                                name: s.name,
                                lat: s.lat,
                                lon: s.lon,
                                has_coords: !!(s.lat && s.lon)
                            }))
                        };
                        
                        console.error(`[SUB-ROUTES] API-Fehler f√ºr Tour ${tour.tour_id}:`, errorInfo);
                        
                        // Detaillierte Fehlermeldung anzeigen (mit Trace-ID)
                        const detailMsg = errorDetail?.error_detail || errorDetail?.detail || errorDetail?.error || errorText.substring(0, 100);
                        const traceIdMsg = errorInfo.trace_id ? ` (Trace: ${errorInfo.trace_id})` : '';
                        updateAIStatus(`Fehler bei Tour ${tour.tour_id}: ${response.status} - ${detailMsg}${traceIdMsg}`, 'warning');
                        
                        // Zeige Toast mit Trace-ID (falls verf√ºgbar)
                        if (errorInfo.trace_id && errorInfo.trace_id !== 'unknown') {
                            console.warn(`[SUB-ROUTES] Serverfehler ‚Äì Trace-ID: ${errorInfo.trace_id}`);
                        }
                        
                        errorCount++;
                        continue;
                    }
                    
                    // responseText wurde bereits gelesen
                    let result;
                    try {
                        result = JSON.parse(responseText);
                        console.log(`[SUB-ROUTES] Tour ${tour.tour_id} optimiert:`, result);
                    } catch (e) {
                        console.error(`[SUB-ROUTES] JSON-Parse-Fehler f√ºr Tour ${tour.tour_id}:`, e, 'Rohe Antwort:', responseText);
                        updateAIStatus(`Parse-Fehler bei Tour ${tour.tour_id}`, 'warning');
                        errorCount++;
                        continue;
                    }
                    
                    // Pr√ºfe ob Erfolg
                    if (result.success === false) {
                        console.error(`[SUB-ROUTES] Optimierung fehlgeschlagen f√ºr Tour ${tour.tour_id}:`, result.error);
                        updateAIStatus(`Fehler bei Tour ${tour.tour_id}: ${result.error || 'Optimierung fehlgeschlagen'}`, 'warning');
                        errorCount++;
                        continue;
                    }
                    
                    if (!result.optimized_stops || result.optimized_stops.length === 0) {
                        console.warn(`[SUB-ROUTES] Tour ${tour.tour_id}: Keine optimierten Stopps zur√ºckgegeben`);
                        updateAIStatus(`Warnung: Tour ${tour.tour_id} lieferte keine optimierten Stopps`, 'warning');
                        errorCount++;
                        continue;
                    }
                    
                    // WICHTIG: Pr√ºfe OHNE R√ºckfahrt (R√ºckfahrt z√§hlt nicht in die 60-65 Min Regel)
                    // Regeln: Fahrzeit + Servicezeit ‚â§ 60-65 Minuten (ohne R√ºckfahrt)
                    const timeWithoutReturn = (result.estimated_driving_time_minutes || 0) + (result.estimated_service_time_minutes || 0);
                    const MAX_TIME_WITHOUT_RETURN = 65; // Minuten (inkl. Servicezeit, OHNE R√ºckfahrt!)
                    
                    // HINWEIS: Das Backend sollte bereits beim initialen Clustering die Touren korrekt aufteilen
                    // Diese Splitting-Logik ist nur ein Fallback f√ºr den Fall, dass das Backend-Clustering versagt hat
                    // Wenn Tour > 65 Minuten ‚Üí sollte eigentlich beim Clustering bereits in mehrere Touren (A, B, C) aufgeteilt worden sein
                    if (timeWithoutReturn > MAX_TIME_WITHOUT_RETURN) {
                        console.warn(`[SUB-ROUTES] WARNUNG: Tour ${tour.tour_id} √ºberschreitet Zeit-Constraint: ${timeWithoutReturn.toFixed(1)} Min > ${MAX_TIME_WITHOUT_RETURN} Min`);
                        console.warn(`[SUB-ROUTES] Diese Tour sollte beim initialen Clustering bereits in mehrere Touren (A, B, C) aufgeteilt worden sein!`);
                        console.warn(`[SUB-ROUTES] Verwende Fallback-Splitting als Notl√∂sung...`);
                        
                        // Fallback: Splitte in Sub-Touren (nur als Notl√∂sung)
                        const subTours = splitTourIntoSubRoutes(tour, result);
                        if (subTours && subTours.length > 0) {
                            allSubRoutes.push(...subTours);
                            console.log(`[SUB-ROUTES] Tour ${tour.tour_id} in ${subTours.length} Sub-Routen aufgeteilt`);
                            successCount++;
                        } else {
                            console.warn(`[SUB-ROUTES] Tour ${tour.tour_id}: splitTourIntoSubRoutes gab keine Routen zur√ºck`);
                            // Fallback: Als einzelne Route behandeln - WICHTIG: R√ºckfahrt zum Depot + BAR-Flags
                            const returnTime = result.estimated_return_time_minutes || 0;
                            const totalTimeWithReturn = (result.estimated_total_time_minutes || 0) + returnTime;
                            
                            // WICHTIG: Stelle sicher, dass BAR-Flags aus urspr√ºnglichen Stopps erhalten bleiben
                            const optimizedStopsWithBarFlags = result.optimized_stops.map(optStop => {
                                // Finde urspr√ºnglichen Stop mit gleicher customer_number oder name
                                const originalStop = stops.find(s => 
                                    (s.customer_number || s.order_id) === (optStop.customer_number || optStop.order_id) ||
                                    (s.customer || s.name) === (optStop.customer || optStop.name)
                                );
                                
                                // BAR-Flag: Erst vom optimierten Stop, dann vom urspr√ºnglichen Stop, dann Tour-Level
                                const barFlag = optStop.bar_flag !== undefined 
                                    ? !!optStop.bar_flag 
                                    : (originalStop && originalStop.bar_flag !== undefined 
                                        ? !!originalStop.bar_flag 
                                        : (tour.is_bar_tour || false));
                                
                                return {
                                    ...optStop,
                                    bar_flag: barFlag  // WICHTIG: BAR-Flag explizit setzen
                                };
                            });
                            
                            allSubRoutes.push({
                                tour_id: tour.tour_id,
                                sub_route: 'A',
                                stops: optimizedStopsWithBarFlags,  // WICHTIG: Stopps mit BAR-Flags
                                driving_time: result.estimated_driving_time_minutes,
                                service_time: result.estimated_service_time_minutes,
                                return_time: returnTime,  // WICHTIG: R√ºckfahrt zum Depot
                                total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                                reasoning: result.reasoning || `Fallback Route (Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                            });
                            successCount++;
                        }
                    } else {
                        // Tour passt in eine Route - WICHTIG: R√ºckfahrt zum Depot ber√ºcksichtigen + BAR-Flags
                        const returnTime = result.estimated_return_time_minutes || 0;
                        const totalTimeWithReturn = (result.estimated_total_time_minutes || 0) + returnTime;
                        
                        // WICHTIG: Stelle sicher, dass BAR-Flags aus urspr√ºnglichen Stopps erhalten bleiben
                        const optimizedStopsWithBarFlags = result.optimized_stops.map(optStop => {
                            // Finde urspr√ºnglichen Stop mit gleicher customer_number oder name
                            const originalStop = stops.find(s => 
                                (s.customer_number || s.order_id) === (optStop.customer_number || optStop.order_id) ||
                                (s.customer || s.name) === (optStop.customer || optStop.name)
                            );
                            
                            // BAR-Flag: Erst vom optimierten Stop, dann vom urspr√ºnglichen Stop, dann Tour-Level
                            const barFlag = optStop.bar_flag !== undefined 
                                ? !!optStop.bar_flag 
                                : (originalStop && originalStop.bar_flag !== undefined 
                                    ? !!originalStop.bar_flag 
                                    : (tour.is_bar_tour || false));
                            
                            return {
                                ...optStop,
                                bar_flag: barFlag  // WICHTIG: BAR-Flag explizit setzen
                            };
                        });
                        
                        allSubRoutes.push({
                            tour_id: tour.tour_id,
                            sub_route: 'A',
                            stops: optimizedStopsWithBarFlags,  // WICHTIG: Stopps mit BAR-Flags
                            driving_time: result.estimated_driving_time_minutes,
                            service_time: result.estimated_service_time_minutes,
                            return_time: returnTime,  // WICHTIG: R√ºckfahrt zum Depot
                            total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                            reasoning: result.reasoning || `Tour passt in eine Route (Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                        });
                        console.log(`[SUB-ROUTES] Tour ${tour.tour_id} passt in eine Route: ${result.estimated_driving_time_minutes.toFixed(1)} Min Fahrt + ${result.estimated_service_time_minutes.toFixed(1)} Min Service + ${returnTime.toFixed(1)} Min R√ºckfahrt = ${totalTimeWithReturn.toFixed(1)} Min gesamt`);
                        successCount++;
                    }
                    
                    // Aktualisiere Progress Bar nach erfolgreicher Verarbeitung
                    const progressPercentUpdate = Math.round(((tourIndex + 1) / totalTours) * 100);
                    progressBar.style.width = `${progressPercentUpdate}%`;
                    progressBar.setAttribute('aria-valuenow', progressPercentUpdate);
                    progressText.textContent = `${progressPercentUpdate}%`;
                    progressDetails.textContent = `Abgeschlossen: ${successCount} erfolgreich, ${errorCount} Fehler`;
                }
                
                console.log(`[SUB-ROUTES] Verarbeitung abgeschlossen: ${successCount} erfolgreich, ${errorCount} Fehler`);
                
                // Zeige Ergebnisse
                console.log(`[SUB-ROUTES] Zusammenfassung: ${successCount} erfolgreich, ${errorCount} Fehler, ${allSubRoutes.length} Routen generiert`);
                
                if (allSubRoutes.length > 0) {
                    status.innerHTML = `<i class="fas fa-check text-success"></i> ${allSubRoutes.length} Route(n) generiert! (${successCount} erfolgreich, ${errorCount} Fehler)`;
                    status.className = 'small text-success mb-3';
                    updateAIStatus(`${allSubRoutes.length} Route(n) erfolgreich generiert (${successCount} Touren verarbeitet)`, 'success');
                    
                    // Aktualisiere Tour-Liste mit Sub-Routen
                    updateToursWithSubRoutes(allSubRoutes);
                    
                    // Optional: Navigiere zur erweiterten Ansicht
                    localStorage.setItem('subRoutes', JSON.stringify(allSubRoutes));
                } else {
                    // Detaillierte Fehlermeldung
                    let errorDetails = [];
                    if (toursToOptimize.length === 0) {
                        errorDetails.push('Keine Touren zum Optimieren gefunden');
                    } else {
                        const toursWithoutCoords = toursToOptimize.filter(t => {
                            const stops = t.stops || [];
                            return stops.filter(s => s.lat && s.lon).length === 0;
                        });
                        if (toursWithoutCoords.length > 0) {
                            errorDetails.push(`${toursWithoutCoords.length} Tour(en) ohne Koordinaten`);
                        }
                        const processedTours = toursToOptimize.length - toursWithoutCoords.length;
                        if (processedTours > 0 && allSubRoutes.length === 0) {
                            errorDetails.push(`API-Fehler bei allen ${processedTours} Tour(en)`);
                        }
                        if (errorCount > 0) {
                            errorDetails.push(`${errorCount} Tour(en) konnten nicht verarbeitet werden`);
                        }
                    }
                    
                    const errorMsg = errorDetails.length > 0 
                        ? `Keine Sub-Routen generiert: ${errorDetails.join(', ')}`
                        : 'Keine Sub-Routen konnten generiert werden.';
                    
                    progressDetails.textContent = `Fehler: ${errorMsg}`;
                    progressBar.classList.remove('progress-bar-animated');
                    progressBar.classList.add('bg-danger');
                    throw new Error(errorMsg);
                }
                
                // Progress Bar auf 100% setzen
                progressBar.style.width = '100%';
                progressBar.setAttribute('aria-valuenow', 100);
                progressText.textContent = '100%';
                progressBar.classList.remove('progress-bar-animated');
                if (allSubRoutes.length > 0) {
                    progressDetails.textContent = `Fertig! ${allSubRoutes.length} Route(n) generiert (${successCount} erfolgreich, ${errorCount} Fehler)`;
                }
                
            } catch (error) {
                console.error('Sub-Routen Generator Fehler:', error);
                status.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> Fehler: ${error.message}`;
                status.className = 'small text-danger mb-3';
                progressDetails.textContent = `Fehler: ${error.message}`;
                progressBar.classList.remove('progress-bar-animated');
                progressBar.classList.add('bg-danger');
                updateAIStatus(`Fehler: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-magic"></i> Routen optimieren (W-Touren & >4 Kunden)';
                // Progress Bar nach 3 Sekunden ausblenden (wenn erfolgreich) oder nach 5 Sekunden (bei Fehler)
                const progressContainer = document.getElementById('subRouteProgress');
                if (progressBar.classList.contains('bg-danger')) {
                    // Bei Fehler: Nach 5 Sekunden ausblenden
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 5000);
                } else {
                    // Bei Erfolg: Nach 3 Sekunden ausblenden
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 3000);
                }
            }
        }
        
        // Splitte Tour in Sub-Routen wenn > 60 Minuten
        function splitTourIntoSubRoutes(tour, optimizationResult) {
            console.log('[SPLIT] Starte Split f√ºr Tour:', tour.tour_id, optimizationResult);
            
            const stops = optimizationResult.optimized_stops || [];
            if (!stops || stops.length === 0) {
                console.warn('[SPLIT] Keine Stopps zum Aufteilen');
                return [];
            }
            
            // WICHTIG: Regeln - OHNE R√ºckfahrt z√§hlen!
            // Fahrzeit + Servicezeit ‚â§ 65 Minuten (ohne R√ºckfahrt)
            // R√ºckfahrt kommt DANACH und z√§hlt NICHT in die 60-65 Minuten!
            const maxTimePerRoute = 65; // Minuten (OHNE R√ºckfahrt zum Depot!)
            const serviceTimePerStop = 2; // Minuten
            const estimatedDrivingTime = optimizationResult.estimated_driving_time_minutes || 0;
            const estimatedServiceTime = optimizationResult.estimated_service_time_minutes || (stops.length * serviceTimePerStop);
            const estimatedReturnTime = optimizationResult.estimated_return_time_minutes || 0;
            
            // WICHTIG: Zeit OHNE R√ºckfahrt (f√ºr Pr√ºfung)
            const timeWithoutReturn = estimatedDrivingTime + estimatedServiceTime;
            // Gesamtzeit MIT R√ºckfahrt (nur f√ºr Anzeige)
            const totalTimeWithReturn = timeWithoutReturn + estimatedReturnTime;
            
            console.log(`[SPLIT] Tour ${tour.tour_id}: ${stops.length} Stopps`);
            console.log(`[SPLIT] Zeit OHNE R√ºckfahrt: ${timeWithoutReturn.toFixed(1)} Min (Fahrt: ${estimatedDrivingTime.toFixed(1)}, Service: ${estimatedServiceTime.toFixed(1)})`);
            console.log(`[SPLIT] R√ºckfahrt: ${estimatedReturnTime.toFixed(1)} Min ‚Üí Gesamt: ${totalTimeWithReturn.toFixed(1)} Min`);
            console.log(`[SPLIT] Regel: ${timeWithoutReturn.toFixed(1)} Min ‚â§ ${maxTimePerRoute} Min (ohne R√ºckfahrt)`);
            
            // WICHTIG: Pr√ºfe OHNE R√ºckfahrt (R√ºckfahrt z√§hlt nicht in die 60-65 Min Regel)
            if (timeWithoutReturn <= maxTimePerRoute) {
                console.log(`[SPLIT] Tour ${tour.tour_id} passt in eine Route (${timeWithoutReturn.toFixed(1)} Min ohne R√ºckfahrt <= ${maxTimePerRoute} Min)`);
                // WICHTIG: Stelle sicher, dass alle Stopps bar_flag haben
                const stopsWithBarFlags = stops.map(s => ({
                    ...s,
                    bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)
                }));
                return [{
                    tour_id: tour.tour_id,
                    sub_route: 'A',
                    stops: stopsWithBarFlags,  // Stopps mit BAR-Flags
                    driving_time: estimatedDrivingTime,
                    service_time: estimatedServiceTime,
                    return_time: estimatedReturnTime,  // WICHTIG: R√ºckfahrt zum Depot
                    total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                    reasoning: optimizationResult.reasoning || `Tour passt in eine Route (Depot ‚Üí ${stops.length} Kunden ‚Üí Depot, ${timeWithoutReturn.toFixed(1)} Min ohne R√ºckfahrt, ${totalTimeWithReturn.toFixed(1)} Min gesamt)`
                }];
            }
            
            // Berechne Anzahl der ben√∂tigten Routen (basierend auf Zeit OHNE R√ºckfahrt)
            const timePerStop = timeWithoutReturn / stops.length;
            const estimatedRoutes = Math.ceil(timeWithoutReturn / maxTimePerRoute);
            const stopsPerRoute = Math.ceil(stops.length / estimatedRoutes);
            
            console.log(`[SPLIT] Ben√∂tige ca. ${estimatedRoutes} Route(n), ${stopsPerRoute} Stopps pro Route`);
            
            const subRoutes = [];
            let currentRoute = [];
            let currentDrivingTime = 0;
            let currentServiceTime = 0;
            let routeLetter = 'A';
            
            // VARIABLE Splitting-Logik: Verwende tats√§chliche Distanzen zwischen Stopps
            // Entweder aus segment_distances (vom Backend) oder berechnet aus Koordinaten
            const segmentDistances = optimizationResult.segment_distances || [];
            // Depot-Koordinaten: FAMO Dresden (Gittersee)
            const depotCoords = optimizationResult.depot_coordinates || { lat: 51.01127, lon: 13.70161 };
            const speedKmh = 50.0; // Durchschnittsgeschwindigkeit
            
            // Hilfsfunktion: Haversine-Distanz berechnen
            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371.0; // Erdradius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            // Berechne Distanz/Fahrzeit zum n√§chsten Stop
            function getDriveTimeToNextStop(currentIndex, nextIndex) {
                // Versuche segment_distances zu verwenden (vom Backend)
                // segment_distances[0] = Depot ‚Üí Stop 0
                // segment_distances[1] = Stop 0 ‚Üí Stop 1
                // segment_distances[i] = Stop i-1 ‚Üí Stop i
                if (segmentDistances.length > 0) {
                    if (currentIndex === -1 && nextIndex === 0) {
                        // Depot ‚Üí Erster Stop
                        const segment = segmentDistances[0];
                        if (segment && segment.driving_time_minutes !== undefined) {
                            return segment.driving_time_minutes;
                        }
                    } else if (currentIndex >= 0 && nextIndex > currentIndex && nextIndex < segmentDistances.length) {
                        // Stop currentIndex ‚Üí Stop nextIndex (segment_distances[nextIndex] = Stop nextIndex-1 ‚Üí Stop nextIndex)
                        const segment = segmentDistances[nextIndex];
                        if (segment && segment.driving_time_minutes !== undefined) {
                            return segment.driving_time_minutes;
                        }
                    }
                }
                
                // Fallback: Berechne aus Koordinaten
                if (currentIndex >= 0 && currentIndex < stops.length && 
                    nextIndex >= 0 && nextIndex < stops.length) {
                    const currentStop = stops[currentIndex];
                    const nextStop = stops[nextIndex];
                    
                    if (currentStop.lat && currentStop.lon && nextStop.lat && nextStop.lon) {
                        // Distanz berechnen
                        let distanceKm;
                        if (currentIndex === -1 && depotCoords) {
                            // Vom Depot zum ersten Stop
                            distanceKm = haversineDistance(
                                depotCoords.lat, depotCoords.lon,
                                nextStop.lat, nextStop.lon
                            );
                        } else {
                            // Zwischen zwei Stopps
                            distanceKm = haversineDistance(
                                currentStop.lat, currentStop.lon,
                                nextStop.lat, nextStop.lon
                            );
                        }
                        
                        // Faktor 1.3 f√ºr Stadtverkehr (Betriebsordnung ¬ß4)
                        const adjustedDistance = distanceKm * 1.3;
                        const drivingTime = (adjustedDistance / speedKmh) * 60;
                        return drivingTime;
                    }
                }
                
                // Letzter Fallback: 5 Minuten
                return 5.0;
            }
            
            console.log(`[SPLIT] Verwende variable Distanzen (${segmentDistances.length} Segmente vom Backend oder berechnet aus Koordinaten)`);
            
            // WICHTIG: Stelle sicher, dass bar_flag von urspr√ºnglichen Tour-Stopps √ºbernommen wird
            // BAR-Kunden sind immer die gleichen Firmen/Experten, daher muss das Flag IMMER erhalten bleiben
            const originalStops = tour.stops || [];
            const stopBarFlagMap = new Map();
            
            // Erstelle Mapping mit mehreren Schl√ºsseln (customer_number, name, etc.)
            originalStops.forEach(os => {
                // Mehrere Keys f√ºr besseres Matching
                const keys = [
                    os.order_id || '',
                    os.customer_number || '',
                    os.name || '',
                    (os.customer || '').toLowerCase().trim(),
                    (os.name || '').toLowerCase().trim()
                ].filter(k => k);
                
                const barFlag = os.bar_flag !== undefined ? os.bar_flag : (tour.is_bar_tour || false);
                
                keys.forEach(key => {
                    if (key) {
                        stopBarFlagMap.set(key.toLowerCase(), barFlag);
                    }
                });
            });
            
            // Erweitere Stopps mit bar_flag - PRIORIT√ÑT: Original-Stopps haben h√∂chste Priorit√§t
            stops.forEach(stop => {
                // Pr√ºfe mehrere Keys
                const searchKeys = [
                    stop.customer_number || '',
                    stop.name || '',
                    (stop.name || '').toLowerCase().trim(),
                    (stop.customer_number || '').toString()
                ].filter(k => k).map(k => k.toLowerCase());
                
                let foundBarFlag = false;
                for (const key of searchKeys) {
                    if (stopBarFlagMap.has(key)) {
                        stop.bar_flag = stopBarFlagMap.get(key);
                        foundBarFlag = true;
                        console.log(`[SPLIT] BAR-Flag f√ºr ${stop.name || stop.customer_number} √ºbertragen: ${stop.bar_flag}`);
                        break;
                    }
                }
                
                // Falls nicht gefunden, aber Tour ist BAR-Tour: setze auf true
                if (!foundBarFlag && tour.is_bar_tour) {
                    stop.bar_flag = true;
                    console.log(`[SPLIT] BAR-Flag aus Tour-Level f√ºr ${stop.name || stop.customer_number} gesetzt: true`);
                }
                
                // Fallback: Falls Stop bereits bar_flag hat, behalte es
                if (stop.bar_flag === undefined) {
                    stop.bar_flag = false; // Explizit setzen
                }
            });
            
            for (let i = 0; i < stops.length; i++) {
                const stop = stops[i];
                
                // Berechne Fahrzeit zum n√§chsten Stop (variabel!)
                // WICHTIG: Alle Sub-Routen starten am Depot (FAMO Hauptlager)!
                let driveTime;
                if (currentRoute.length === 0) {
                    // Erster Stop einer neuen Route: IMMER vom Depot!
                    // Jede Sub-Route beginnt am Depot (FAMO Hauptlager)
                    driveTime = getDriveTimeToNextStop(-1, i);  // Depot ‚Üí Erster Stop
                    console.log(`[SPLIT] Neue Route ${routeLetter} startet am Depot ‚Üí Stop ${i+1} (${driveTime.toFixed(1)} Min)`);
                } else {
                    // Vom vorherigen Stop in dieser Route
                    const prevIndex = stops.indexOf(currentRoute[currentRoute.length - 1]);
                    driveTime = getDriveTimeToNextStop(prevIndex, i);
                }
                const serviceTime = serviceTimePerStop;
                const totalForStop = driveTime + serviceTime;
                
                // WICHTIG: Berechne R√ºckfahrt-Zeit zum Depot (vom aktuellen Stop, wenn hinzugef√ºgt)
                let returnTimeToDepot = 0;
                if (stop.lat && stop.lon && depotCoords) {
                    const returnDistanceKm = haversineDistance(
                        stop.lat, stop.lon,
                        depotCoords.lat, depotCoords.lon
                    ) * 1.3; // Faktor 1.3 f√ºr Stadtverkehr
                    returnTimeToDepot = (returnDistanceKm / speedKmh) * 60;
                }
                
                console.log(`[SPLIT] Stop ${i+1}: Fahrt ${driveTime.toFixed(1)} Min, Service ${serviceTime} Min, R√ºckfahrt ${returnTimeToDepot.toFixed(1)} Min`);
                
                // WICHTIG: Pr√ºfe OHNE R√ºckfahrt (R√ºckfahrt z√§hlt nicht in die 60-65 Min Regel!)
                // Regel: Fahrzeit + Servicezeit ‚â§ 65 Minuten (ohne R√ºckfahrt)
                const timeWithoutReturn = currentDrivingTime + currentServiceTime + totalForStop;
                const wouldExceed = timeWithoutReturn > maxTimePerRoute;
                
                if (!wouldExceed) {
                    // WICHTIG: Stelle sicher, dass bar_flag beim Hinzuf√ºgen erhalten bleibt
                    const stopWithBarFlag = {
                        ...stop,
                        bar_flag: stop.bar_flag !== undefined ? stop.bar_flag : (tour.is_bar_tour || false)
                    };
                    currentRoute.push(stopWithBarFlag);
                    currentDrivingTime += driveTime;
                    currentServiceTime += serviceTime;
                    console.log(`[SPLIT] Stop ${i+1} (BAR: ${stopWithBarFlag.bar_flag}) hinzugef√ºgt. Route ${routeLetter}: ${currentRoute.length} Stopps, ${(currentDrivingTime + currentServiceTime).toFixed(1)} Min`);
                } else {
                    // Aktuelle Route speichern und neue starten
                    if (currentRoute.length > 0) {
                        // Stelle sicher, dass alle Stopps in dieser Route bar_flag haben
                        const stopsWithBarFlags = currentRoute.map(s => ({
                            ...s,
                            bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)
                        }));
                        
                        // WICHTIG: Berechne R√ºckfahrt zum Depot vom letzten Stop
                        let returnTimeToDepot = 0;
                        const lastStop = currentRoute[currentRoute.length - 1];
                        if (lastStop.lat && lastStop.lon && depotCoords) {
                            const returnDistanceKm = haversineDistance(
                                lastStop.lat, lastStop.lon,
                                depotCoords.lat, depotCoords.lon
                            ) * 1.3; // Faktor 1.3 f√ºr Stadtverkehr
                            returnTimeToDepot = (returnDistanceKm / speedKmh) * 60;
                        }
                        
                        const totalTimeWithReturn = currentDrivingTime + currentServiceTime + returnTimeToDepot;
                        
                        subRoutes.push({
                            tour_id: tour.tour_id,
                            sub_route: routeLetter,
                            stops: stopsWithBarFlags,  // Stopps mit BAR-Flags
                            driving_time: currentDrivingTime,
                            service_time: currentServiceTime,
                            return_time: returnTimeToDepot,  // WICHTIG: R√ºckfahrt zum Depot
                            total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                            reasoning: `Automatisch gesplittet: ${routeLetter} (${currentRoute.length} Stopps, Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                        });
                        console.log(`[SPLIT] Route ${routeLetter} abgeschlossen: ${currentRoute.length} Stopps, ${currentDrivingTime.toFixed(1)} Min Fahrt + ${currentServiceTime.toFixed(1)} Min Service + ${returnTimeToDepot.toFixed(1)} Min R√ºckfahrt = ${totalTimeWithReturn.toFixed(1)} Min gesamt`);
                        routeLetter = String.fromCharCode(routeLetter.charCodeAt(0) + 1);
                    }
                    
                    // Neue Route starten - WICHTIG: BAR-Flag erhalten
                    const newStopWithBarFlag = {
                        ...stop,
                        bar_flag: stop.bar_flag !== undefined ? stop.bar_flag : (tour.is_bar_tour || false)
                    };
                    currentRoute = [newStopWithBarFlag];
                    currentDrivingTime = 0; // Keine Fahrzeit zum ersten Stop (wird erst beim n√§chsten Stop berechnet)
                    currentServiceTime = serviceTime;
                    console.log(`[SPLIT] Neue Route ${routeLetter} gestartet mit Stop ${i+1} (BAR: ${newStopWithBarFlag.bar_flag})`);
                }
            }
            
            // Letzte Route speichern - WICHTIG: BAR-Flags erhalten + R√ºckfahrt zum Depot
            if (currentRoute.length > 0) {
                // Stelle sicher, dass alle Stopps in dieser Route bar_flag haben
                const stopsWithBarFlags = currentRoute.map(s => ({
                    ...s,
                    bar_flag: s.bar_flag !== undefined ? s.bar_flag : (tour.is_bar_tour || false)
                }));
                
                // WICHTIG: Berechne R√ºckfahrt zum Depot vom letzten Stop
                let returnTimeToDepot = 0;
                const lastStop = currentRoute[currentRoute.length - 1];
                if (lastStop.lat && lastStop.lon && depotCoords) {
                    const returnDistanceKm = haversineDistance(
                        lastStop.lat, lastStop.lon,
                        depotCoords.lat, depotCoords.lon
                    ) * 1.3; // Faktor 1.3 f√ºr Stadtverkehr
                    returnTimeToDepot = (returnDistanceKm / speedKmh) * 60;
                }
                
                const totalTimeWithReturn = currentDrivingTime + currentServiceTime + returnTimeToDepot;
                
                subRoutes.push({
                    tour_id: tour.tour_id,
                    sub_route: routeLetter,
                    stops: stopsWithBarFlags,  // Stopps mit BAR-Flags
                    driving_time: currentDrivingTime,
                    service_time: currentServiceTime,
                    return_time: returnTimeToDepot,  // WICHTIG: R√ºckfahrt zum Depot
                    total_time: totalTimeWithReturn,  // WICHTIG: Inkl. R√ºckfahrt!
                    reasoning: `Automatisch gesplittet: ${routeLetter} (${currentRoute.length} Stopps, Depot ‚Üí Kunden ‚Üí Depot, ${totalTimeWithReturn.toFixed(1)} Min inkl. R√ºckfahrt)`
                });
                console.log(`[SPLIT] Finale Route ${routeLetter}: ${currentRoute.length} Stopps, ${currentDrivingTime.toFixed(1)} Min Fahrt + ${currentServiceTime.toFixed(1)} Min Service + ${returnTimeToDepot.toFixed(1)} Min R√ºckfahrt = ${totalTimeWithReturn.toFixed(1)} Min gesamt`);
            }
            
            // WICHTIG: Validierung nach Erstellen der Sub-Routen
            subRoutes.forEach(subRoute => {
                const barCount = subRoute.stops.filter(s => s.bar_flag === true).length;
                console.log(`[SPLIT] Validierung: Sub-Route ${subRoute.sub_route} hat ${barCount} BAR-Kunden von ${subRoute.stops.length} Stopps`);
                
                // Warnung wenn BAR-Kunden erwartet wurden aber fehlen
                if (tour.is_bar_tour && barCount === 0 && subRoute.stops.length > 0) {
                    console.warn(`[SPLIT] ‚ö†Ô∏è WARNUNG: Sub-Route ${subRoute.sub_route} sollte BAR-Kunden haben (Tour ist BAR-Tour), aber keiner gefunden!`);
                }
                
                // Info wenn BAR-Kunden vorhanden sind
                if (barCount > 0) {
                    const barCustomers = subRoute.stops.filter(s => s.bar_flag === true).map(s => s.name || s.customer_number || 'Unbekannt');
                    console.log(`[SPLIT] ‚úÖ Sub-Route ${subRoute.sub_route} enth√§lt BAR-Kunden: ${barCustomers.join(', ')}`);
                }
            });
            
            return subRoutes;
        }
        
        // Aktualisiere Tour-Liste mit Sub-Routen
        // Farbpalette f√ºr verschiedene Routen (jede Route bekommt eine eindeutige Farbe)
        // Hilfsfunktion: Konvertiert Buchstaben (A, B, C, ...) zu Zahlen (1, 2, 3, ...)
        function letterToNumber(letter) {
            if (!letter || letter.length === 0) return '';
            const charCode = letter.charCodeAt(0);
            if (charCode >= 65 && charCode <= 90) { // A-Z
                return (charCode - 64).toString(); // A=1, B=2, C=3, etc.
            }
            return letter; // Falls kein Buchstabe, unver√§ndert zur√ºckgeben
        }

        function getTourColor(tourId, routeIndex = null) {
            // Wenn routeIndex vorhanden ist (aus Workflow), verwende diesen f√ºr eindeutige Farbzuweisung
            if (routeIndex !== null && routeIndex !== undefined) {
                const colors = [
                    '#2196F3', // Blau
                    '#4CAF50', // Gr√ºn
                    '#FF9800', // Orange
                    '#9C27B0', // Lila
                    '#F44336', // Rot
                    '#00BCD4', // Cyan
                    '#795548', // Braun
                    '#607D8B', // Blau-Grau
                    '#E91E63', // Pink
                    '#3F51B5', // Indigo
                    '#FF5722', // Deep Orange
                    '#009688', // Teal
                    '#673AB7', // Deep Purple
                    '#CDDC39', // Lime
                    '#FFC107', // Amber
                    '#8BC34A', // Light Green
                    '#FF4081', // Pink
                    '#00E676', // Green A400
                    '#FF6D00', // Orange A700
                    '#2962FF', // Blue A700
                    '#AA00FF', // Purple A700
                    '#00BFA5', // Teal A700
                ];
                return colors[routeIndex % colors.length] || '#2196F3'; // Fallback: Blau
            }
            
            // Fallback: Extrahiere Tour-Zeit aus Tour-ID (z.B. "W-07.00" ‚Üí "07")
            const timeMatch = tourId.match(/W-(\d+)\.\d+/);
            if (timeMatch) {
                const hour = parseInt(timeMatch[1]);
                // Verschiedene Farben f√ºr verschiedene Stunden
                const colors = [
                    '#2196F3', // Blau (07:00)
                    '#4CAF50', // Gr√ºn (08:00)
                    '#FF9800', // Orange (09:00)
                    '#9C27B0', // Lila (10:00)
                    '#F44336', // Rot (11:00)
                    '#00BCD4', // Cyan (12:00)
                    '#795548', // Braun (13:00)
                    '#607D8B', // Blau-Grau (14:00)
                    '#E91E63', // Pink (15:00)
                    '#3F51B5', // Indigo (16:00)
                ];
                return colors[hour % colors.length] || '#2196F3'; // Fallback: Blau
            }
            return '#2196F3'; // Standard: Blau
        }
        
        function updateToursWithSubRoutes(subRoutes) {
            // Gruppiere nach urspr√ºnglicher Tour-ID
            const grouped = {};
            subRoutes.forEach(subRoute => {
                const key = subRoute.tour_id;
                if (!grouped[key]) {
                    grouped[key] = [];
                }
                grouped[key].push(subRoute);
            });
            
            // Aktualisiere workflowResult mit Sub-Routen
            if (workflowResult && workflowResult.tours) {
                workflowResult.tours = workflowResult.tours.map(tour => {
                    if (grouped[tour.tour_id]) {
                        // Ersetze Tour mit Sub-Routen
                        const baseTourId = tour.tour_id;
                        const tourColor = getTourColor(baseTourId);
                        
                        return grouped[baseTourId].map((sub, subIndex) => {
                            // WICHTIG: Stelle sicher, dass BAR-Flags in stops erhalten bleiben
                            const stopsWithBarFlags = sub.stops.map(stop => {
                                // BAR-Flag: Erst individuell, dann Tour-Level, dann false
                                const barFlag = stop.bar_flag !== undefined 
                                    ? !!stop.bar_flag 
                                    : (tour.is_bar_tour || false);
                                
                                return {
                                    ...stop,
                                    bar_flag: barFlag,  // WICHTIG: BAR-Flag explizit setzen
                                    // Stelle sicher, dass alle Felder vorhanden sind f√ºr renderToursFromMatch
                                    order_id: stop.order_id || stop.customer_number || '',
                                    customer_number: stop.customer_number || stop.order_id || '',
                                    customer: stop.customer || stop.name || 'Unbekannt',
                                    name: stop.name || stop.customer || 'Unbekannt',
                                    lat: stop.lat || stop.latitude,
                                    lon: stop.lon || stop.longitude,
                                    latitude: stop.latitude || stop.lat,
                                    longitude: stop.longitude || stop.lon,
                                    has_coordinates: !!(stop.lat || stop.latitude) && !!(stop.lon || stop.longitude)
                                };
                            });
                            
                            // WICHTIG: Konvertiere stops zu customers f√ºr Frontend-Anzeige und allTourCustomers
                            const customers = stopsWithBarFlags.map(stop => {
                                return {
                                    customer_number: stop.customer_number || stop.order_id || '',
                                    name: stop.name || stop.customer || 'Unbekannt',
                                    street: stop.street || '',
                                    postal_code: stop.postal_code || '',
                                    city: stop.city || '',
                                    bar_flag: stop.bar_flag,  // WICHTIG: BAR-Flag von stop √ºbernommen
                                    latitude: stop.lat || stop.latitude,
                                    longitude: stop.lon || stop.longitude,
                                    address: stop.address || (() => {
                                        const parts = [stop.street, stop.postal_code, stop.city].filter(Boolean);
                                        return parts.join(', ') || '';
                                    })(),
                                    has_coordinates: stop.has_coordinates
                                };
                            });
                            
                            // Berechne BAR-Count f√ºr diese Sub-Route
                            const barCount = customers.filter(c => c.bar_flag === true).length;
                            const hasBarCustomers = barCount > 0;
                            const tourIsBar = tour.is_bar_tour || hasBarCustomers;
                            
                            console.log(`[UPDATE-TOURS] Sub-Route ${baseTourId} ${sub.sub_route}: ${stopsWithBarFlags.length} Stops, ${barCount} BAR-Kunden`);
                            
                            return {
                                ...tour,
                                tour_id: `${baseTourId} ${sub.sub_route}`,
                                stops: stopsWithBarFlags,  // WICHTIG: F√ºr renderToursFromMatch (erwartet stops)
                                customers: customers,  // WICHTIG: F√ºr Frontend-Anzeige und allTourCustomers
                                driving_time_minutes: sub.driving_time,
                                service_time_minutes: sub.service_time,
                                return_time_minutes: sub.return_time || 0,  // WICHTIG: R√ºckfahrt zum Depot
                                total_time_minutes: sub.total_time,
                                _tour_color: tourColor, // Speichere Farbe f√ºr Rendering
                                _base_tour_id: baseTourId, // Original Tour-ID
                                _sub_route: sub.sub_route, // Sub-Route Buchstabe
                                is_bar_tour: tourIsBar,  // WICHTIG: BAR-Status basierend auf tats√§chlichen Kunden
                                bar_customer_count: barCount  // WICHTIG: Anzahl BAR-Kunden in dieser Sub-Route
                            };
                        });
                    }
                    return tour;
                }).flat();
                
                // Rendere neu
                renderToursFromMatch(workflowResult);
                saveToursToStorage();
            }
        }
        
        // Zeige Sub-Routen Generator Button wenn W-Touren oder gro√üe Touren vorhanden
        function updateSubRouteButtonVisibility() {
            const btn = document.getElementById('btnGenerateSubRoutes');
            if (!btn) return;
            
            let hasToursToOptimize = false;
            
            // Pr√ºfe workflowResult.tours
            if (workflowResult && workflowResult.tours) {
                hasToursToOptimize = workflowResult.tours.some(t => {
                    const tourId = t.tour_id || t.name || '';
                    const isWTour = /^W-\d+\.\d+/.test(tourId);
                    const stopCount = (t.stops || []).length;
                    const customerCount = (t.customers || []).length;
                    return isWTour || stopCount > 4 || customerCount > 4;
                });
            }
            
            // Fallback: allTourCustomers
            if (!hasToursToOptimize && allTourCustomers) {
                hasToursToOptimize = Object.values(allTourCustomers).some(tour => {
                    const tourName = tour.name || '';
                    const isWTour = /^W-\d+\.\d+/.test(tourName);
                    const customerCount = (tour.customers && tour.customers.length) || 0;
                    return isWTour || customerCount > 4;
                });
            }
            
            btn.style.display = hasToursToOptimize ? 'block' : 'none';
        }
        
        // ============================================
        // Panel-Funktionen (Abdockbare Fenster)
        // ============================================
        
        function openMapPanel() {
            if (mapPanelWindow && !mapPanelWindow.closed) {
                mapPanelWindow.focus();
                return;
            }
            
            const width = 1000;
            const height = 700;
            const left = (screen.width - width) / 2;
            const top = (screen.height - height) / 2;
            
            mapPanelWindow = window.open('/panel-map.html', 'mapPanel', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`);
            
            if (!mapPanelWindow) {
                alert('Popup wurde blockiert. Bitte Popup-Blocker deaktivieren.');
                return;
            }
            
            // Warte bis Panel bereit ist, dann sende Daten
            const checkReady = setInterval(() => {
                if (mapPanelWindow.closed) {
                    clearInterval(checkReady);
                    mapPanelWindow = null;
                    return;
                }
                // Sende aktuelle Karten-Daten
                syncMapToPanel();
            }, 500);
            
            // Cleanup nach 10 Sekunden
            setTimeout(() => clearInterval(checkReady), 10000);
        }
        
        function openToursPanel() {
            if (toursPanelWindow && !toursPanelWindow.closed) {
                toursPanelWindow.focus();
                return;
            }
            
            const width = 400;
            const height = 700;
            const left = screen.width - width - 50;
            const top = (screen.height - height) / 2;
            
            toursPanelWindow = window.open('/panel-tours.html', 'toursPanel', 
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`);
            
            if (!toursPanelWindow) {
                alert('Popup wurde blockiert. Bitte Popup-Blocker deaktivieren.');
                return;
            }
            
            // Warte bis Panel bereit ist, dann sende Daten
            const checkReady = setInterval(() => {
                if (toursPanelWindow.closed) {
                    clearInterval(checkReady);
                    toursPanelWindow = null;
                    return;
                }
                // Sende aktuelle Tour-Daten
                syncToursToPanel();
            }, 500);
            
            // Cleanup nach 10 Sekunden
            setTimeout(() => clearInterval(checkReady), 10000);
        }
        
        function syncMapToPanel() {
            if (!mapPanelWindow || mapPanelWindow.closed || !window.panelIPC) return;
            
            // Sammle Route-Daten
            const routes = [];
            const markers = [];
            const bounds = [];
            
            // Route-Linien
            tourRouteLines.forEach((line, index) => {
                const latlngs = line.getLatLngs();
                if (latlngs && latlngs.length > 0) {
                    // Konvertiere zu Polyline6 (vereinfacht - in Produktion sollte echte Geometrie verwendet werden)
                    const color = line.options.color || '#3388ff';
                    routes.push({
                        geometry: null, // Wird sp√§ter aus Route-Details geladen
                        color: color,
                        geometry_type: 'polyline6'
                    });
                }
            });
            
            // Marker
            tourMarkers.forEach(marker => {
                const latlng = marker.getLatLng();
                markers.push({
                    lat: latlng.lat,
                    lon: latlng.lng,
                    name: marker.options.title || marker._popup?.content || 'Unbekannt',
                    color: marker.options.color || '#3388ff'
                });
                bounds.push([latlng.lat, latlng.lng]);
            });
            
            // Sende an Panel
            if (map && bounds.length > 0) {
                const mapBounds = map.getBounds();
                window.panelIPC.postMessage('route-update', {
                    routes: routes,
                    markers: markers,
                    bounds: [[mapBounds.getSouth(), mapBounds.getWest()], [mapBounds.getNorth(), mapBounds.getEast()]]
                });
            }
        }
        
        function syncToursToPanel() {
            if (!toursPanelWindow || toursPanelWindow.closed || !window.panelIPC) return;
            
            // Konvertiere allTourCustomers zu Panel-Format
            const tours = Object.entries(allTourCustomers).map(([key, tour]) => {
                const customers = tour.customers || [];
                return {
                    key: key,
                    name: tour.name || 'Unbekannte Tour',
                    stops: customers.length,
                    distance: 0, // Wird sp√§ter aus Route-Details geladen
                    duration: 0
                };
            });
            
            window.panelIPC.postMessage('tours-update', {
                tours: tours,
                activeTourKey: activeTourKey
            });
        }
        
        // IPC-Handler f√ºr Panel-Kommunikation
        if (window.panelIPC) {
            window.panelIPC.on('panel-ready', (data) => {
                console.log('Panel bereit:', data);
                if (data.type === 'map') {
                    syncMapToPanel();
                } else if (data.type === 'tours') {
                    syncToursToPanel();
                }
            });
            
            window.panelIPC.on('tour-selected', (data) => {
                if (data.tourKey && allTourCustomers[data.tourKey]) {
                    selectTour(data.tourKey);
                }
            });
            
            window.panelIPC.on('panel-closed', (data) => {
                if (data.type === 'map') {
                    mapPanelWindow = null;
                } else if (data.type === 'tours') {
                    toursPanelWindow = null;
                }
            });
        }
        
        // Synchronisiere Daten bei √Ñnderungen
        const originalRenderTours = window.renderToursFromWorkflow;
        if (originalRenderTours) {
            window.renderToursFromWorkflow = function(...args) {
                originalRenderTours.apply(this, args);
                syncMapToPanel();
                syncToursToPanel();
            };
        }
    </script>
</body>
</html>
